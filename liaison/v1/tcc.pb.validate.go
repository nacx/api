// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: tcc.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Metadata) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for Tag

	return nil
}

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on LoadBalancer with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *LoadBalancer) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadBalancerValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPorts() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerValidationError{
					field:  fmt.Sprintf("Ports[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// LoadBalancerValidationError is the validation error returned by
// LoadBalancer.Validate if the designated constraints aren't met.
type LoadBalancerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerValidationError) ErrorName() string { return "LoadBalancerValidationError" }

// Error satisfies the builtin error interface
func (e LoadBalancerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerValidationError{}

// Validate checks the field values on LBPort with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *LBPort) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Port

	// no validation rules for Protocol

	// no validation rules for IsSecure

	return nil
}

// LBPortValidationError is the validation error returned by LBPort.Validate if
// the designated constraints aren't met.
type LBPortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LBPortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LBPortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LBPortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LBPortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LBPortValidationError) ErrorName() string { return "LBPortValidationError" }

// Error satisfies the builtin error interface
func (e LBPortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLBPort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LBPortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LBPortValidationError{}

// Validate checks the field values on Service with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Service) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hostname

	// no validation rules for Port

	// no validation rules for Protocol

	if v, ok := interface{}(m.GetTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetHttpRequestTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceValidationError{
				field:  "HttpRequestTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetHttpRules() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceValidationError{
					field:  fmt.Sprintf("HttpRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ServiceValidationError is the validation error returned by Service.Validate
// if the designated constraints aren't met.
type ServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceValidationError) ErrorName() string { return "ServiceValidationError" }

// Error satisfies the builtin error interface
func (e ServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceValidationError{}

// Validate checks the field values on HttpRuleOrId with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *HttpRuleOrId) Validate() error {
	if m == nil {
		return nil
	}

	switch m.ObjOrId.(type) {

	case *HttpRuleOrId_Id:
		// no validation rules for Id

	case *HttpRuleOrId_HttpRule:

		if v, ok := interface{}(m.GetHttpRule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpRuleOrIdValidationError{
					field:  "HttpRule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// HttpRuleOrIdValidationError is the validation error returned by
// HttpRuleOrId.Validate if the designated constraints aren't met.
type HttpRuleOrIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpRuleOrIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpRuleOrIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpRuleOrIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpRuleOrIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpRuleOrIdValidationError) ErrorName() string { return "HttpRuleOrIdValidationError" }

// Error satisfies the builtin error interface
func (e HttpRuleOrIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpRuleOrId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpRuleOrIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpRuleOrIdValidationError{}

// Validate checks the field values on HttpRule with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *HttpRule) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpRuleValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetMatchProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpRuleValidationError{
				field:  "MatchProgram",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetModifyProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpRuleValidationError{
				field:  "ModifyProgram",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.RouteOrRedirect.(type) {

	case *HttpRule_Route:

		if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpRuleValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *HttpRule_Redirect:

		if v, ok := interface{}(m.GetRedirect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpRuleValidationError{
					field:  "Redirect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// HttpRuleValidationError is the validation error returned by
// HttpRule.Validate if the designated constraints aren't met.
type HttpRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpRuleValidationError) ErrorName() string { return "HttpRuleValidationError" }

// Error satisfies the builtin error interface
func (e HttpRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpRuleValidationError{}

// Validate checks the field values on MatchProgramOrId with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *MatchProgramOrId) Validate() error {
	if m == nil {
		return nil
	}

	switch m.ObjOrId.(type) {

	case *MatchProgramOrId_Id:
		// no validation rules for Id

	case *MatchProgramOrId_Program:

		if v, ok := interface{}(m.GetProgram()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchProgramOrIdValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// MatchProgramOrIdValidationError is the validation error returned by
// MatchProgramOrId.Validate if the designated constraints aren't met.
type MatchProgramOrIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchProgramOrIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchProgramOrIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchProgramOrIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchProgramOrIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchProgramOrIdValidationError) ErrorName() string { return "MatchProgramOrIdValidationError" }

// Error satisfies the builtin error interface
func (e MatchProgramOrIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchProgramOrId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchProgramOrIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchProgramOrIdValidationError{}

// Validate checks the field values on HttpMatchProgram with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *HttpMatchProgram) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpMatchProgramValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExpressions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HttpMatchProgramValidationError{
					field:  fmt.Sprintf("Expressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// HttpMatchProgramValidationError is the validation error returned by
// HttpMatchProgram.Validate if the designated constraints aren't met.
type HttpMatchProgramValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpMatchProgramValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpMatchProgramValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpMatchProgramValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpMatchProgramValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpMatchProgramValidationError) ErrorName() string { return "HttpMatchProgramValidationError" }

// Error satisfies the builtin error interface
func (e HttpMatchProgramValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpMatchProgram.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpMatchProgramValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpMatchProgramValidationError{}

// Validate checks the field values on HttpMatchExpression with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *HttpMatchExpression) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetUri()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpMatchExpressionValidationError{
				field:  "Uri",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetScheme()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpMatchExpressionValidationError{
				field:  "Scheme",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetMethod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpMatchExpressionValidationError{
				field:  "Method",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HttpMatchExpressionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Headers

	return nil
}

// HttpMatchExpressionValidationError is the validation error returned by
// HttpMatchExpression.Validate if the designated constraints aren't met.
type HttpMatchExpressionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HttpMatchExpressionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HttpMatchExpressionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HttpMatchExpressionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HttpMatchExpressionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HttpMatchExpressionValidationError) ErrorName() string {
	return "HttpMatchExpressionValidationError"
}

// Error satisfies the builtin error interface
func (e HttpMatchExpressionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHttpMatchExpression.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HttpMatchExpressionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HttpMatchExpressionValidationError{}

// Validate checks the field values on StringMatch with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *StringMatch) Validate() error {
	if m == nil {
		return nil
	}

	switch m.MatchType.(type) {

	case *StringMatch_Exact:
		// no validation rules for Exact

	case *StringMatch_Prefix:
		// no validation rules for Prefix

	case *StringMatch_Regex:
		// no validation rules for Regex

	}

	return nil
}

// StringMatchValidationError is the validation error returned by
// StringMatch.Validate if the designated constraints aren't met.
type StringMatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringMatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringMatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringMatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringMatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringMatchValidationError) ErrorName() string { return "StringMatchValidationError" }

// Error satisfies the builtin error interface
func (e StringMatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringMatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringMatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringMatchValidationError{}

// Validate checks the field values on ModifyProgramOrId with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *ModifyProgramOrId) Validate() error {
	if m == nil {
		return nil
	}

	switch m.ObjOrId.(type) {

	case *ModifyProgramOrId_Id:
		// no validation rules for Id

	case *ModifyProgramOrId_Program:

		if v, ok := interface{}(m.GetProgram()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyProgramOrIdValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ModifyProgramOrIdValidationError is the validation error returned by
// ModifyProgramOrId.Validate if the designated constraints aren't met.
type ModifyProgramOrIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModifyProgramOrIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModifyProgramOrIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModifyProgramOrIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModifyProgramOrIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModifyProgramOrIdValidationError) ErrorName() string {
	return "ModifyProgramOrIdValidationError"
}

// Error satisfies the builtin error interface
func (e ModifyProgramOrIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModifyProgramOrId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModifyProgramOrIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModifyProgramOrIdValidationError{}

// Validate checks the field values on ModifyProgram with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *ModifyProgram) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModifyProgramValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetModify() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyProgramValidationError{
					field:  fmt.Sprintf("Modify[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ModifyProgramValidationError is the validation error returned by
// ModifyProgram.Validate if the designated constraints aren't met.
type ModifyProgramValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModifyProgramValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModifyProgramValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModifyProgramValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModifyProgramValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModifyProgramValidationError) ErrorName() string { return "ModifyProgramValidationError" }

// Error satisfies the builtin error interface
func (e ModifyProgramValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModifyProgram.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModifyProgramValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModifyProgramValidationError{}

// Validate checks the field values on Modify with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Modify) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for What

	// no validation rules for How

	// no validation rules for HeaderName

	// no validation rules for Value

	return nil
}

// ModifyValidationError is the validation error returned by Modify.Validate if
// the designated constraints aren't met.
type ModifyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModifyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModifyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModifyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModifyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModifyValidationError) ErrorName() string { return "ModifyValidationError" }

// Error satisfies the builtin error interface
func (e ModifyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModify.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModifyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModifyValidationError{}

// Validate checks the field values on Route with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Route) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetDestinations() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  fmt.Sprintf("Destinations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// RouteValidationError is the validation error returned by Route.Validate if
// the designated constraints aren't met.
type RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouteValidationError) ErrorName() string { return "RouteValidationError" }

// Error satisfies the builtin error interface
func (e RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouteValidationError{}

// Validate checks the field values on Redirect with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Redirect) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Uri

	// no validation rules for Authority

	return nil
}

// RedirectValidationError is the validation error returned by
// Redirect.Validate if the designated constraints aren't met.
type RedirectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RedirectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RedirectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RedirectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RedirectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RedirectValidationError) ErrorName() string { return "RedirectValidationError" }

// Error satisfies the builtin error interface
func (e RedirectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRedirect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RedirectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RedirectValidationError{}

// Validate checks the field values on TLSSettingsOrId with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *TLSSettingsOrId) Validate() error {
	if m == nil {
		return nil
	}

	switch m.ObjOrId.(type) {

	case *TLSSettingsOrId_Id:
		// no validation rules for Id

	case *TLSSettingsOrId_TlsSettings:

		if v, ok := interface{}(m.GetTlsSettings()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TLSSettingsOrIdValidationError{
					field:  "TlsSettings",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// TLSSettingsOrIdValidationError is the validation error returned by
// TLSSettingsOrId.Validate if the designated constraints aren't met.
type TLSSettingsOrIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSSettingsOrIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSSettingsOrIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSSettingsOrIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSSettingsOrIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSSettingsOrIdValidationError) ErrorName() string { return "TLSSettingsOrIdValidationError" }

// Error satisfies the builtin error interface
func (e TLSSettingsOrIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSSettingsOrId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSSettingsOrIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSSettingsOrIdValidationError{}

// Validate checks the field values on TLSSettings with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *TLSSettings) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSSettingsValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServerCertificate

	// no validation rules for PrivateKey

	// no validation rules for CaCertificates

	// no validation rules for SecretName

	return nil
}

// TLSSettingsValidationError is the validation error returned by
// TLSSettings.Validate if the designated constraints aren't met.
type TLSSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSSettingsValidationError) ErrorName() string { return "TLSSettingsValidationError" }

// Error satisfies the builtin error interface
func (e TLSSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSSettingsValidationError{}

// Validate checks the field values on Route_Destination with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *Route_Destination) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Host

	// no validation rules for Subset

	// no validation rules for Port

	// no validation rules for Weight

	return nil
}

// Route_DestinationValidationError is the validation error returned by
// Route_Destination.Validate if the designated constraints aren't met.
type Route_DestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Route_DestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Route_DestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Route_DestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Route_DestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Route_DestinationValidationError) ErrorName() string {
	return "Route_DestinationValidationError"
}

// Error satisfies the builtin error interface
func (e Route_DestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoute_Destination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Route_DestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Route_DestinationValidationError{}
