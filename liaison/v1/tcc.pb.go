// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tcc.proto

package v1 // import "github.com/tetrateio/tetrate/api/liaison/v1"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import duration "github.com/golang/protobuf/ptypes/duration"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Modify_What int32

const (
	Modify_URI       Modify_What = 0
	Modify_AUTHORITY Modify_What = 1
	Modify_HEADER    Modify_What = 2
)

var Modify_What_name = map[int32]string{
	0: "URI",
	1: "AUTHORITY",
	2: "HEADER",
}
var Modify_What_value = map[string]int32{
	"URI":       0,
	"AUTHORITY": 1,
	"HEADER":    2,
}

func (x Modify_What) String() string {
	return proto.EnumName(Modify_What_name, int32(x))
}
func (Modify_What) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{12, 0}
}

type Modify_How int32

const (
	// this is the only value allowed for uri and authority rewrite
	Modify_SET Modify_How = 0
	// append and delete are applicable only for headers
	Modify_APPEND Modify_How = 1
	Modify_DELETE Modify_How = 2
)

var Modify_How_name = map[int32]string{
	0: "SET",
	1: "APPEND",
	2: "DELETE",
}
var Modify_How_value = map[string]int32{
	"SET":    0,
	"APPEND": 1,
	"DELETE": 2,
}

func (x Modify_How) String() string {
	return proto.EnumName(Modify_How_name, int32(x))
}
func (Modify_How) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{12, 1}
}

// Lookup objects associated with each construct
type Metadata struct {
	// Used for lookups
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// This is arbitrary key-value pairs used for querying
	Tag                  map[string]string `protobuf:"bytes,3,rep,name=tag,proto3" json:"tag,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{0}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (dst *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(dst, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Metadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Metadata) GetTag() map[string]string {
	if m != nil {
		return m.Tag
	}
	return nil
}

// Configuration of a Load balancer
// a load balancer is composed of multiple ports
// The network administrator attaches one or more services to each port
type LoadBalancer struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Ports    []*LBPort `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	// This is a temporary hack until we figure out the workflow processes and UI related stuff.
	// Until then we figure out the load balancer ports from the service_ids itself.
	// In the UI, this corresponds to a user clicking on a load balancer and adding one or more
	// hosts within that load balancer.
	Services             []*Service `protobuf:"bytes,3,rep,name=services,proto3" json:"services,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LoadBalancer) Reset()         { *m = LoadBalancer{} }
func (m *LoadBalancer) String() string { return proto.CompactTextString(m) }
func (*LoadBalancer) ProtoMessage()    {}
func (*LoadBalancer) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{1}
}
func (m *LoadBalancer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadBalancer.Unmarshal(m, b)
}
func (m *LoadBalancer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadBalancer.Marshal(b, m, deterministic)
}
func (dst *LoadBalancer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancer.Merge(dst, src)
}
func (m *LoadBalancer) XXX_Size() int {
	return xxx_messageInfo_LoadBalancer.Size(m)
}
func (m *LoadBalancer) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancer.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancer proto.InternalMessageInfo

func (m *LoadBalancer) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *LoadBalancer) GetPorts() []*LBPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *LoadBalancer) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type LBPort struct {
	Port     uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// if set to true, indicates that TLS settings should be applied
	// to the server on this port
	IsSecure bool `protobuf:"varint,3,opt,name=is_secure,json=isSecure,proto3" json:"is_secure,omitempty"`
	// Should there be a common tls settings here?
	// set of services exposed on this port
	ServiceIds           []string `protobuf:"bytes,4,rep,name=service_ids,json=serviceIds,proto3" json:"service_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LBPort) Reset()         { *m = LBPort{} }
func (m *LBPort) String() string { return proto.CompactTextString(m) }
func (*LBPort) ProtoMessage()    {}
func (*LBPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{2}
}
func (m *LBPort) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LBPort.Unmarshal(m, b)
}
func (m *LBPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LBPort.Marshal(b, m, deterministic)
}
func (dst *LBPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LBPort.Merge(dst, src)
}
func (m *LBPort) XXX_Size() int {
	return xxx_messageInfo_LBPort.Size(m)
}
func (m *LBPort) XXX_DiscardUnknown() {
	xxx_messageInfo_LBPort.DiscardUnknown(m)
}

var xxx_messageInfo_LBPort proto.InternalMessageInfo

func (m *LBPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *LBPort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *LBPort) GetIsSecure() bool {
	if m != nil {
		return m.IsSecure
	}
	return false
}

func (m *LBPort) GetServiceIds() []string {
	if m != nil {
		return m.ServiceIds
	}
	return nil
}

// Service describes the properties of a service
type Service struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Hostname string    `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port     uint32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// HTTP/HTTPS/TCP/Secure TCP
	// UI should show TLS settings if protocol is HTTPS or secure TCP
	Protocol string `protobuf:"bytes,4,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// We assume that this is a HTTP based service. TLS settings if
	// specified will result in TLS termination depending on the LB port
	// to which this service is assigned.
	Tls *TLSSettingsOrId `protobuf:"bytes,5,opt,name=tls,proto3" json:"tls,omitempty"`
	// Timeout for HTTP requests made to backends of this service
	HttpRequestTimeout   *duration.Duration `protobuf:"bytes,6,opt,name=http_request_timeout,json=httpRequestTimeout,proto3" json:"http_request_timeout,omitempty"`
	HttpRules            []*HttpRuleOrId    `protobuf:"bytes,7,rep,name=http_rules,json=httpRules,proto3" json:"http_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{3}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Service.Unmarshal(m, b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Service.Marshal(b, m, deterministic)
}
func (dst *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(dst, src)
}
func (m *Service) XXX_Size() int {
	return xxx_messageInfo_Service.Size(m)
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Service) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Service) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Service) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Service) GetTls() *TLSSettingsOrId {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *Service) GetHttpRequestTimeout() *duration.Duration {
	if m != nil {
		return m.HttpRequestTimeout
	}
	return nil
}

func (m *Service) GetHttpRules() []*HttpRuleOrId {
	if m != nil {
		return m.HttpRules
	}
	return nil
}

type HttpRuleOrId struct {
	// Types that are valid to be assigned to ObjOrId:
	//	*HttpRuleOrId_Id
	//	*HttpRuleOrId_HttpRule
	ObjOrId              isHttpRuleOrId_ObjOrId `protobuf_oneof:"obj_or_id"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *HttpRuleOrId) Reset()         { *m = HttpRuleOrId{} }
func (m *HttpRuleOrId) String() string { return proto.CompactTextString(m) }
func (*HttpRuleOrId) ProtoMessage()    {}
func (*HttpRuleOrId) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{4}
}
func (m *HttpRuleOrId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpRuleOrId.Unmarshal(m, b)
}
func (m *HttpRuleOrId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpRuleOrId.Marshal(b, m, deterministic)
}
func (dst *HttpRuleOrId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRuleOrId.Merge(dst, src)
}
func (m *HttpRuleOrId) XXX_Size() int {
	return xxx_messageInfo_HttpRuleOrId.Size(m)
}
func (m *HttpRuleOrId) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRuleOrId.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRuleOrId proto.InternalMessageInfo

type isHttpRuleOrId_ObjOrId interface {
	isHttpRuleOrId_ObjOrId()
}

type HttpRuleOrId_Id struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3,oneof"`
}

type HttpRuleOrId_HttpRule struct {
	HttpRule *HttpRule `protobuf:"bytes,2,opt,name=http_rule,json=httpRule,proto3,oneof"`
}

func (*HttpRuleOrId_Id) isHttpRuleOrId_ObjOrId() {}

func (*HttpRuleOrId_HttpRule) isHttpRuleOrId_ObjOrId() {}

func (m *HttpRuleOrId) GetObjOrId() isHttpRuleOrId_ObjOrId {
	if m != nil {
		return m.ObjOrId
	}
	return nil
}

func (m *HttpRuleOrId) GetId() string {
	if x, ok := m.GetObjOrId().(*HttpRuleOrId_Id); ok {
		return x.Id
	}
	return ""
}

func (m *HttpRuleOrId) GetHttpRule() *HttpRule {
	if x, ok := m.GetObjOrId().(*HttpRuleOrId_HttpRule); ok {
		return x.HttpRule
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpRuleOrId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpRuleOrId_OneofMarshaler, _HttpRuleOrId_OneofUnmarshaler, _HttpRuleOrId_OneofSizer, []interface{}{
		(*HttpRuleOrId_Id)(nil),
		(*HttpRuleOrId_HttpRule)(nil),
	}
}

func _HttpRuleOrId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpRuleOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *HttpRuleOrId_Id:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Id)
	case *HttpRuleOrId_HttpRule:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpRule); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpRuleOrId.ObjOrId has unexpected type %T", x)
	}
	return nil
}

func _HttpRuleOrId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpRuleOrId)
	switch tag {
	case 1: // obj_or_id.id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ObjOrId = &HttpRuleOrId_Id{x}
		return true, err
	case 2: // obj_or_id.http_rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpRule)
		err := b.DecodeMessage(msg)
		m.ObjOrId = &HttpRuleOrId_HttpRule{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpRuleOrId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpRuleOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *HttpRuleOrId_Id:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *HttpRuleOrId_HttpRule:
		s := proto.Size(x.HttpRule)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A single HTTP rule
type HttpRule struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// one or more match conditions (OR-ed)
	MatchProgram *MatchProgramOrId `protobuf:"bytes,2,opt,name=match_program,json=matchProgram,proto3" json:"match_program,omitempty"`
	// one or more mutations to be performed
	ModifyProgram *ModifyProgramOrId `protobuf:"bytes,3,opt,name=modify_program,json=modifyProgram,proto3" json:"modify_program,omitempty"`
	// Types that are valid to be assigned to RouteOrRedirect:
	//	*HttpRule_Route
	//	*HttpRule_Redirect
	RouteOrRedirect      isHttpRule_RouteOrRedirect `protobuf_oneof:"route_or_redirect"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *HttpRule) Reset()         { *m = HttpRule{} }
func (m *HttpRule) String() string { return proto.CompactTextString(m) }
func (*HttpRule) ProtoMessage()    {}
func (*HttpRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{5}
}
func (m *HttpRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpRule.Unmarshal(m, b)
}
func (m *HttpRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpRule.Marshal(b, m, deterministic)
}
func (dst *HttpRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRule.Merge(dst, src)
}
func (m *HttpRule) XXX_Size() int {
	return xxx_messageInfo_HttpRule.Size(m)
}
func (m *HttpRule) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRule.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRule proto.InternalMessageInfo

func (m *HttpRule) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HttpRule) GetMatchProgram() *MatchProgramOrId {
	if m != nil {
		return m.MatchProgram
	}
	return nil
}

func (m *HttpRule) GetModifyProgram() *ModifyProgramOrId {
	if m != nil {
		return m.ModifyProgram
	}
	return nil
}

type isHttpRule_RouteOrRedirect interface {
	isHttpRule_RouteOrRedirect()
}

type HttpRule_Route struct {
	Route *Route `protobuf:"bytes,4,opt,name=route,proto3,oneof"`
}

type HttpRule_Redirect struct {
	Redirect *Redirect `protobuf:"bytes,5,opt,name=redirect,proto3,oneof"`
}

func (*HttpRule_Route) isHttpRule_RouteOrRedirect() {}

func (*HttpRule_Redirect) isHttpRule_RouteOrRedirect() {}

func (m *HttpRule) GetRouteOrRedirect() isHttpRule_RouteOrRedirect {
	if m != nil {
		return m.RouteOrRedirect
	}
	return nil
}

func (m *HttpRule) GetRoute() *Route {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Route); ok {
		return x.Route
	}
	return nil
}

func (m *HttpRule) GetRedirect() *Redirect {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Redirect); ok {
		return x.Redirect
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpRule_OneofMarshaler, _HttpRule_OneofUnmarshaler, _HttpRule_OneofSizer, []interface{}{
		(*HttpRule_Route)(nil),
		(*HttpRule_Redirect)(nil),
	}
}

func _HttpRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpRule)
	// route_or_redirect
	switch x := m.RouteOrRedirect.(type) {
	case *HttpRule_Route:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case *HttpRule_Redirect:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Redirect); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpRule.RouteOrRedirect has unexpected type %T", x)
	}
	return nil
}

func _HttpRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpRule)
	switch tag {
	case 4: // route_or_redirect.route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Route)
		err := b.DecodeMessage(msg)
		m.RouteOrRedirect = &HttpRule_Route{msg}
		return true, err
	case 5: // route_or_redirect.redirect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Redirect)
		err := b.DecodeMessage(msg)
		m.RouteOrRedirect = &HttpRule_Redirect{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpRule)
	// route_or_redirect
	switch x := m.RouteOrRedirect.(type) {
	case *HttpRule_Route:
		s := proto.Size(x.Route)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpRule_Redirect:
		s := proto.Size(x.Redirect)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MatchProgramOrId struct {
	// Types that are valid to be assigned to ObjOrId:
	//	*MatchProgramOrId_Id
	//	*MatchProgramOrId_Program
	ObjOrId              isMatchProgramOrId_ObjOrId `protobuf_oneof:"obj_or_id"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *MatchProgramOrId) Reset()         { *m = MatchProgramOrId{} }
func (m *MatchProgramOrId) String() string { return proto.CompactTextString(m) }
func (*MatchProgramOrId) ProtoMessage()    {}
func (*MatchProgramOrId) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{6}
}
func (m *MatchProgramOrId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchProgramOrId.Unmarshal(m, b)
}
func (m *MatchProgramOrId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchProgramOrId.Marshal(b, m, deterministic)
}
func (dst *MatchProgramOrId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchProgramOrId.Merge(dst, src)
}
func (m *MatchProgramOrId) XXX_Size() int {
	return xxx_messageInfo_MatchProgramOrId.Size(m)
}
func (m *MatchProgramOrId) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchProgramOrId.DiscardUnknown(m)
}

var xxx_messageInfo_MatchProgramOrId proto.InternalMessageInfo

type isMatchProgramOrId_ObjOrId interface {
	isMatchProgramOrId_ObjOrId()
}

type MatchProgramOrId_Id struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3,oneof"`
}

type MatchProgramOrId_Program struct {
	Program *HttpMatchProgram `protobuf:"bytes,2,opt,name=program,proto3,oneof"`
}

func (*MatchProgramOrId_Id) isMatchProgramOrId_ObjOrId() {}

func (*MatchProgramOrId_Program) isMatchProgramOrId_ObjOrId() {}

func (m *MatchProgramOrId) GetObjOrId() isMatchProgramOrId_ObjOrId {
	if m != nil {
		return m.ObjOrId
	}
	return nil
}

func (m *MatchProgramOrId) GetId() string {
	if x, ok := m.GetObjOrId().(*MatchProgramOrId_Id); ok {
		return x.Id
	}
	return ""
}

func (m *MatchProgramOrId) GetProgram() *HttpMatchProgram {
	if x, ok := m.GetObjOrId().(*MatchProgramOrId_Program); ok {
		return x.Program
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MatchProgramOrId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MatchProgramOrId_OneofMarshaler, _MatchProgramOrId_OneofUnmarshaler, _MatchProgramOrId_OneofSizer, []interface{}{
		(*MatchProgramOrId_Id)(nil),
		(*MatchProgramOrId_Program)(nil),
	}
}

func _MatchProgramOrId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MatchProgramOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *MatchProgramOrId_Id:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Id)
	case *MatchProgramOrId_Program:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Program); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MatchProgramOrId.ObjOrId has unexpected type %T", x)
	}
	return nil
}

func _MatchProgramOrId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MatchProgramOrId)
	switch tag {
	case 1: // obj_or_id.id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ObjOrId = &MatchProgramOrId_Id{x}
		return true, err
	case 2: // obj_or_id.program
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpMatchProgram)
		err := b.DecodeMessage(msg)
		m.ObjOrId = &MatchProgramOrId_Program{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MatchProgramOrId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MatchProgramOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *MatchProgramOrId_Id:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *MatchProgramOrId_Program:
		s := proto.Size(x.Program)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A program for lack of better name has one or more match expressions
// if any one of them match, the Http rule will apply
type HttpMatchProgram struct {
	Metadata             *Metadata              `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Expressions          []*HttpMatchExpression `protobuf:"bytes,2,rep,name=expressions,proto3" json:"expressions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *HttpMatchProgram) Reset()         { *m = HttpMatchProgram{} }
func (m *HttpMatchProgram) String() string { return proto.CompactTextString(m) }
func (*HttpMatchProgram) ProtoMessage()    {}
func (*HttpMatchProgram) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{7}
}
func (m *HttpMatchProgram) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpMatchProgram.Unmarshal(m, b)
}
func (m *HttpMatchProgram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpMatchProgram.Marshal(b, m, deterministic)
}
func (dst *HttpMatchProgram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMatchProgram.Merge(dst, src)
}
func (m *HttpMatchProgram) XXX_Size() int {
	return xxx_messageInfo_HttpMatchProgram.Size(m)
}
func (m *HttpMatchProgram) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMatchProgram.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMatchProgram proto.InternalMessageInfo

func (m *HttpMatchProgram) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HttpMatchProgram) GetExpressions() []*HttpMatchExpression {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// A single match clause to match all aspects of a request
type HttpMatchExpression struct {
	// URI to match
	Uri *StringMatch `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// URI Scheme
	Scheme *StringMatch `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// HTTP Method
	Method *StringMatch `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	// HTTP Authority
	Authority *StringMatch `protobuf:"bytes,4,opt,name=authority,proto3" json:"authority,omitempty"`
	// The header keys must be lowercase and use hyphen as the separator,
	// e.g. _x-request-id_.
	Headers              map[string]*StringMatch `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HttpMatchExpression) Reset()         { *m = HttpMatchExpression{} }
func (m *HttpMatchExpression) String() string { return proto.CompactTextString(m) }
func (*HttpMatchExpression) ProtoMessage()    {}
func (*HttpMatchExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{8}
}
func (m *HttpMatchExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpMatchExpression.Unmarshal(m, b)
}
func (m *HttpMatchExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpMatchExpression.Marshal(b, m, deterministic)
}
func (dst *HttpMatchExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMatchExpression.Merge(dst, src)
}
func (m *HttpMatchExpression) XXX_Size() int {
	return xxx_messageInfo_HttpMatchExpression.Size(m)
}
func (m *HttpMatchExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMatchExpression.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMatchExpression proto.InternalMessageInfo

func (m *HttpMatchExpression) GetUri() *StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func (m *HttpMatchExpression) GetScheme() *StringMatch {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *HttpMatchExpression) GetMethod() *StringMatch {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *HttpMatchExpression) GetAuthority() *StringMatch {
	if m != nil {
		return m.Authority
	}
	return nil
}

func (m *HttpMatchExpression) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Describes how to match a given string in HTTP headers. Match is
// case-sensitive.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StringMatch) Reset()         { *m = StringMatch{} }
func (m *StringMatch) String() string { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()    {}
func (*StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{9}
}
func (m *StringMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StringMatch.Unmarshal(m, b)
}
func (m *StringMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StringMatch.Marshal(b, m, deterministic)
}
func (dst *StringMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatch.Merge(dst, src)
}
func (m *StringMatch) XXX_Size() int {
	return xxx_messageInfo_StringMatch.Size(m)
}
func (m *StringMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatch.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatch proto.InternalMessageInfo

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof"`
}

type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof"`
}

type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType() {}

func (*StringMatch_Prefix) isStringMatch_MatchType() {}

func (*StringMatch_Regex) isStringMatch_MatchType() {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringMatch_OneofMarshaler, _StringMatch_OneofUnmarshaler, _StringMatch_OneofSizer, []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

func _StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case *StringMatch_Regex:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("StringMatch.MatchType has unexpected type %T", x)
	}
	return nil
}

func _StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringMatch)
	switch tag {
	case 1: // match_type.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Exact{x}
		return true, err
	case 2: // match_type.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Prefix{x}
		return true, err
	case 3: // match_type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *StringMatch_Prefix:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *StringMatch_Regex:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ModifyProgramOrId struct {
	// Types that are valid to be assigned to ObjOrId:
	//	*ModifyProgramOrId_Id
	//	*ModifyProgramOrId_Program
	ObjOrId              isModifyProgramOrId_ObjOrId `protobuf_oneof:"obj_or_id"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ModifyProgramOrId) Reset()         { *m = ModifyProgramOrId{} }
func (m *ModifyProgramOrId) String() string { return proto.CompactTextString(m) }
func (*ModifyProgramOrId) ProtoMessage()    {}
func (*ModifyProgramOrId) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{10}
}
func (m *ModifyProgramOrId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModifyProgramOrId.Unmarshal(m, b)
}
func (m *ModifyProgramOrId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModifyProgramOrId.Marshal(b, m, deterministic)
}
func (dst *ModifyProgramOrId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProgramOrId.Merge(dst, src)
}
func (m *ModifyProgramOrId) XXX_Size() int {
	return xxx_messageInfo_ModifyProgramOrId.Size(m)
}
func (m *ModifyProgramOrId) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProgramOrId.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProgramOrId proto.InternalMessageInfo

type isModifyProgramOrId_ObjOrId interface {
	isModifyProgramOrId_ObjOrId()
}

type ModifyProgramOrId_Id struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3,oneof"`
}

type ModifyProgramOrId_Program struct {
	Program *ModifyProgram `protobuf:"bytes,2,opt,name=program,proto3,oneof"`
}

func (*ModifyProgramOrId_Id) isModifyProgramOrId_ObjOrId() {}

func (*ModifyProgramOrId_Program) isModifyProgramOrId_ObjOrId() {}

func (m *ModifyProgramOrId) GetObjOrId() isModifyProgramOrId_ObjOrId {
	if m != nil {
		return m.ObjOrId
	}
	return nil
}

func (m *ModifyProgramOrId) GetId() string {
	if x, ok := m.GetObjOrId().(*ModifyProgramOrId_Id); ok {
		return x.Id
	}
	return ""
}

func (m *ModifyProgramOrId) GetProgram() *ModifyProgram {
	if x, ok := m.GetObjOrId().(*ModifyProgramOrId_Program); ok {
		return x.Program
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ModifyProgramOrId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ModifyProgramOrId_OneofMarshaler, _ModifyProgramOrId_OneofUnmarshaler, _ModifyProgramOrId_OneofSizer, []interface{}{
		(*ModifyProgramOrId_Id)(nil),
		(*ModifyProgramOrId_Program)(nil),
	}
}

func _ModifyProgramOrId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ModifyProgramOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *ModifyProgramOrId_Id:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Id)
	case *ModifyProgramOrId_Program:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Program); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ModifyProgramOrId.ObjOrId has unexpected type %T", x)
	}
	return nil
}

func _ModifyProgramOrId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ModifyProgramOrId)
	switch tag {
	case 1: // obj_or_id.id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ObjOrId = &ModifyProgramOrId_Id{x}
		return true, err
	case 2: // obj_or_id.program
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ModifyProgram)
		err := b.DecodeMessage(msg)
		m.ObjOrId = &ModifyProgramOrId_Program{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ModifyProgramOrId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ModifyProgramOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *ModifyProgramOrId_Id:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *ModifyProgramOrId_Program:
		s := proto.Size(x.Program)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// All modifications to be done on a single request
// like URL rewrite, host rewrite, headers to add/remove/append
type ModifyProgram struct {
	Metadata             *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Modify               []*Modify `protobuf:"bytes,2,rep,name=modify,proto3" json:"modify,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ModifyProgram) Reset()         { *m = ModifyProgram{} }
func (m *ModifyProgram) String() string { return proto.CompactTextString(m) }
func (*ModifyProgram) ProtoMessage()    {}
func (*ModifyProgram) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{11}
}
func (m *ModifyProgram) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModifyProgram.Unmarshal(m, b)
}
func (m *ModifyProgram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModifyProgram.Marshal(b, m, deterministic)
}
func (dst *ModifyProgram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProgram.Merge(dst, src)
}
func (m *ModifyProgram) XXX_Size() int {
	return xxx_messageInfo_ModifyProgram.Size(m)
}
func (m *ModifyProgram) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProgram.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProgram proto.InternalMessageInfo

func (m *ModifyProgram) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ModifyProgram) GetModify() []*Modify {
	if m != nil {
		return m.Modify
	}
	return nil
}

// A single modification for a part of a request
type Modify struct {
	What Modify_What `protobuf:"varint,1,opt,name=what,proto3,enum=tetrate.api.liaison.v1.Modify_What" json:"what,omitempty"`
	How  Modify_How  `protobuf:"varint,2,opt,name=how,proto3,enum=tetrate.api.liaison.v1.Modify_How" json:"how,omitempty"`
	// used only if what is a Header
	HeaderName string `protobuf:"bytes,3,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// string to use as replacement for url rewrite/host rewrite or setting headers
	// no value is necessary when deleting the header
	Value                string   `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Modify) Reset()         { *m = Modify{} }
func (m *Modify) String() string { return proto.CompactTextString(m) }
func (*Modify) ProtoMessage()    {}
func (*Modify) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{12}
}
func (m *Modify) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Modify.Unmarshal(m, b)
}
func (m *Modify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Modify.Marshal(b, m, deterministic)
}
func (dst *Modify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Modify.Merge(dst, src)
}
func (m *Modify) XXX_Size() int {
	return xxx_messageInfo_Modify.Size(m)
}
func (m *Modify) XXX_DiscardUnknown() {
	xxx_messageInfo_Modify.DiscardUnknown(m)
}

var xxx_messageInfo_Modify proto.InternalMessageInfo

func (m *Modify) GetWhat() Modify_What {
	if m != nil {
		return m.What
	}
	return Modify_URI
}

func (m *Modify) GetHow() Modify_How {
	if m != nil {
		return m.How
	}
	return Modify_SET
}

func (m *Modify) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *Modify) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// One or more destinations for the given request
type Route struct {
	Destinations         []*Route_Destination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{13}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Route.Unmarshal(m, b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Route.Marshal(b, m, deterministic)
}
func (dst *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(dst, src)
}
func (m *Route) XXX_Size() int {
	return xxx_messageInfo_Route.Size(m)
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetDestinations() []*Route_Destination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

type Route_Destination struct {
	Host   string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Subset string `protobuf:"bytes,2,opt,name=subset,proto3" json:"subset,omitempty"`
	Port   uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// sum of all weights should add up to 100
	Weight               uint32   `protobuf:"varint,4,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route_Destination) Reset()         { *m = Route_Destination{} }
func (m *Route_Destination) String() string { return proto.CompactTextString(m) }
func (*Route_Destination) ProtoMessage()    {}
func (*Route_Destination) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{13, 0}
}
func (m *Route_Destination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Route_Destination.Unmarshal(m, b)
}
func (m *Route_Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Route_Destination.Marshal(b, m, deterministic)
}
func (dst *Route_Destination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route_Destination.Merge(dst, src)
}
func (m *Route_Destination) XXX_Size() int {
	return xxx_messageInfo_Route_Destination.Size(m)
}
func (m *Route_Destination) XXX_DiscardUnknown() {
	xxx_messageInfo_Route_Destination.DiscardUnknown(m)
}

var xxx_messageInfo_Route_Destination proto.InternalMessageInfo

func (m *Route_Destination) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Route_Destination) GetSubset() string {
	if m != nil {
		return m.Subset
	}
	return ""
}

func (m *Route_Destination) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Route_Destination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type Redirect struct {
	// On a redirect, overwrite the Path portion of the URL with this
	// value.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// On a redirect, overwrite the Authority/Host portion of the URL with
	// this value.
	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redirect) Reset()         { *m = Redirect{} }
func (m *Redirect) String() string { return proto.CompactTextString(m) }
func (*Redirect) ProtoMessage()    {}
func (*Redirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{14}
}
func (m *Redirect) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Redirect.Unmarshal(m, b)
}
func (m *Redirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Redirect.Marshal(b, m, deterministic)
}
func (dst *Redirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redirect.Merge(dst, src)
}
func (m *Redirect) XXX_Size() int {
	return xxx_messageInfo_Redirect.Size(m)
}
func (m *Redirect) XXX_DiscardUnknown() {
	xxx_messageInfo_Redirect.DiscardUnknown(m)
}

var xxx_messageInfo_Redirect proto.InternalMessageInfo

func (m *Redirect) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Redirect) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

type TLSSettingsOrId struct {
	// Types that are valid to be assigned to ObjOrId:
	//	*TLSSettingsOrId_Id
	//	*TLSSettingsOrId_TlsSettings
	ObjOrId              isTLSSettingsOrId_ObjOrId `protobuf_oneof:"obj_or_id"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TLSSettingsOrId) Reset()         { *m = TLSSettingsOrId{} }
func (m *TLSSettingsOrId) String() string { return proto.CompactTextString(m) }
func (*TLSSettingsOrId) ProtoMessage()    {}
func (*TLSSettingsOrId) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{15}
}
func (m *TLSSettingsOrId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TLSSettingsOrId.Unmarshal(m, b)
}
func (m *TLSSettingsOrId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TLSSettingsOrId.Marshal(b, m, deterministic)
}
func (dst *TLSSettingsOrId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSSettingsOrId.Merge(dst, src)
}
func (m *TLSSettingsOrId) XXX_Size() int {
	return xxx_messageInfo_TLSSettingsOrId.Size(m)
}
func (m *TLSSettingsOrId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSSettingsOrId.DiscardUnknown(m)
}

var xxx_messageInfo_TLSSettingsOrId proto.InternalMessageInfo

type isTLSSettingsOrId_ObjOrId interface {
	isTLSSettingsOrId_ObjOrId()
}

type TLSSettingsOrId_Id struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3,oneof"`
}

type TLSSettingsOrId_TlsSettings struct {
	TlsSettings *TLSSettings `protobuf:"bytes,2,opt,name=tls_settings,json=tlsSettings,proto3,oneof"`
}

func (*TLSSettingsOrId_Id) isTLSSettingsOrId_ObjOrId() {}

func (*TLSSettingsOrId_TlsSettings) isTLSSettingsOrId_ObjOrId() {}

func (m *TLSSettingsOrId) GetObjOrId() isTLSSettingsOrId_ObjOrId {
	if m != nil {
		return m.ObjOrId
	}
	return nil
}

func (m *TLSSettingsOrId) GetId() string {
	if x, ok := m.GetObjOrId().(*TLSSettingsOrId_Id); ok {
		return x.Id
	}
	return ""
}

func (m *TLSSettingsOrId) GetTlsSettings() *TLSSettings {
	if x, ok := m.GetObjOrId().(*TLSSettingsOrId_TlsSettings); ok {
		return x.TlsSettings
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TLSSettingsOrId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TLSSettingsOrId_OneofMarshaler, _TLSSettingsOrId_OneofUnmarshaler, _TLSSettingsOrId_OneofSizer, []interface{}{
		(*TLSSettingsOrId_Id)(nil),
		(*TLSSettingsOrId_TlsSettings)(nil),
	}
}

func _TLSSettingsOrId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TLSSettingsOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *TLSSettingsOrId_Id:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Id)
	case *TLSSettingsOrId_TlsSettings:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TlsSettings); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TLSSettingsOrId.ObjOrId has unexpected type %T", x)
	}
	return nil
}

func _TLSSettingsOrId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TLSSettingsOrId)
	switch tag {
	case 1: // obj_or_id.id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ObjOrId = &TLSSettingsOrId_Id{x}
		return true, err
	case 2: // obj_or_id.tls_settings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TLSSettings)
		err := b.DecodeMessage(msg)
		m.ObjOrId = &TLSSettingsOrId_TlsSettings{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TLSSettingsOrId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TLSSettingsOrId)
	// obj_or_id
	switch x := m.ObjOrId.(type) {
	case *TLSSettingsOrId_Id:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *TLSSettingsOrId_TlsSettings:
		s := proto.Size(x.TlsSettings)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TLSSettings struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// For proxies running on VMs, the path to the file holding the
	// server-side TLS certificate to use.
	ServerCertificate string `protobuf:"bytes,2,opt,name=server_certificate,json=serverCertificate,proto3" json:"server_certificate,omitempty"`
	// For proxies running on VMs, the path to the file holding the
	// server's private key.
	PrivateKey string `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// For proxies running on VMs, the path to a file containing
	// certificate authority certificates to use in verifying a
	// presented client side certificate for mutual TLS connections.
	CaCertificates string `protobuf:"bytes,4,opt,name=ca_certificates,json=caCertificates,proto3" json:"ca_certificates,omitempty"`
	// For proxies running on Kubernetes, the name of the secret that
	// holds the TLS certs. Currently applicable only on Kubernetes.
	// The secret should contain the server certificate and the private
	// key. If mutual TLS is being used, an additional secret with name
	// secretName-cacert should be created with the CaCertificates that
	// the server will use to verify client side certificates.
	SecretName           string   `protobuf:"bytes,5,opt,name=secret_name,json=secretName,proto3" json:"secret_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLSSettings) Reset()         { *m = TLSSettings{} }
func (m *TLSSettings) String() string { return proto.CompactTextString(m) }
func (*TLSSettings) ProtoMessage()    {}
func (*TLSSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_tcc_a171d216ca7ff05c, []int{16}
}
func (m *TLSSettings) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TLSSettings.Unmarshal(m, b)
}
func (m *TLSSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TLSSettings.Marshal(b, m, deterministic)
}
func (dst *TLSSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSSettings.Merge(dst, src)
}
func (m *TLSSettings) XXX_Size() int {
	return xxx_messageInfo_TLSSettings.Size(m)
}
func (m *TLSSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TLSSettings proto.InternalMessageInfo

func (m *TLSSettings) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *TLSSettings) GetServerCertificate() string {
	if m != nil {
		return m.ServerCertificate
	}
	return ""
}

func (m *TLSSettings) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *TLSSettings) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *TLSSettings) GetSecretName() string {
	if m != nil {
		return m.SecretName
	}
	return ""
}

func init() {
	proto.RegisterType((*Metadata)(nil), "tetrate.api.liaison.v1.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.liaison.v1.Metadata.TagEntry")
	proto.RegisterType((*LoadBalancer)(nil), "tetrate.api.liaison.v1.LoadBalancer")
	proto.RegisterType((*LBPort)(nil), "tetrate.api.liaison.v1.LBPort")
	proto.RegisterType((*Service)(nil), "tetrate.api.liaison.v1.Service")
	proto.RegisterType((*HttpRuleOrId)(nil), "tetrate.api.liaison.v1.HttpRuleOrId")
	proto.RegisterType((*HttpRule)(nil), "tetrate.api.liaison.v1.HttpRule")
	proto.RegisterType((*MatchProgramOrId)(nil), "tetrate.api.liaison.v1.MatchProgramOrId")
	proto.RegisterType((*HttpMatchProgram)(nil), "tetrate.api.liaison.v1.HttpMatchProgram")
	proto.RegisterType((*HttpMatchExpression)(nil), "tetrate.api.liaison.v1.HttpMatchExpression")
	proto.RegisterMapType((map[string]*StringMatch)(nil), "tetrate.api.liaison.v1.HttpMatchExpression.HeadersEntry")
	proto.RegisterType((*StringMatch)(nil), "tetrate.api.liaison.v1.StringMatch")
	proto.RegisterType((*ModifyProgramOrId)(nil), "tetrate.api.liaison.v1.ModifyProgramOrId")
	proto.RegisterType((*ModifyProgram)(nil), "tetrate.api.liaison.v1.ModifyProgram")
	proto.RegisterType((*Modify)(nil), "tetrate.api.liaison.v1.Modify")
	proto.RegisterType((*Route)(nil), "tetrate.api.liaison.v1.Route")
	proto.RegisterType((*Route_Destination)(nil), "tetrate.api.liaison.v1.Route.Destination")
	proto.RegisterType((*Redirect)(nil), "tetrate.api.liaison.v1.Redirect")
	proto.RegisterType((*TLSSettingsOrId)(nil), "tetrate.api.liaison.v1.TLSSettingsOrId")
	proto.RegisterType((*TLSSettings)(nil), "tetrate.api.liaison.v1.TLSSettings")
	proto.RegisterEnum("tetrate.api.liaison.v1.Modify_What", Modify_What_name, Modify_What_value)
	proto.RegisterEnum("tetrate.api.liaison.v1.Modify_How", Modify_How_name, Modify_How_value)
}

func init() { proto.RegisterFile("tcc.proto", fileDescriptor_tcc_a171d216ca7ff05c) }

var fileDescriptor_tcc_a171d216ca7ff05c = []byte{
	// 1239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdb, 0x6e, 0x1b, 0x37,
	0x13, 0x96, 0xb4, 0x96, 0x2c, 0x8d, 0x64, 0x47, 0x61, 0x02, 0x43, 0xbf, 0xff, 0x36, 0x31, 0xb6,
	0x87, 0xb8, 0x0d, 0xb2, 0x46, 0xdc, 0x24, 0xcd, 0xa1, 0x68, 0x61, 0xc7, 0x02, 0xd6, 0x88, 0x9d,
	0x18, 0xb4, 0x82, 0xa2, 0xbd, 0x11, 0xe8, 0x5d, 0x5a, 0xcb, 0x56, 0x12, 0x55, 0x92, 0xeb, 0x43,
	0x2f, 0x0b, 0xf4, 0x39, 0xfa, 0x0c, 0x7d, 0x80, 0xb6, 0xaf, 0xd2, 0x9b, 0x3e, 0x42, 0xef, 0x0b,
	0x1e, 0x56, 0x5e, 0xbb, 0xda, 0xd8, 0x85, 0xef, 0x38, 0xc3, 0xef, 0x1b, 0x0e, 0x87, 0x33, 0xc3,
	0x81, 0x86, 0x8a, 0xa2, 0x60, 0x22, 0xb8, 0xe2, 0x68, 0x49, 0x51, 0x25, 0x88, 0xa2, 0x01, 0x99,
	0xb0, 0x60, 0xc8, 0x08, 0x93, 0x7c, 0x1c, 0x1c, 0x3d, 0x5c, 0xbe, 0x33, 0xe0, 0x7c, 0x30, 0xa4,
	0x6b, 0x06, 0x75, 0x90, 0x1e, 0xae, 0xc5, 0xa9, 0x20, 0x8a, 0xf1, 0xb1, 0xe5, 0xf9, 0xbf, 0x96,
	0xa1, 0xbe, 0x4b, 0x15, 0x89, 0x89, 0x22, 0x68, 0x11, 0x2a, 0x2c, 0xee, 0x94, 0x57, 0xca, 0xab,
	0x0d, 0x5c, 0x61, 0x31, 0x5a, 0x81, 0x66, 0x4c, 0x65, 0x24, 0xd8, 0x44, 0x33, 0x3a, 0x15, 0xb3,
	0x91, 0x57, 0xa1, 0x17, 0xe0, 0x29, 0x32, 0xe8, 0x78, 0x2b, 0xde, 0x6a, 0x73, 0xfd, 0x93, 0x60,
	0xb6, 0x13, 0x41, 0x76, 0x40, 0xd0, 0x23, 0x83, 0xee, 0x58, 0x89, 0x53, 0xac, 0x59, 0xcb, 0x4f,
	0xa0, 0x9e, 0x29, 0x50, 0x1b, 0xbc, 0xef, 0xe9, 0xa9, 0x3b, 0x5b, 0x2f, 0xd1, 0x6d, 0xa8, 0x1e,
	0x91, 0x61, 0x4a, 0xdd, 0xb1, 0x56, 0x78, 0x5e, 0x79, 0x5a, 0xf6, 0xff, 0x28, 0x43, 0x6b, 0x87,
	0x93, 0x78, 0x93, 0x0c, 0xc9, 0x38, 0xa2, 0x02, 0x7d, 0x01, 0xf5, 0x91, 0x3b, 0xc2, 0x58, 0x68,
	0xae, 0xaf, 0x5c, 0xe6, 0x0a, 0x9e, 0x32, 0xd0, 0x23, 0xa8, 0x4e, 0xb8, 0x50, 0xb2, 0x53, 0x31,
	0xb7, 0xb8, 0x53, 0x44, 0xdd, 0xd9, 0xdc, 0xe3, 0x42, 0x61, 0x0b, 0x46, 0x2f, 0xa0, 0x2e, 0xa9,
	0x38, 0x62, 0x11, 0x95, 0xee, 0xfa, 0x77, 0x8b, 0x88, 0xfb, 0x16, 0x87, 0xa7, 0x04, 0xff, 0x08,
	0x6a, 0xd6, 0x1a, 0x42, 0x30, 0xa7, 0xed, 0x19, 0xb7, 0x17, 0xb0, 0x59, 0xa3, 0x65, 0xa8, 0x9b,
	0xc7, 0x89, 0xf8, 0xd0, 0x5d, 0x7e, 0x2a, 0xa3, 0xff, 0x43, 0x83, 0xc9, 0xbe, 0xa4, 0x51, 0x2a,
	0x68, 0xc7, 0x5b, 0x29, 0xaf, 0xd6, 0x71, 0x9d, 0xc9, 0x7d, 0x23, 0xa3, 0xbb, 0xd0, 0x74, 0x47,
	0xf4, 0x59, 0x2c, 0x3b, 0x73, 0x2b, 0xde, 0x6a, 0x03, 0x83, 0x53, 0x6d, 0xc7, 0xd2, 0xff, 0xb3,
	0x02, 0xf3, 0xce, 0x9b, 0x6b, 0x06, 0x6d, 0x19, 0xea, 0x09, 0x97, 0x6a, 0x4c, 0x46, 0xd9, 0x03,
	0x4d, 0xe5, 0xe9, 0x9d, 0xbc, 0x82, 0x3b, 0xcd, 0x5d, 0xb8, 0xd3, 0x33, 0xf0, 0xd4, 0x50, 0x76,
	0xaa, 0xc6, 0x89, 0x7b, 0x45, 0x4e, 0xf4, 0x76, 0xf6, 0xf7, 0xa9, 0x52, 0x6c, 0x3c, 0x90, 0x6f,
	0xc4, 0x76, 0x8c, 0x35, 0x07, 0xbd, 0x82, 0xdb, 0x89, 0x52, 0x93, 0xbe, 0xa0, 0x3f, 0xa4, 0x54,
	0xaa, 0xbe, 0x62, 0x23, 0xca, 0x53, 0xd5, 0xa9, 0x19, 0x5b, 0xff, 0x0b, 0x6c, 0xf6, 0x07, 0x59,
	0xf6, 0x07, 0x5b, 0x2e, 0xfb, 0x31, 0xd2, 0x34, 0x6c, 0x59, 0x3d, 0x4b, 0x42, 0x2f, 0x01, 0xac,
	0xb1, 0x74, 0x48, 0x65, 0x67, 0xde, 0x3c, 0xea, 0x87, 0x45, 0xee, 0x84, 0x9a, 0x9f, 0x0e, 0xa9,
	0xf1, 0xa5, 0x91, 0x38, 0x49, 0xfa, 0x63, 0x68, 0xe5, 0xb7, 0x50, 0xfb, 0xac, 0xa6, 0xc2, 0x92,
	0xa9, 0xaa, 0xaf, 0xa0, 0x31, 0x3d, 0xc6, 0xc4, 0xee, 0x1d, 0x91, 0xcf, 0x4c, 0x85, 0x25, 0x5c,
	0xcf, 0xce, 0xd8, 0x6c, 0x42, 0x83, 0x1f, 0x7c, 0xd7, 0xe7, 0xa2, 0xcf, 0x62, 0xff, 0xef, 0x0a,
	0xd4, 0x33, 0xd4, 0x35, 0xdf, 0x74, 0x17, 0x16, 0x46, 0x44, 0x45, 0x49, 0x7f, 0x22, 0xf8, 0x40,
	0x90, 0x91, 0x73, 0x6e, 0xb5, 0xd0, 0x84, 0x06, 0xef, 0x59, 0xac, 0x09, 0x43, 0x6b, 0x94, 0xd3,
	0xa0, 0x3d, 0x58, 0x1c, 0xf1, 0x98, 0x1d, 0x9e, 0x4e, 0xed, 0x79, 0xc6, 0x5e, 0x71, 0x9b, 0x30,
	0xe8, 0xbc, 0xc1, 0x85, 0x51, 0x5e, 0x85, 0x1e, 0x43, 0x55, 0xf0, 0x54, 0x51, 0x93, 0x41, 0xcd,
	0xf5, 0xf7, 0x8b, 0x0c, 0x61, 0x0d, 0x0a, 0x4b, 0xd8, 0xa2, 0xd1, 0x97, 0x50, 0x17, 0x34, 0x66,
	0x82, 0x46, 0xca, 0x25, 0x59, 0x61, 0x54, 0xb0, 0xc3, 0xe9, 0x78, 0x67, 0x9c, 0xcd, 0x5b, 0x70,
	0xd3, 0x18, 0xd2, 0x11, 0xcf, 0x94, 0xfe, 0x31, 0xb4, 0x2f, 0xde, 0x7f, 0xc6, 0x5b, 0x6f, 0xc1,
	0xfc, 0x15, 0x83, 0xa9, 0xdf, 0x30, 0x6f, 0x30, 0x2c, 0xe1, 0x8c, 0x7a, 0xfe, 0xc1, 0x7f, 0x29,
	0x43, 0xfb, 0x22, 0xf8, 0xda, 0x0f, 0xdf, 0xa4, 0x27, 0x13, 0x41, 0xa5, 0x64, 0x7c, 0x9c, 0xf5,
	0xc1, 0xfb, 0x97, 0x7a, 0xda, 0x9d, 0x72, 0x70, 0x9e, 0xef, 0xff, 0xee, 0xc1, 0xad, 0x19, 0x20,
	0xf4, 0x18, 0xbc, 0x54, 0x30, 0xe7, 0xdf, 0x07, 0x85, 0xdd, 0x52, 0x09, 0x36, 0x1e, 0x18, 0x2e,
	0xd6, 0x78, 0xf4, 0x02, 0x6a, 0x32, 0x4a, 0xe8, 0x28, 0x2b, 0x96, 0x2b, 0x31, 0x1d, 0x45, 0x93,
	0x47, 0x54, 0x25, 0x3c, 0x76, 0xc9, 0x77, 0x35, 0xb2, 0xa5, 0xa0, 0x0d, 0x68, 0x90, 0x54, 0x25,
	0x5c, 0x30, 0x75, 0xea, 0x72, 0xee, 0x4a, 0xfc, 0x33, 0x16, 0xc2, 0x30, 0x9f, 0x50, 0x12, 0x53,
	0xa1, 0xfb, 0x9b, 0x0e, 0xeb, 0xd3, 0xff, 0x10, 0xd6, 0x20, 0xb4, 0x54, 0xfb, 0x67, 0x66, 0x86,
	0x96, 0xfb, 0xd0, 0xca, 0x6f, 0xcc, 0xf8, 0x3b, 0x9f, 0xe5, 0xff, 0xce, 0x2b, 0x3a, 0x9d, 0xfb,
	0x60, 0x29, 0x34, 0x73, 0x3b, 0x68, 0x09, 0xaa, 0xf4, 0x84, 0x44, 0x6a, 0x9a, 0xd9, 0x56, 0x44,
	0x1d, 0xa8, 0x4d, 0x04, 0x3d, 0x64, 0x27, 0xf6, 0x07, 0x08, 0x4b, 0xd8, 0xc9, 0x9a, 0x21, 0xe8,
	0x80, 0x9e, 0x98, 0xa0, 0x1b, 0x86, 0x11, 0x37, 0x5b, 0x00, 0xb6, 0xc3, 0xa8, 0xd3, 0x09, 0xf5,
	0x53, 0xb8, 0xf9, 0xaf, 0x92, 0x9f, 0x51, 0x43, 0x1b, 0x17, 0x6b, 0xe8, 0xa3, 0x2b, 0x35, 0x90,
	0xc2, 0x02, 0xfa, 0xb9, 0x0c, 0x0b, 0xe7, 0x90, 0xd7, 0xac, 0x9e, 0x27, 0x50, 0xb3, 0x6d, 0xea,
	0xb2, 0x01, 0xc2, 0x1e, 0x8a, 0x1d, 0xda, 0xff, 0xa9, 0x02, 0x35, 0xab, 0x42, 0x9f, 0xc3, 0xdc,
	0x71, 0x42, 0x6c, 0x80, 0x17, 0x8b, 0x9f, 0xcb, 0xa2, 0x83, 0xaf, 0x13, 0xa2, 0xb0, 0x21, 0xa0,
	0x47, 0xe0, 0x25, 0xfc, 0xd8, 0xc4, 0x65, 0x71, 0xdd, 0xbf, 0x84, 0x17, 0xf2, 0x63, 0xac, 0xe1,
	0x7a, 0x4e, 0xb0, 0xb9, 0xd4, 0x37, 0xff, 0xb7, 0x79, 0x24, 0x0c, 0x56, 0xf5, 0x5a, 0xff, 0xe0,
	0xd3, 0xd9, 0x6b, 0x2e, 0x37, 0x7b, 0xf9, 0x9f, 0xc2, 0x9c, 0x3e, 0x1a, 0xcd, 0x83, 0xf7, 0x16,
	0x6f, 0xb7, 0x4b, 0x68, 0x01, 0x1a, 0x1b, 0x6f, 0x7b, 0xe1, 0x1b, 0xbc, 0xdd, 0xfb, 0xa6, 0x5d,
	0x46, 0x00, 0xb5, 0xb0, 0xbb, 0xb1, 0xd5, 0xc5, 0xed, 0x8a, 0xff, 0x31, 0x78, 0x21, 0x3f, 0xd6,
	0xd0, 0xfd, 0x6e, 0xaf, 0x5d, 0xd2, 0x7b, 0x1b, 0x7b, 0x7b, 0xdd, 0xd7, 0x5b, 0x16, 0xb7, 0xd5,
	0xdd, 0xe9, 0xf6, 0xba, 0xed, 0x8a, 0xff, 0x5b, 0x19, 0xaa, 0xa6, 0x5d, 0xa3, 0x5d, 0x68, 0xc5,
	0x54, 0x2a, 0x36, 0x36, 0x1f, 0xb4, 0xec, 0x94, 0xdf, 0x3d, 0x53, 0x1a, 0x52, 0xb0, 0x75, 0xc6,
	0xc0, 0xe7, 0xe8, 0xcb, 0x14, 0x9a, 0xb9, 0x4d, 0x3d, 0x93, 0xe8, 0xf9, 0xc4, 0x15, 0x89, 0x59,
	0xa3, 0x25, 0xa8, 0xc9, 0xf4, 0x40, 0x52, 0xe5, 0x26, 0x18, 0x27, 0xcd, 0x9c, 0x5f, 0x96, 0xa0,
	0x76, 0x4c, 0xd9, 0x20, 0x51, 0x26, 0x24, 0x0b, 0xd8, 0x49, 0xfe, 0x73, 0xa8, 0x67, 0x7f, 0x86,
	0xae, 0xc3, 0xac, 0xbf, 0x35, 0x6c, 0xeb, 0x7a, 0x2f, 0xdf, 0x40, 0xec, 0x21, 0x67, 0x0a, 0xff,
	0x47, 0xb8, 0x71, 0x61, 0xa8, 0x99, 0x91, 0xfd, 0x21, 0xb4, 0xd4, 0x50, 0x4f, 0x7c, 0x16, 0x75,
	0x59, 0x45, 0xe7, 0x0c, 0x86, 0x25, 0xdc, 0x54, 0x43, 0x99, 0x89, 0xe7, 0x8b, 0xe0, 0xaf, 0x32,
	0x34, 0x73, 0xd8, 0x6b, 0x96, 0xc0, 0x03, 0x40, 0x7a, 0xca, 0xa4, 0xa2, 0x1f, 0x51, 0xa1, 0xd8,
	0x21, 0x8b, 0x88, 0xca, 0xe6, 0xc2, 0x9b, 0x76, 0xe7, 0xe5, 0xd9, 0x86, 0xce, 0xbf, 0x89, 0x60,
	0x47, 0x44, 0xd1, 0xbe, 0x6e, 0x5c, 0x2e, 0xff, 0x9c, 0xea, 0x15, 0x3d, 0x45, 0xf7, 0xe0, 0x46,
	0x44, 0xf2, 0xb6, 0xa4, 0xcb, 0xc4, 0xc5, 0x88, 0xe4, 0x0c, 0x49, 0x3b, 0xf1, 0x46, 0x82, 0x2a,
	0x9b, 0xc9, 0x55, 0x6b, 0xc9, 0xaa, 0x74, 0x26, 0x6f, 0x3e, 0xf8, 0xf6, 0xfe, 0x80, 0xa9, 0x24,
	0x3d, 0x08, 0x22, 0x3e, 0x5a, 0x73, 0x37, 0x62, 0x3c, 0x5b, 0xad, 0x91, 0x09, 0x5b, 0x73, 0x77,
	0x5b, 0x3b, 0x7a, 0x78, 0x50, 0x33, 0x93, 0xe2, 0x67, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xaf,
	0xf4, 0x63, 0x2e, 0x5a, 0x0d, 0x00, 0x00,
}
