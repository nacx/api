// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tsb/traffic/v1/traffic_setting.proto

// Traffic Settings allow configuring the behavior of the sidecars in
// a set of namespaces owned by a traffic group. Specifically, it
// allows configuring the dependencies of sidecars on namespaces
// outside the traffic group as well as reliability settings for
// outbound calls made by the sidecars to other services.
//
// The following example creates a traffic group for the sidecars in
// `ns1`, `ns2` and `ns3` namespaces owned by its parent workspace
// `w1` under tenant `mycompany`. It then defines a traffic setting
// for the all workloads in these namespaces, adding a dependency on
// all the services in the shared `db` namespace, and forwarding all
// unknown traffic via the egress gateway in the `istio-system`
// namespace.
//
// ```yaml
// apiVersion: traffic.tsb.tetrate.io/v1
// kind: Group
// metadata:
//   name: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   namespaceSelector:
//     names:
//     - */ns1
//     - */ns2
//     - */ns3
//   configMode: TETRATE
//```
//
// And the associated traffic settings for the sidecars:
//
// ```yaml
// apiVersion: traffic.tsb.tetrate.io/v1
// kind: TrafficSetting
// metadata:
//   name: defaults
//   group: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   reachability:
//     mode: CUSTOM
//     hosts:
//     - ns1/*
//     - ns2/*
//     - ns3/*
//     - db/*
//   resilience:
//     circuitBreakerSensitivity: MEDIUM
//   egressGateway: istio-system/istio-egressgateway
//```
//
// The following traffic setting confines the reachability of sidecars
// in the traffic group `t1` to other namespaces inside the group. The
// resilience and egress gateway settings will be inherited from the
// workspace wide traffic setting.
//
// ```yaml
// apiVersion: traffic.tsb.tetrate.io/v1
// kind: TrafficSetting
// metadata:
//   name: defaults
//   group: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   reachability:
//     mode: GROUP
//```
//

package v1

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Available sensitivity levels for the circuit breaker.
type ResilienceSettings_Sensitivity int32

const (
	ResilienceSettings_UNSET ResilienceSettings_Sensitivity = 0
	// Tolerate upto 20 consecutive 5xx or connection failures from an
	// endpoint before ejecting it temporarily from the load balancing
	// pool.
	ResilienceSettings_LOW ResilienceSettings_Sensitivity = 1
	// Tolerate upto 10 consecutive 5xx or connection failures from an
	// endpoint before ejecting it temporarily from the load balancing
	// pool.
	ResilienceSettings_MEDIUM ResilienceSettings_Sensitivity = 2
	// Tolerate upto 5 consecutive 5xx or connection failures from an
	// endpoint before ejecting it temporarily from the load balancing
	// pool.
	ResilienceSettings_HIGH ResilienceSettings_Sensitivity = 3
)

var ResilienceSettings_Sensitivity_name = map[int32]string{
	0: "UNSET",
	1: "LOW",
	2: "MEDIUM",
	3: "HIGH",
}

var ResilienceSettings_Sensitivity_value = map[string]int32{
	"UNSET":  0,
	"LOW":    1,
	"MEDIUM": 2,
	"HIGH":   3,
}

func (x ResilienceSettings_Sensitivity) String() string {
	return proto.EnumName(ResilienceSettings_Sensitivity_name, int32(x))
}

func (ResilienceSettings_Sensitivity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{1, 0}
}

// A short cut for defining the common reachability patterns
type ReachabilitySettings_Mode int32

const (
	// Inherit from parent if possible. Otherwise treated as `CLUSTER`.
	ReachabilitySettings_UNSET ReachabilitySettings_Mode = 0
	// The workload may talk to any service in its own namespace.
	ReachabilitySettings_NAMESPACE ReachabilitySettings_Mode = 1
	// The workload may talk to any service in the traffic group.
	ReachabilitySettings_GROUP ReachabilitySettings_Mode = 2
	// The workload may talk to any service in the workspace.
	ReachabilitySettings_WORKSPACE ReachabilitySettings_Mode = 3
	// The workload may talk to any service in the cluster.
	ReachabilitySettings_CLUSTER ReachabilitySettings_Mode = 4
	// The workload may talk to services defined explicitly.
	ReachabilitySettings_CUSTOM ReachabilitySettings_Mode = 5
)

var ReachabilitySettings_Mode_name = map[int32]string{
	0: "UNSET",
	1: "NAMESPACE",
	2: "GROUP",
	3: "WORKSPACE",
	4: "CLUSTER",
	5: "CUSTOM",
}

var ReachabilitySettings_Mode_value = map[string]int32{
	"UNSET":     0,
	"NAMESPACE": 1,
	"GROUP":     2,
	"WORKSPACE": 3,
	"CLUSTER":   4,
	"CUSTOM":    5,
}

func (x ReachabilitySettings_Mode) String() string {
	return proto.EnumName(ReachabilitySettings_Mode_name, int32(x))
}

func (ReachabilitySettings_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{3, 0}
}

// A traffic setting applies configuration to a set of sidecars in a
// traffic group or a workspace. When applied to a traffic group,
// missing fields will inherit values from the workspace-wide setting if any.
type TrafficSetting struct {
	// The set of services and hosts accessed by a workload (and hence
	// its sidecar) in the mesh. Defining the set of services accessed
	// by a workload (i.e. its dependencies) in advance reduces the
	// memory and CPU consumption both the Istio control plane and the
	// individual Envoy sidecars in the data plane.
	Reachability *ReachabilitySettings `protobuf:"bytes,1,opt,name=reachability,proto3" json:"reachability,omitempty"`
	// Specifies the details of the egress proxy to which unknown
	// traffic should be forwarded to from the sidecar. If not
	// specified, the sidecar will send the unknown traffic directly to
	// the IP requested by the application. Must be in
	// `<namespace>/<fqdn>` format.
	EgressGateway string `protobuf:"bytes,2,opt,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	// Resilience settings such as timeouts, retries, etc., affecting
	// outbound traffic from sidecars.
	Resilience           *ResilienceSettings `protobuf:"bytes,3,opt,name=resilience,proto3" json:"resilience,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TrafficSetting) Reset()         { *m = TrafficSetting{} }
func (m *TrafficSetting) String() string { return proto.CompactTextString(m) }
func (*TrafficSetting) ProtoMessage()    {}
func (*TrafficSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{0}
}
func (m *TrafficSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficSetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSetting.Merge(m, src)
}
func (m *TrafficSetting) XXX_Size() int {
	return m.Size()
}
func (m *TrafficSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSetting.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSetting proto.InternalMessageInfo

func (m *TrafficSetting) GetReachability() *ReachabilitySettings {
	if m != nil {
		return m.Reachability
	}
	return nil
}

func (m *TrafficSetting) GetEgressGateway() string {
	if m != nil {
		return m.EgressGateway
	}
	return ""
}

func (m *TrafficSetting) GetResilience() *ResilienceSettings {
	if m != nil {
		return m.Resilience
	}
	return nil
}

// ResilienceSettings control the reliability knobs in Envoy when making
// outbound connections from a gateway or sidecar.
// TODO(@rshriram): Need more examples here.
type ResilienceSettings struct {
	// Timeout for HTTP requests. Disabled if not set.
	HttpRequestTimeout *types.Duration `protobuf:"bytes,1,opt,name=http_request_timeout,json=httpRequestTimeout,proto3" json:"http_request_timeout,omitempty"`
	// Retry policy for HTTP requests. Disabled if not set.
	HttpRetries *HTTPRetry `protobuf:"bytes,2,opt,name=http_retries,json=httpRetries,proto3" json:"http_retries,omitempty"`
	// If enabled, sets SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *types.BoolValue `protobuf:"bytes,3,opt,name=tcp_keepalive,json=tcpKeepalive,proto3" json:"tcp_keepalive,omitempty"`
	// Circuit breakers in Envoy are applied per endpoint in a load
	// balancing pool. By default, circuit breakers are disabled. If
	// set, the sensitivity level determines the maximum number of
	// consecutive failures that Envoy will tolerate before ejecting an
	// endpoint from the load balancing pool.
	CircuitBreakerSensitivity ResilienceSettings_Sensitivity `protobuf:"varint,4,opt,name=circuit_breaker_sensitivity,json=circuitBreakerSensitivity,proto3,enum=tetrateio.api.tsb.traffic.v1.ResilienceSettings_Sensitivity" json:"circuit_breaker_sensitivity,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                       `json:"-"`
	XXX_unrecognized          []byte                         `json:"-"`
	XXX_sizecache             int32                          `json:"-"`
}

func (m *ResilienceSettings) Reset()         { *m = ResilienceSettings{} }
func (m *ResilienceSettings) String() string { return proto.CompactTextString(m) }
func (*ResilienceSettings) ProtoMessage()    {}
func (*ResilienceSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{1}
}
func (m *ResilienceSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResilienceSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResilienceSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResilienceSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResilienceSettings.Merge(m, src)
}
func (m *ResilienceSettings) XXX_Size() int {
	return m.Size()
}
func (m *ResilienceSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ResilienceSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ResilienceSettings proto.InternalMessageInfo

func (m *ResilienceSettings) GetHttpRequestTimeout() *types.Duration {
	if m != nil {
		return m.HttpRequestTimeout
	}
	return nil
}

func (m *ResilienceSettings) GetHttpRetries() *HTTPRetry {
	if m != nil {
		return m.HttpRetries
	}
	return nil
}

func (m *ResilienceSettings) GetTcpKeepalive() *types.BoolValue {
	if m != nil {
		return m.TcpKeepalive
	}
	return nil
}

func (m *ResilienceSettings) GetCircuitBreakerSensitivity() ResilienceSettings_Sensitivity {
	if m != nil {
		return m.CircuitBreakerSensitivity
	}
	return ResilienceSettings_UNSET
}

// HTTPRetry defines the parameters for retrying API calls to a service.
type HTTPRetry struct {
	// Number of retries for a given request. The interval between retries will be determined
	// automatically (25ms+).
	//
	// Actual number of retries attempted depends on the httpReqTimeout.
	Attempts int32 `protobuf:"varint,1,opt,name=attempts,proto3" json:"attempts,omitempty"`
	// Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE >=1ms.
	PerTryTimeout *types.Duration `protobuf:"bytes,2,opt,name=per_try_timeout,json=perTryTimeout,proto3" json:"per_try_timeout,omitempty"`
	// Specifies the conditions under which retry takes place.
	// One or more policies can be specified using a ‘,’ delimited list.
	// See the [retry
	// policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on)
	// and [gRPC retry
	// policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on)
	// for more details.
	RetryOn              string   `protobuf:"bytes,3,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPRetry) Reset()         { *m = HTTPRetry{} }
func (m *HTTPRetry) String() string { return proto.CompactTextString(m) }
func (*HTTPRetry) ProtoMessage()    {}
func (*HTTPRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{2}
}
func (m *HTTPRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPRetry.Merge(m, src)
}
func (m *HTTPRetry) XXX_Size() int {
	return m.Size()
}
func (m *HTTPRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPRetry.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPRetry proto.InternalMessageInfo

func (m *HTTPRetry) GetAttempts() int32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *HTTPRetry) GetPerTryTimeout() *types.Duration {
	if m != nil {
		return m.PerTryTimeout
	}
	return nil
}

func (m *HTTPRetry) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

// `ReachabilitySettings` define the set of services and hosts
// accessed by a workload (and hence its sidecar) in the
// mesh. Defining the set of services accessed by a workload (i.e. its
// dependencies) in advance reduces the memory and CPU consumption
// both the Istio control plane and the individual Envoy sidecars in
// the data plane.
type ReachabilitySettings struct {
	// A short cut for specifying the set of services accessed by the workload.
	Mode ReachabilitySettings_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=tetrateio.api.tsb.traffic.v1.ReachabilitySettings_Mode" json:"mode,omitempty"`
	// When the mode is `CUSTOM`, `hosts` specify the set of services
	// that the sidecar should be able to reach. Must be in the
	// `<namespace>/<fqdn>` format.
	//
	// - `./*` indicates all services in the namespace where the sidecar resides.
	//
	// - `ns1/*` indicates all services in the `ns1` namespace.
	//
	// - `ns1/svc1.com` indicates `svc1.com` service in `ns1` namespace.
	//
	// - `*/svc1.com` indicates `svc1.com` service in any namespace.
	Hosts                []string `protobuf:"bytes,2,rep,name=hosts,proto3" json:"hosts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReachabilitySettings) Reset()         { *m = ReachabilitySettings{} }
func (m *ReachabilitySettings) String() string { return proto.CompactTextString(m) }
func (*ReachabilitySettings) ProtoMessage()    {}
func (*ReachabilitySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6caf5409540d77a, []int{3}
}
func (m *ReachabilitySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReachabilitySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReachabilitySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReachabilitySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReachabilitySettings.Merge(m, src)
}
func (m *ReachabilitySettings) XXX_Size() int {
	return m.Size()
}
func (m *ReachabilitySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ReachabilitySettings.DiscardUnknown(m)
}

var xxx_messageInfo_ReachabilitySettings proto.InternalMessageInfo

func (m *ReachabilitySettings) GetMode() ReachabilitySettings_Mode {
	if m != nil {
		return m.Mode
	}
	return ReachabilitySettings_UNSET
}

func (m *ReachabilitySettings) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func init() {
	proto.RegisterEnum("tetrateio.api.tsb.traffic.v1.ResilienceSettings_Sensitivity", ResilienceSettings_Sensitivity_name, ResilienceSettings_Sensitivity_value)
	proto.RegisterEnum("tetrateio.api.tsb.traffic.v1.ReachabilitySettings_Mode", ReachabilitySettings_Mode_name, ReachabilitySettings_Mode_value)
	proto.RegisterType((*TrafficSetting)(nil), "tetrateio.api.tsb.traffic.v1.TrafficSetting")
	proto.RegisterType((*ResilienceSettings)(nil), "tetrateio.api.tsb.traffic.v1.ResilienceSettings")
	proto.RegisterType((*HTTPRetry)(nil), "tetrateio.api.tsb.traffic.v1.HTTPRetry")
	proto.RegisterType((*ReachabilitySettings)(nil), "tetrateio.api.tsb.traffic.v1.ReachabilitySettings")
}

func init() {
	proto.RegisterFile("tsb/traffic/v1/traffic_setting.proto", fileDescriptor_c6caf5409540d77a)
}

var fileDescriptor_c6caf5409540d77a = []byte{
	// 688 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xed, 0x6a, 0x1a, 0x4d,
	0x18, 0x7d, 0xd7, 0x8f, 0x24, 0x8e, 0xd1, 0xec, 0x3b, 0x08, 0x6f, 0xe2, 0x5b, 0x6c, 0x90, 0xd0,
	0x08, 0x85, 0xdd, 0xc6, 0x52, 0xf2, 0xa3, 0x85, 0xa2, 0x89, 0x24, 0xa9, 0x31, 0xca, 0xb8, 0x26,
	0xd0, 0xd2, 0x2c, 0xb3, 0xeb, 0xa3, 0x0e, 0x59, 0x9d, 0xed, 0xec, 0x68, 0x10, 0x7a, 0x13, 0xbd,
	0x88, 0xde, 0x4b, 0x7f, 0x95, 0x5e, 0x42, 0xc8, 0x4d, 0x14, 0xf2, 0xab, 0xec, 0x87, 0xd6, 0x90,
	0x36, 0x21, 0x7f, 0x64, 0x1f, 0xce, 0x79, 0x8e, 0x67, 0xce, 0xd9, 0x1d, 0xb4, 0x25, 0x3d, 0x4b,
	0x97, 0x82, 0xf6, 0x7a, 0xcc, 0xd6, 0x27, 0x3b, 0xb3, 0x47, 0xd3, 0x03, 0x29, 0xd9, 0xa8, 0xaf,
	0xb9, 0x82, 0x4b, 0x8e, 0x9f, 0x48, 0x90, 0x82, 0x4a, 0x60, 0x5c, 0xa3, 0x2e, 0xd3, 0xa4, 0x67,
	0x69, 0x11, 0x51, 0x9b, 0xec, 0xe4, 0x9f, 0xf6, 0x39, 0xef, 0x3b, 0xa0, 0x53, 0x97, 0xe9, 0x3d,
	0x06, 0x4e, 0xd7, 0xb4, 0x60, 0x40, 0x27, 0x8c, 0x8b, 0x70, 0x3d, 0x5f, 0x88, 0x08, 0xc1, 0x64,
	0x8d, 0x7b, 0x7a, 0x77, 0x2c, 0xa8, 0x64, 0x7c, 0xf4, 0x37, 0xfc, 0x52, 0x50, 0xd7, 0x05, 0xe1,
	0x45, 0xf8, 0x7f, 0x13, 0xea, 0xb0, 0x2e, 0x95, 0xa0, 0xcf, 0x1e, 0x42, 0xa0, 0xf8, 0x53, 0x41,
	0x59, 0x23, 0x34, 0xd2, 0x0e, 0x0d, 0xe3, 0x53, 0xb4, 0x2a, 0x80, 0xda, 0x03, 0x6a, 0x31, 0x87,
	0xc9, 0xe9, 0xba, 0xb2, 0xa9, 0x94, 0xd2, 0xe5, 0xb2, 0x76, 0xdf, 0x09, 0x34, 0xb2, 0xb0, 0x11,
	0x09, 0x79, 0xe4, 0x96, 0x0e, 0x7e, 0x8d, 0xb2, 0xd0, 0x17, 0xe0, 0x79, 0x66, 0x9f, 0x4a, 0xb8,
	0xa4, 0xd3, 0xf5, 0xd8, 0xa6, 0x52, 0x4a, 0x55, 0x73, 0x37, 0xd5, 0x7f, 0xc5, 0x5a, 0x39, 0x73,
	0xfe, 0xe1, 0x5c, 0xff, 0xf8, 0x5c, 0x0f, 0x7e, 0xb7, 0x48, 0x26, 0xe4, 0x1e, 0x84, 0x54, 0xdc,
	0x42, 0x48, 0x80, 0xc7, 0x1c, 0x06, 0x23, 0x1b, 0xd6, 0xe3, 0x81, 0xa5, 0x17, 0x0f, 0x59, 0x9a,
	0xf1, 0xe7, 0x86, 0x16, 0x34, 0x8a, 0x5f, 0xe3, 0x08, 0xdf, 0xa5, 0xe0, 0x3a, 0xca, 0x0d, 0xa4,
	0x74, 0x4d, 0x01, 0x9f, 0xc6, 0xe0, 0x49, 0x53, 0xb2, 0x21, 0xf0, 0xb1, 0x8c, 0x52, 0xd8, 0xd0,
	0xc2, 0xa0, 0xb5, 0x59, 0xd0, 0xda, 0x7e, 0x54, 0x04, 0xc1, 0xfe, 0x1a, 0x09, 0xb7, 0x8c, 0x70,
	0x09, 0xbf, 0x43, 0xab, 0x91, 0x98, 0x14, 0x0c, 0xbc, 0xe0, 0xc0, 0xe9, 0xf2, 0xf6, 0xfd, 0xbe,
	0x0f, 0x0d, 0xa3, 0x45, 0x40, 0x8a, 0x29, 0x49, 0x87, 0x92, 0xc1, 0x2e, 0x7e, 0x8b, 0x32, 0xd2,
	0x76, 0xcd, 0x0b, 0x00, 0x97, 0x3a, 0x6c, 0x32, 0x0b, 0x21, 0x7f, 0xc7, 0x51, 0x95, 0x73, 0xe7,
	0x94, 0x3a, 0x63, 0x20, 0xab, 0xd2, 0x76, 0xeb, 0x33, 0x3e, 0xfe, 0x8c, 0xfe, 0xb7, 0x99, 0xb0,
	0xc7, 0x4c, 0x9a, 0x96, 0x00, 0x7a, 0x01, 0xc2, 0xf4, 0x60, 0xe4, 0x31, 0xc9, 0x26, 0x7e, 0xcd,
	0x89, 0x4d, 0xa5, 0x94, 0x2d, 0xbf, 0x79, 0x6c, 0xa6, 0x5a, 0xfb, 0xb7, 0x06, 0xd9, 0x88, 0xfe,
	0xa0, 0x1a, 0xea, 0x2f, 0x40, 0xc5, 0x5d, 0x94, 0x5e, 0x18, 0x71, 0x0a, 0x25, 0x3b, 0x27, 0xed,
	0x9a, 0xa1, 0xfe, 0x83, 0x97, 0x51, 0xfc, 0xb8, 0x79, 0xa6, 0x2a, 0x18, 0xa1, 0xa5, 0x46, 0x6d,
	0xff, 0xa8, 0xd3, 0x50, 0x63, 0x78, 0x05, 0x25, 0x0e, 0x8f, 0x0e, 0x0e, 0xd5, 0x78, 0xf1, 0x8b,
	0x82, 0x52, 0xf3, 0x48, 0xf0, 0x33, 0xb4, 0x42, 0xa5, 0x84, 0xa1, 0x2b, 0xbd, 0xa0, 0x92, 0x64,
	0x15, 0x5d, 0x55, 0x62, 0x37, 0xd5, 0x44, 0x3e, 0x56, 0x52, 0xc8, 0x1c, 0xc3, 0x15, 0xb4, 0xe6,
	0x82, 0x30, 0xa5, 0x98, 0xce, 0x1b, 0x8c, 0x3d, 0xd4, 0x60, 0xc6, 0x05, 0x61, 0x88, 0xe9, 0xac,
	0xbc, 0x0d, 0xb4, 0xe2, 0xf7, 0x36, 0x35, 0xf9, 0x28, 0xc8, 0x3a, 0x45, 0x96, 0x83, 0xb9, 0x39,
	0x2a, 0x7e, 0x57, 0x50, 0xee, 0x4f, 0x6f, 0x3c, 0xae, 0xa3, 0xc4, 0x90, 0x77, 0x21, 0xb0, 0x96,
	0x2d, 0xef, 0x3e, 0xfe, 0x9b, 0xd1, 0x1a, 0xbc, 0x0b, 0x24, 0x10, 0xc1, 0x39, 0x94, 0x1c, 0x70,
	0x4f, 0xfa, 0xaf, 0x4d, 0xbc, 0x94, 0x22, 0xe1, 0x50, 0x6c, 0xa3, 0x84, 0xcf, 0x59, 0x4c, 0x30,
	0x83, 0x52, 0x27, 0x95, 0x46, 0xad, 0xdd, 0xaa, 0xec, 0xd5, 0x54, 0xc5, 0x47, 0x0e, 0x48, 0xb3,
	0xd3, 0x52, 0x63, 0x3e, 0x72, 0xd6, 0x24, 0xf5, 0x10, 0x89, 0xe3, 0x34, 0x5a, 0xde, 0x3b, 0xee,
	0xb4, 0x8d, 0x1a, 0x51, 0x13, 0x7e, 0xdc, 0x7b, 0x9d, 0xb6, 0xd1, 0x6c, 0xa8, 0xc9, 0xea, 0xab,
	0x6f, 0xd7, 0x05, 0xe5, 0xc7, 0x75, 0x41, 0xb9, 0xba, 0x2e, 0x28, 0xef, 0xb7, 0xfb, 0x4c, 0x0e,
	0xc6, 0x96, 0x66, 0xf3, 0xa1, 0x3e, 0x3f, 0x41, 0x70, 0x39, 0xdd, 0xbe, 0xeb, 0xac, 0xa5, 0x20,
	0xc4, 0x97, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x96, 0x1b, 0x43, 0x68, 0x04, 0x05, 0x00, 0x00,
}

func (m *TrafficSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrafficSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resilience != nil {
		{
			size, err := m.Resilience.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EgressGateway) > 0 {
		i -= len(m.EgressGateway)
		copy(dAtA[i:], m.EgressGateway)
		i = encodeVarintTrafficSetting(dAtA, i, uint64(len(m.EgressGateway)))
		i--
		dAtA[i] = 0x12
	}
	if m.Reachability != nil {
		{
			size, err := m.Reachability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResilienceSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResilienceSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResilienceSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CircuitBreakerSensitivity != 0 {
		i = encodeVarintTrafficSetting(dAtA, i, uint64(m.CircuitBreakerSensitivity))
		i--
		dAtA[i] = 0x20
	}
	if m.TcpKeepalive != nil {
		{
			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.HttpRetries != nil {
		{
			size, err := m.HttpRetries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HttpRequestTimeout != nil {
		{
			size, err := m.HttpRequestTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetryOn) > 0 {
		i -= len(m.RetryOn)
		copy(dAtA[i:], m.RetryOn)
		i = encodeVarintTrafficSetting(dAtA, i, uint64(len(m.RetryOn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PerTryTimeout != nil {
		{
			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTrafficSetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Attempts != 0 {
		i = encodeVarintTrafficSetting(dAtA, i, uint64(m.Attempts))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReachabilitySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReachabilitySettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReachabilitySettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintTrafficSetting(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Mode != 0 {
		i = encodeVarintTrafficSetting(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTrafficSetting(dAtA []byte, offset int, v uint64) int {
	offset -= sovTrafficSetting(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TrafficSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reachability != nil {
		l = m.Reachability.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	l = len(m.EgressGateway)
	if l > 0 {
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.Resilience != nil {
		l = m.Resilience.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResilienceSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRequestTimeout != nil {
		l = m.HttpRequestTimeout.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.HttpRetries != nil {
		l = m.HttpRetries.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.TcpKeepalive != nil {
		l = m.TcpKeepalive.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.CircuitBreakerSensitivity != 0 {
		n += 1 + sovTrafficSetting(uint64(m.CircuitBreakerSensitivity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attempts != 0 {
		n += 1 + sovTrafficSetting(uint64(m.Attempts))
	}
	if m.PerTryTimeout != nil {
		l = m.PerTryTimeout.Size()
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovTrafficSetting(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReachabilitySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTrafficSetting(uint64(m.Mode))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovTrafficSetting(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTrafficSetting(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTrafficSetting(x uint64) (n int) {
	return sovTrafficSetting(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TrafficSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrafficSetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reachability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reachability == nil {
				m.Reachability = &ReachabilitySettings{}
			}
			if err := m.Reachability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resilience", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resilience == nil {
				m.Resilience = &ResilienceSettings{}
			}
			if err := m.Resilience.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrafficSetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResilienceSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrafficSetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResilienceSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResilienceSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRequestTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpRequestTimeout == nil {
				m.HttpRequestTimeout = &types.Duration{}
			}
			if err := m.HttpRequestTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRetries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpRetries == nil {
				m.HttpRetries = &HTTPRetry{}
			}
			if err := m.HttpRetries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpKeepalive == nil {
				m.TcpKeepalive = &types.BoolValue{}
			}
			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakerSensitivity", wireType)
			}
			m.CircuitBreakerSensitivity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CircuitBreakerSensitivity |= ResilienceSettings_Sensitivity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrafficSetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrafficSetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPRetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPRetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
			}
			m.Attempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerTryTimeout == nil {
				m.PerTryTimeout = &types.Duration{}
			}
			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrafficSetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReachabilitySettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrafficSetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReachabilitySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReachabilitySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ReachabilitySettings_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrafficSetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrafficSetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrafficSetting(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrafficSetting
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrafficSetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTrafficSetting
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTrafficSetting
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTrafficSetting
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTrafficSetting(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTrafficSetting
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTrafficSetting = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrafficSetting   = fmt.Errorf("proto: integer overflow")
)
