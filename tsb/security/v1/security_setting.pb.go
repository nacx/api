// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tsb/security/v1/security_setting.proto

// `SecuritySetting` allows configuring security related properties
// such as TLS authentication and access control for traffic arriving
// at a sidecar in a security group.
//
// The following example creates a security group for the sidecars in
// `ns1`, `ns2` and `ns3` namespaces owned by its parent workspace
// `w1` under tenant `mycompany` and defines a security setting that
// only allows mutual TLS authenticated traffic from other sidecars in
// the same group.
//
// ```yaml
// apiVersion: security.tsb.tetrate.io/v1
// kind: Group
// metadata:
//   name: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   namespaceSelectors:
//   - name: */ns1
//   - name: */ns2
//   - name: */ns3
//   configMode: TETRATE
//```
//
// And the associated security settings for all sidecars in the group
//
// ```yaml
// apiVersion: security.tsb.tetrate.io/v1
// kind: SecuritySetting
// metadata:
//   name: defaults
//   group: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   authentication: REQUIRED
//   authorization:
//     mode: GROUP
//```
//
// The following example customizes the `allowedSources` to allow
// traffic from the namespaces within the group as well as the
// `catalog-sa` service account from `ns4` namespace.
//
// ```yaml
// apiVersion: security.tsb.tetrate.io/v1
// kind: SecuritySetting
// metadata:
//   name: custom
//   group: t1
//   workspace: w1
//   tenant: mycompany
// spec:
//   authentication: REQUIRED
//   authorization:
//     mode: CUSTOM
//     serviceAccounts:
//     - ns1/*
//     - ns2/*
//     - ns3/*
//     - ns4/catalog-sa
//```
//

package v1

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AuthenticationMode indicates whether to accept only Istio mutual
// TLS authenticated traffic or allow legacy plaintext traffic as
// well.
type SecuritySetting_AuthenticationMode int32

const (
	// Inherit from parent, if has one. Otherwise treated as OPTIONAL.
	SecuritySetting_UNSET SecuritySetting_AuthenticationMode = 0
	// Accept both plaintext and mTLS authenticated connections.
	SecuritySetting_OPTIONAL SecuritySetting_AuthenticationMode = 1
	// Accept only mutual TLS authenticated connections.
	SecuritySetting_REQUIRED SecuritySetting_AuthenticationMode = 2
)

var SecuritySetting_AuthenticationMode_name = map[int32]string{
	0: "UNSET",
	1: "OPTIONAL",
	2: "REQUIRED",
}

var SecuritySetting_AuthenticationMode_value = map[string]int32{
	"UNSET":    0,
	"OPTIONAL": 1,
	"REQUIRED": 2,
}

func (x SecuritySetting_AuthenticationMode) String() string {
	return proto.EnumName(SecuritySetting_AuthenticationMode_name, int32(x))
}

func (SecuritySetting_AuthenticationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_75428e2eeb40db26, []int{0, 0}
}

// A short cut for defining the common authorization patterns
type AuthorizationSettings_Mode int32

const (
	// Inherit from parent if possible. Otherwise treated as `DISABLED`.
	AuthorizationSettings_UNSET AuthorizationSettings_Mode = 0
	// The workload allows traffic from any other authenticated workload in its own
	// namespace.
	AuthorizationSettings_NAMESPACE AuthorizationSettings_Mode = 1
	// The workload allows traffic from any other authenticated workload in the security group.
	AuthorizationSettings_GROUP AuthorizationSettings_Mode = 2
	// The workload allows traffic from any other authenticated workload in the workspace.
	AuthorizationSettings_WORKSPACE AuthorizationSettings_Mode = 3
	// The workload allows traffic from any other authenticated workload in the cluster.
	AuthorizationSettings_CLUSTER AuthorizationSettings_Mode = 4
	// Authorization is disabled.
	AuthorizationSettings_DISABLED AuthorizationSettings_Mode = 5
	// The workload allows traffic from service accounts defined explicitly.
	AuthorizationSettings_CUSTOM AuthorizationSettings_Mode = 6
)

var AuthorizationSettings_Mode_name = map[int32]string{
	0: "UNSET",
	1: "NAMESPACE",
	2: "GROUP",
	3: "WORKSPACE",
	4: "CLUSTER",
	5: "DISABLED",
	6: "CUSTOM",
}

var AuthorizationSettings_Mode_value = map[string]int32{
	"UNSET":     0,
	"NAMESPACE": 1,
	"GROUP":     2,
	"WORKSPACE": 3,
	"CLUSTER":   4,
	"DISABLED":  5,
	"CUSTOM":    6,
}

func (x AuthorizationSettings_Mode) String() string {
	return proto.EnumName(AuthorizationSettings_Mode_name, int32(x))
}

func (AuthorizationSettings_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_75428e2eeb40db26, []int{1, 0}
}

// A security setting applies configuration to a set of sidecars in a
// security group or a workspace. When applied to a security group,
// missing fields will inherit values from the workspace-wide setting.
type SecuritySetting struct {
	// Specifies whether the sidecars should accept only mutual TLS
	// authenticated traffic or allow legacy plaintext traffic as well.
	Authentication SecuritySetting_AuthenticationMode `protobuf:"varint,1,opt,name=authentication,proto3,enum=tetrateio.api.tsb.security.v1.SecuritySetting_AuthenticationMode" json:"authentication,omitempty"`
	// The set of service accounts in one or more namespaces allowed to
	// access a workload (and hence its sidecar) in the mesh.
	Authorization        *AuthorizationSettings `protobuf:"bytes,2,opt,name=authorization,proto3" json:"authorization,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SecuritySetting) Reset()         { *m = SecuritySetting{} }
func (m *SecuritySetting) String() string { return proto.CompactTextString(m) }
func (*SecuritySetting) ProtoMessage()    {}
func (*SecuritySetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_75428e2eeb40db26, []int{0}
}
func (m *SecuritySetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecuritySetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecuritySetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecuritySetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecuritySetting.Merge(m, src)
}
func (m *SecuritySetting) XXX_Size() int {
	return m.Size()
}
func (m *SecuritySetting) XXX_DiscardUnknown() {
	xxx_messageInfo_SecuritySetting.DiscardUnknown(m)
}

var xxx_messageInfo_SecuritySetting proto.InternalMessageInfo

func (m *SecuritySetting) GetAuthentication() SecuritySetting_AuthenticationMode {
	if m != nil {
		return m.Authentication
	}
	return SecuritySetting_UNSET
}

func (m *SecuritySetting) GetAuthorization() *AuthorizationSettings {
	if m != nil {
		return m.Authorization
	}
	return nil
}

// `AuthorizationSettings` define the set of service accounts in one
// or more namespaces allowed to access a workload (and hence its
// sidecar) in the mesh.
//
// **NOTE**: When used in `WorkspaceSetting`, authorization if not
// specified defaults to `NAMESPACE` mode, i.e. workloads will only
// allow traffic from other workloads in the same namespace.
type AuthorizationSettings struct {
	// A short cut for specifying the set of allowed callers.
	Mode AuthorizationSettings_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=tetrateio.api.tsb.security.v1.AuthorizationSettings_Mode" json:"mode,omitempty"`
	// When the mode is `CUSTOM`, `serviceAccounts` specify the allowed
	// set of service accounts (and the workloads using them). Must be
	// in the `<namespace>/<service-account-name>` format.
	//
	// - `./*` indicates all service accounts in the namespace where the sidecar resides.
	//
	// - `ns1/*` indicates all service accounts in the `ns1` namespace.
	//
	// - `ns1/svc1-sa` indicates `svc1-sa` service account in `ns1` namespace.
	ServiceAccounts      []string `protobuf:"bytes,2,rep,name=service_accounts,json=serviceAccounts,proto3" json:"service_accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthorizationSettings) Reset()         { *m = AuthorizationSettings{} }
func (m *AuthorizationSettings) String() string { return proto.CompactTextString(m) }
func (*AuthorizationSettings) ProtoMessage()    {}
func (*AuthorizationSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_75428e2eeb40db26, []int{1}
}
func (m *AuthorizationSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationSettings.Merge(m, src)
}
func (m *AuthorizationSettings) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationSettings.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationSettings proto.InternalMessageInfo

func (m *AuthorizationSettings) GetMode() AuthorizationSettings_Mode {
	if m != nil {
		return m.Mode
	}
	return AuthorizationSettings_UNSET
}

func (m *AuthorizationSettings) GetServiceAccounts() []string {
	if m != nil {
		return m.ServiceAccounts
	}
	return nil
}

func init() {
	proto.RegisterEnum("tetrateio.api.tsb.security.v1.SecuritySetting_AuthenticationMode", SecuritySetting_AuthenticationMode_name, SecuritySetting_AuthenticationMode_value)
	proto.RegisterEnum("tetrateio.api.tsb.security.v1.AuthorizationSettings_Mode", AuthorizationSettings_Mode_name, AuthorizationSettings_Mode_value)
	proto.RegisterType((*SecuritySetting)(nil), "tetrateio.api.tsb.security.v1.SecuritySetting")
	proto.RegisterType((*AuthorizationSettings)(nil), "tetrateio.api.tsb.security.v1.AuthorizationSettings")
}

func init() {
	proto.RegisterFile("tsb/security/v1/security_setting.proto", fileDescriptor_75428e2eeb40db26)
}

var fileDescriptor_75428e2eeb40db26 = []byte{
	// 418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xdf, 0x8a, 0xd3, 0x40,
	0x14, 0xc6, 0x9d, 0x6c, 0xb7, 0xda, 0x59, 0x77, 0x77, 0x18, 0x10, 0x16, 0xc1, 0x52, 0x72, 0x21,
	0xf1, 0x62, 0x27, 0xec, 0x2a, 0x82, 0x78, 0x35, 0xdb, 0x06, 0x29, 0x36, 0x4d, 0x9d, 0x24, 0x08,
	0x7b, 0xb3, 0x4c, 0xd2, 0xa1, 0x3b, 0xe0, 0x66, 0x42, 0x32, 0x09, 0xd6, 0xf7, 0xf0, 0x9d, 0xbc,
	0xf4, 0x11, 0xa4, 0xcf, 0xe0, 0x03, 0x48, 0xfe, 0xb8, 0xb4, 0xa9, 0x28, 0x78, 0x77, 0xe6, 0x9c,
	0x39, 0xdf, 0xef, 0x9c, 0xc3, 0x07, 0x9f, 0xeb, 0x3c, 0xb2, 0x73, 0x11, 0x17, 0x99, 0xd4, 0x6b,
	0xbb, 0xbc, 0xb8, 0x8f, 0x6f, 0x72, 0xa1, 0xb5, 0x4c, 0x56, 0x24, 0xcd, 0x94, 0x56, 0xf8, 0x99,
	0x16, 0x3a, 0xe3, 0x5a, 0x48, 0x45, 0x78, 0x2a, 0x89, 0xce, 0x23, 0xf2, 0xfb, 0x27, 0x29, 0x2f,
	0x9e, 0xd2, 0x95, 0xd4, 0xb7, 0x45, 0x44, 0x62, 0x75, 0x67, 0x8b, 0xa4, 0x54, 0xeb, 0x34, 0x53,
	0x9f, 0xd7, 0x76, 0xdd, 0x1b, 0x9f, 0xaf, 0x44, 0x72, 0x5e, 0xf2, 0x4f, 0x72, 0xc9, 0xb5, 0xb0,
	0xf7, 0x82, 0x86, 0x60, 0x7e, 0x35, 0xe0, 0xa9, 0xdf, 0x4a, 0xfa, 0x0d, 0x1b, 0x4b, 0x78, 0xc2,
	0x0b, 0x7d, 0x2b, 0x12, 0x2d, 0x63, 0xae, 0xa5, 0x4a, 0xce, 0xc0, 0x08, 0x58, 0x27, 0x97, 0x94,
	0xfc, 0x75, 0x1c, 0xd2, 0xd1, 0x21, 0x74, 0x47, 0xc4, 0x55, 0x4b, 0xc1, 0x3a, 0xc2, 0xf8, 0x1a,
	0x1e, 0x57, 0x19, 0x95, 0xc9, 0x2f, 0x0d, 0xc9, 0x18, 0x01, 0xeb, 0xe8, 0xf2, 0xd5, 0x3f, 0x48,
	0x74, 0xbb, 0xa7, 0xc5, 0xe5, 0x6c, 0x57, 0xca, 0x7c, 0x0b, 0xf1, 0xfe, 0x04, 0x78, 0x00, 0x0f,
	0xc3, 0xb9, 0xef, 0x04, 0xe8, 0x01, 0x7e, 0x0c, 0x1f, 0x79, 0x8b, 0x60, 0xea, 0xcd, 0xe9, 0x0c,
	0x81, 0xea, 0xc5, 0x9c, 0x0f, 0xe1, 0x94, 0x39, 0x13, 0x64, 0x98, 0x3f, 0x01, 0x7c, 0xf2, 0x47,
	0x0a, 0x76, 0x61, 0xef, 0x4e, 0x2d, 0x45, 0x7b, 0x93, 0x37, 0xff, 0x33, 0x29, 0xa9, 0x6f, 0x51,
	0xcb, 0xe0, 0x17, 0x10, 0xe5, 0x22, 0x2b, 0x65, 0x2c, 0x6e, 0x78, 0x1c, 0xab, 0x22, 0xd1, 0xf9,
	0x99, 0x31, 0x3a, 0xb0, 0x06, 0xec, 0xb4, 0xcd, 0xd3, 0x36, 0x6d, 0x72, 0xd8, 0xeb, 0xae, 0x70,
	0x0c, 0x07, 0x73, 0xea, 0x3a, 0xfe, 0x82, 0x8e, 0x1d, 0x04, 0xaa, 0xca, 0x3b, 0xe6, 0x85, 0x0b,
	0x64, 0x54, 0x95, 0x8f, 0x1e, 0x7b, 0xdf, 0x54, 0x0e, 0xf0, 0x11, 0x7c, 0x38, 0x9e, 0x85, 0x7e,
	0xe0, 0x30, 0xd4, 0xab, 0x56, 0x9d, 0x4c, 0x7d, 0x7a, 0x35, 0x73, 0x26, 0xe8, 0x10, 0x43, 0xd8,
	0x1f, 0x87, 0x7e, 0xe0, 0xb9, 0xa8, 0x7f, 0xf5, 0xfa, 0xdb, 0x66, 0x08, 0xbe, 0x6f, 0x86, 0xe0,
	0xc7, 0x66, 0x08, 0xae, 0xad, 0x2d, 0x7f, 0xdd, 0xaf, 0x69, 0xf3, 0x54, 0xda, 0x1d, 0xff, 0x46,
	0xfd, 0xda, 0x4d, 0x2f, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x56, 0x97, 0xd8, 0xba, 0xd9, 0x02,
	0x00, 0x00,
}

func (m *SecuritySetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecuritySetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecuritySetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Authorization != nil {
		{
			size, err := m.Authorization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSecuritySetting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Authentication != 0 {
		i = encodeVarintSecuritySetting(dAtA, i, uint64(m.Authentication))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceAccounts) > 0 {
		for iNdEx := len(m.ServiceAccounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServiceAccounts[iNdEx])
			copy(dAtA[i:], m.ServiceAccounts[iNdEx])
			i = encodeVarintSecuritySetting(dAtA, i, uint64(len(m.ServiceAccounts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Mode != 0 {
		i = encodeVarintSecuritySetting(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSecuritySetting(dAtA []byte, offset int, v uint64) int {
	offset -= sovSecuritySetting(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecuritySetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != 0 {
		n += 1 + sovSecuritySetting(uint64(m.Authentication))
	}
	if m.Authorization != nil {
		l = m.Authorization.Size()
		n += 1 + l + sovSecuritySetting(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthorizationSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovSecuritySetting(uint64(m.Mode))
	}
	if len(m.ServiceAccounts) > 0 {
		for _, s := range m.ServiceAccounts {
			l = len(s)
			n += 1 + l + sovSecuritySetting(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSecuritySetting(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSecuritySetting(x uint64) (n int) {
	return sovSecuritySetting(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecuritySetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecuritySetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecuritySetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecuritySetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			m.Authentication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Authentication |= SecuritySetting_AuthenticationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authorization == nil {
				m.Authorization = &AuthorizationSettings{}
			}
			if err := m.Authorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecuritySetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecuritySetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= AuthorizationSettings_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccounts = append(m.ServiceAccounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecuritySetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSecuritySetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSecuritySetting(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSecuritySetting
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecuritySetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSecuritySetting
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSecuritySetting
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSecuritySetting
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSecuritySetting(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSecuritySetting
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSecuritySetting = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSecuritySetting   = fmt.Errorf("proto: integer overflow")
)
