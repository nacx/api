// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tsb/gateway/v1/ingress_gateway.proto

// `IngressGateway` configures a workload to act as a gateway for
// traffic entering the mesh. The ingress gateway also provides basic
// API gateway functionalities such as JWT token validation, rate
// limiting, and request authorization. Gateways in privileged
// workspaces can route to services outside the workspace while those
// in unprivileged workspaces can only route to services inside the
// workspace.
//
// The following example declares an ingress gateway running on pods
// with `app: gateway` labels in the `ns1` namespace. The gateway
// exposes a host `bookinfo.com` on https port 8443. TLS is terminated
// using the certificates in the Kubernetes secret
// `bookinfo-certs`. Clients are authenticated using JWT tokens, whose
// keys are obtained from the OIDC provider `www.googleapis.com`. The
// request is then authorized by an the user's authorization engine
// hosted at `https://internal.example.com` before being forwarded to
// the `productpage` service in the backend.
//
// ```yaml
// apiVersion: gateway.tsb.tetrate.io/v1
// kind: IngressGateway
// metadata:
//   name: ingress-bookinfo
//   group: g1
//   workspace: w1
//   tenant: mycompany
// spec:
//   workloadSelector:
//     namespace: ns1
//     labels:
//       app: gateway
//   http:
//   - hostname: bookinfo.com
//     tls:
//       mode: SIMPLE
//       secretName: bookinfo-certs
//     authentication:
//       jwt:
//         issuer: https://www.googleapis.com/oauth2/v1/certs
//         audience: bookinfo
//     authorization:
//       external:
//         uri: https://company.com/authz
//         includeRequestHeaders:
//         - Authorization # forwards the header to the authorization service.
//     routing:
//       rules:
//       - route:
//           host: ns1/productpage.ns1.svc.cluster.local
//```
//
// If the `productpage.ns1` service on Kubernetes has a `ServiceRoute`
// with multiple subsets and weights, the traffic will be split across
// the subsets accordingly.
//
// TODO(rshriram): Add lot more examples in the gateway section.

package v1

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "github.com/tetrateio/api/tsb/types/v1"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ServerTLSSettings_TLSMode int32

const (
	ServerTLSSettings_DISABLED ServerTLSSettings_TLSMode = 0
	ServerTLSSettings_SIMPLE   ServerTLSSettings_TLSMode = 1
	ServerTLSSettings_MUTUAL   ServerTLSSettings_TLSMode = 2
)

var ServerTLSSettings_TLSMode_name = map[int32]string{
	0: "DISABLED",
	1: "SIMPLE",
	2: "MUTUAL",
}

var ServerTLSSettings_TLSMode_value = map[string]int32{
	"DISABLED": 0,
	"SIMPLE":   1,
	"MUTUAL":   2,
}

func (x ServerTLSSettings_TLSMode) String() string {
	return proto.EnumName(ServerTLSSettings_TLSMode_name, int32(x))
}

func (ServerTLSSettings_TLSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{12, 0}
}

// `IngressGateway` configures a workload to act as an ingress gateway into the mesh.
type IngressGateway struct {
	// Specify the gateway workloads (pod labels and Kubernetes
	// namespace) under the gateway group that should be configured with
	// this ingress gateway. There can be only one ingress gateway for a
	// given workload selector.
	WorkloadSelector *v1.WorkloadSelector `protobuf:"bytes,1,opt,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty"`
	// One or more HTTP or HTTPS servers exposed by the gateway. The
	// server exposes configuration for TLS termination, request
	// authentication/authorization, HTTP routing, etc.
	Http                 []*HttpServer `protobuf:"bytes,2,rep,name=http,proto3" json:"http,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IngressGateway) Reset()         { *m = IngressGateway{} }
func (m *IngressGateway) String() string { return proto.CompactTextString(m) }
func (*IngressGateway) ProtoMessage()    {}
func (*IngressGateway) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{0}
}
func (m *IngressGateway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGateway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGateway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGateway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGateway.Merge(m, src)
}
func (m *IngressGateway) XXX_Size() int {
	return m.Size()
}
func (m *IngressGateway) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGateway.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGateway proto.InternalMessageInfo

func (m *IngressGateway) GetWorkloadSelector() *v1.WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *IngressGateway) GetHttp() []*HttpServer {
	if m != nil {
		return m.Http
	}
	return nil
}

type HttpServer struct {
	// Hostname with which the service can be expected to be accessed by clients.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// TLS certificate info. If omitted, the gateway will expose the host on port 80.
	Tls *ServerTLSSettings `protobuf:"bytes,2,opt,name=tls,proto3" json:"tls,omitempty"`
	// Configuration to authenticate clients.
	Authentication *Authentication `protobuf:"bytes,3,opt,name=authentication,proto3" json:"authentication,omitempty"`
	// Configuration to authorize a request.
	Authorization *Authorization `protobuf:"bytes,4,opt,name=authorization,proto3" json:"authorization,omitempty"`
	// Routing rules associated with HTTP traffic to this service.
	Routing              *HttpRouting `protobuf:"bytes,5,opt,name=routing,proto3" json:"routing,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HttpServer) Reset()         { *m = HttpServer{} }
func (m *HttpServer) String() string { return proto.CompactTextString(m) }
func (*HttpServer) ProtoMessage()    {}
func (*HttpServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{1}
}
func (m *HttpServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpServer.Merge(m, src)
}
func (m *HttpServer) XXX_Size() int {
	return m.Size()
}
func (m *HttpServer) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpServer.DiscardUnknown(m)
}

var xxx_messageInfo_HttpServer proto.InternalMessageInfo

func (m *HttpServer) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *HttpServer) GetTls() *ServerTLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *HttpServer) GetAuthentication() *Authentication {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *HttpServer) GetAuthorization() *Authorization {
	if m != nil {
		return m.Authorization
	}
	return nil
}

func (m *HttpServer) GetRouting() *HttpRouting {
	if m != nil {
		return m.Routing
	}
	return nil
}

type HttpRouting struct {
	StickySession        *HttpRouting_StickySession `protobuf:"bytes,1,opt,name=sticky_session,json=stickySession,proto3" json:"sticky_session,omitempty"`
	CorsPolicy           *CorsPolicy                `protobuf:"bytes,2,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	Rules                []*HttpRule                `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *HttpRouting) Reset()         { *m = HttpRouting{} }
func (m *HttpRouting) String() string { return proto.CompactTextString(m) }
func (*HttpRouting) ProtoMessage()    {}
func (*HttpRouting) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{2}
}
func (m *HttpRouting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpRouting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpRouting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpRouting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRouting.Merge(m, src)
}
func (m *HttpRouting) XXX_Size() int {
	return m.Size()
}
func (m *HttpRouting) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRouting.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRouting proto.InternalMessageInfo

func (m *HttpRouting) GetStickySession() *HttpRouting_StickySession {
	if m != nil {
		return m.StickySession
	}
	return nil
}

func (m *HttpRouting) GetCorsPolicy() *CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *HttpRouting) GetRules() []*HttpRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// Describes a HTTP cookie that will be used for sticky sessions. If the cookie is not present, it
// will be generated.
type HttpRouting_HTTPCookie struct {
	// Name of the cookie.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Lifetime of the cookie.
	Ttl                  *types.Duration `protobuf:"bytes,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *HttpRouting_HTTPCookie) Reset()         { *m = HttpRouting_HTTPCookie{} }
func (m *HttpRouting_HTTPCookie) String() string { return proto.CompactTextString(m) }
func (*HttpRouting_HTTPCookie) ProtoMessage()    {}
func (*HttpRouting_HTTPCookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{2, 0}
}
func (m *HttpRouting_HTTPCookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpRouting_HTTPCookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpRouting_HTTPCookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpRouting_HTTPCookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRouting_HTTPCookie.Merge(m, src)
}
func (m *HttpRouting_HTTPCookie) XXX_Size() int {
	return m.Size()
}
func (m *HttpRouting_HTTPCookie) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRouting_HTTPCookie.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRouting_HTTPCookie proto.InternalMessageInfo

func (m *HttpRouting_HTTPCookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HttpRouting_HTTPCookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HttpRouting_HTTPCookie) GetTtl() *types.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

// If set, the load balancer will route all requests from a particular client to the same backend
// of the service.
type HttpRouting_StickySession struct {
	// Types that are valid to be assigned to HashKey:
	//	*HttpRouting_StickySession_Header
	//	*HttpRouting_StickySession_Cookie
	//	*HttpRouting_StickySession_UseSourceIp
	HashKey              isHttpRouting_StickySession_HashKey `protobuf_oneof:"hash_key"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *HttpRouting_StickySession) Reset()         { *m = HttpRouting_StickySession{} }
func (m *HttpRouting_StickySession) String() string { return proto.CompactTextString(m) }
func (*HttpRouting_StickySession) ProtoMessage()    {}
func (*HttpRouting_StickySession) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{2, 1}
}
func (m *HttpRouting_StickySession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpRouting_StickySession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpRouting_StickySession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpRouting_StickySession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRouting_StickySession.Merge(m, src)
}
func (m *HttpRouting_StickySession) XXX_Size() int {
	return m.Size()
}
func (m *HttpRouting_StickySession) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRouting_StickySession.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRouting_StickySession proto.InternalMessageInfo

type isHttpRouting_StickySession_HashKey interface {
	isHttpRouting_StickySession_HashKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpRouting_StickySession_Header struct {
	Header string `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}
type HttpRouting_StickySession_Cookie struct {
	Cookie *HttpRouting_HTTPCookie `protobuf:"bytes,2,opt,name=cookie,proto3,oneof"`
}
type HttpRouting_StickySession_UseSourceIp struct {
	UseSourceIp bool `protobuf:"varint,3,opt,name=use_source_ip,json=useSourceIp,proto3,oneof"`
}

func (*HttpRouting_StickySession_Header) isHttpRouting_StickySession_HashKey()      {}
func (*HttpRouting_StickySession_Cookie) isHttpRouting_StickySession_HashKey()      {}
func (*HttpRouting_StickySession_UseSourceIp) isHttpRouting_StickySession_HashKey() {}

func (m *HttpRouting_StickySession) GetHashKey() isHttpRouting_StickySession_HashKey {
	if m != nil {
		return m.HashKey
	}
	return nil
}

func (m *HttpRouting_StickySession) GetHeader() string {
	if x, ok := m.GetHashKey().(*HttpRouting_StickySession_Header); ok {
		return x.Header
	}
	return ""
}

func (m *HttpRouting_StickySession) GetCookie() *HttpRouting_HTTPCookie {
	if x, ok := m.GetHashKey().(*HttpRouting_StickySession_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *HttpRouting_StickySession) GetUseSourceIp() bool {
	if x, ok := m.GetHashKey().(*HttpRouting_StickySession_UseSourceIp); ok {
		return x.UseSourceIp
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HttpRouting_StickySession) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HttpRouting_StickySession_Header)(nil),
		(*HttpRouting_StickySession_Cookie)(nil),
		(*HttpRouting_StickySession_UseSourceIp)(nil),
	}
}

// A single HTTP rule.
type HttpRule struct {
	// One or more match conditions (OR-ed).
	Match []*HttpMatchCondition `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// One or more mutations to be performed before forwarding. Includes typical modifications to be
	// done on a single request like URL rewrite, host rewrite, headers to add/remove/append.
	Modify *HttpModifyAction `protobuf:"bytes,2,opt,name=modify,proto3" json:"modify,omitempty"`
	// Types that are valid to be assigned to RouteOrRedirect:
	//	*HttpRule_Route
	//	*HttpRule_Redirect
	RouteOrRedirect      isHttpRule_RouteOrRedirect `protobuf_oneof:"route_or_redirect"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *HttpRule) Reset()         { *m = HttpRule{} }
func (m *HttpRule) String() string { return proto.CompactTextString(m) }
func (*HttpRule) ProtoMessage()    {}
func (*HttpRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{3}
}
func (m *HttpRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRule.Merge(m, src)
}
func (m *HttpRule) XXX_Size() int {
	return m.Size()
}
func (m *HttpRule) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRule.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRule proto.InternalMessageInfo

type isHttpRule_RouteOrRedirect interface {
	isHttpRule_RouteOrRedirect()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpRule_Route struct {
	Route *Route `protobuf:"bytes,3,opt,name=route,proto3,oneof"`
}
type HttpRule_Redirect struct {
	Redirect *Redirect `protobuf:"bytes,4,opt,name=redirect,proto3,oneof"`
}

func (*HttpRule_Route) isHttpRule_RouteOrRedirect()    {}
func (*HttpRule_Redirect) isHttpRule_RouteOrRedirect() {}

func (m *HttpRule) GetRouteOrRedirect() isHttpRule_RouteOrRedirect {
	if m != nil {
		return m.RouteOrRedirect
	}
	return nil
}

func (m *HttpRule) GetMatch() []*HttpMatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HttpRule) GetModify() *HttpModifyAction {
	if m != nil {
		return m.Modify
	}
	return nil
}

func (m *HttpRule) GetRoute() *Route {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Route); ok {
		return x.Route
	}
	return nil
}

func (m *HttpRule) GetRedirect() *Redirect {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Redirect); ok {
		return x.Redirect
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HttpRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HttpRule_Route)(nil),
		(*HttpRule_Redirect)(nil),
	}
}

// A single match clause to match all aspects of a request.
type HttpMatchCondition struct {
	// URI to match.
	Uri *StringMatch `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id.
	Headers              map[string]*StringMatch `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HttpMatchCondition) Reset()         { *m = HttpMatchCondition{} }
func (m *HttpMatchCondition) String() string { return proto.CompactTextString(m) }
func (*HttpMatchCondition) ProtoMessage()    {}
func (*HttpMatchCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{4}
}
func (m *HttpMatchCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpMatchCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpMatchCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpMatchCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMatchCondition.Merge(m, src)
}
func (m *HttpMatchCondition) XXX_Size() int {
	return m.Size()
}
func (m *HttpMatchCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMatchCondition.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMatchCondition proto.InternalMessageInfo

func (m *HttpMatchCondition) GetUri() *StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func (m *HttpMatchCondition) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Describes how to match a given string in HTTP headers. Match is case-sensitive.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StringMatch) Reset()         { *m = StringMatch{} }
func (m *StringMatch) String() string { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()    {}
func (*StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{5}
}
func (m *StringMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatch.Merge(m, src)
}
func (m *StringMatch) XXX_Size() int {
	return m.Size()
}
func (m *StringMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatch.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatch proto.InternalMessageInfo

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StringMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

type HTTPRewrite struct {
	// Rewrite the path (or the prefix) portion of the URI with this value. If the original URI was
	// matched based on prefix, the value provided in this field will replace the corresponding
	// matched prefix.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// Rewrite the Authority/Host header with this value.
	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPRewrite) Reset()         { *m = HTTPRewrite{} }
func (m *HTTPRewrite) String() string { return proto.CompactTextString(m) }
func (*HTTPRewrite) ProtoMessage()    {}
func (*HTTPRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{6}
}
func (m *HTTPRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPRewrite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPRewrite.Merge(m, src)
}
func (m *HTTPRewrite) XXX_Size() int {
	return m.Size()
}
func (m *HTTPRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPRewrite proto.InternalMessageInfo

func (m *HTTPRewrite) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *HTTPRewrite) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

// Header manipulation rules.
type Headers struct {
	// Header manipulation rules to apply before forwarding a request to the destination service.
	Request *Headers_HeaderOperations `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// Header manipulation rules to apply before returning a response to the caller.
	Response             *Headers_HeaderOperations `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Headers) Reset()         { *m = Headers{} }
func (m *Headers) String() string { return proto.CompactTextString(m) }
func (*Headers) ProtoMessage()    {}
func (*Headers) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{7}
}
func (m *Headers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Headers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Headers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Headers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Headers.Merge(m, src)
}
func (m *Headers) XXX_Size() int {
	return m.Size()
}
func (m *Headers) XXX_DiscardUnknown() {
	xxx_messageInfo_Headers.DiscardUnknown(m)
}

var xxx_messageInfo_Headers proto.InternalMessageInfo

func (m *Headers) GetRequest() *Headers_HeaderOperations {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Headers) GetResponse() *Headers_HeaderOperations {
	if m != nil {
		return m.Response
	}
	return nil
}

// HeaderOperations Describes the header manipulations to apply.
type Headers_HeaderOperations struct {
	// Overwrite the headers specified by key with the given values.
	Set map[string]string `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Append the given values to the headers specified by keys (will create a comma-separated list
	// of values).
	Add map[string]string `protobuf:"bytes,2,rep,name=add,proto3" json:"add,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Remove a the specified headers.
	Remove               []string `protobuf:"bytes,3,rep,name=remove,proto3" json:"remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Headers_HeaderOperations) Reset()         { *m = Headers_HeaderOperations{} }
func (m *Headers_HeaderOperations) String() string { return proto.CompactTextString(m) }
func (*Headers_HeaderOperations) ProtoMessage()    {}
func (*Headers_HeaderOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{7, 0}
}
func (m *Headers_HeaderOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Headers_HeaderOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Headers_HeaderOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Headers_HeaderOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Headers_HeaderOperations.Merge(m, src)
}
func (m *Headers_HeaderOperations) XXX_Size() int {
	return m.Size()
}
func (m *Headers_HeaderOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_Headers_HeaderOperations.DiscardUnknown(m)
}

var xxx_messageInfo_Headers_HeaderOperations proto.InternalMessageInfo

func (m *Headers_HeaderOperations) GetSet() map[string]string {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Headers_HeaderOperations) GetAdd() map[string]string {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *Headers_HeaderOperations) GetRemove() []string {
	if m != nil {
		return m.Remove
	}
	return nil
}

// HTTP path/url/header modification.
type HttpModifyAction struct {
	Rewrite              *HTTPRewrite `protobuf:"bytes,1,opt,name=rewrite,proto3" json:"rewrite,omitempty"`
	Headers              *Headers     `protobuf:"bytes,2,opt,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HttpModifyAction) Reset()         { *m = HttpModifyAction{} }
func (m *HttpModifyAction) String() string { return proto.CompactTextString(m) }
func (*HttpModifyAction) ProtoMessage()    {}
func (*HttpModifyAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{8}
}
func (m *HttpModifyAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpModifyAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpModifyAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpModifyAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpModifyAction.Merge(m, src)
}
func (m *HttpModifyAction) XXX_Size() int {
	return m.Size()
}
func (m *HttpModifyAction) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpModifyAction.DiscardUnknown(m)
}

var xxx_messageInfo_HttpModifyAction proto.InternalMessageInfo

func (m *HttpModifyAction) GetRewrite() *HTTPRewrite {
	if m != nil {
		return m.Rewrite
	}
	return nil
}

func (m *HttpModifyAction) GetHeaders() *Headers {
	if m != nil {
		return m.Headers
	}
	return nil
}

// One or more destinations in a local cluster for the given request.
type Route struct {
	// The destination service in `<namespace>/<fqdn>` format.
	Host                 string   `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{9}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Route) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Redirect struct {
	// On a redirect, overwrite the Path portion of the URL with this value.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// On a redirect, overwrite the Authority/Host portion of the URL with this value.
	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redirect) Reset()         { *m = Redirect{} }
func (m *Redirect) String() string { return proto.CompactTextString(m) }
func (*Redirect) ProtoMessage()    {}
func (*Redirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{10}
}
func (m *Redirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Redirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Redirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Redirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redirect.Merge(m, src)
}
func (m *Redirect) XXX_Size() int {
	return m.Size()
}
func (m *Redirect) XXX_DiscardUnknown() {
	xxx_messageInfo_Redirect.DiscardUnknown(m)
}

var xxx_messageInfo_Redirect proto.InternalMessageInfo

func (m *Redirect) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Redirect) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

type CorsPolicy struct {
	// The list of origins that are allowed to perform CORS requests. The content will be serialized
	// into the Access-Control-Allow-Origin header. Wildcard * will allow all origins.
	AllowOrigin []string `protobuf:"bytes,1,rep,name=allow_origin,json=allowOrigin,proto3" json:"allow_origin,omitempty"`
	// List of HTTP methods allowed to access the resource. The content will be serialized into the
	// Access-Control-Allow-Methods header.
	AllowMethods []string `protobuf:"bytes,2,rep,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// List of HTTP headers that can be used when requesting the resource. Serialized to
	// Access-Control-Allow-Headers header.
	AllowHeaders []string `protobuf:"bytes,3,rep,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// A white list of HTTP headers that the browsers are allowed to access. Serialized into
	// Access-Control-Expose-Headers header.
	ExposeHeaders []string `protobuf:"bytes,4,rep,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// Specifies how long the results of a preflight request can be cached. Translates to the
	// Access-Control-Max-Age header.
	MaxAge *types.Duration `protobuf:"bytes,5,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// Indicates whether the caller is allowed to send the actual request (not the preflight) using
	// credentials. Translates to Access-Control-Allow-Credentials header.
	AllowCredentials     *types.BoolValue `protobuf:"bytes,6,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CorsPolicy) Reset()         { *m = CorsPolicy{} }
func (m *CorsPolicy) String() string { return proto.CompactTextString(m) }
func (*CorsPolicy) ProtoMessage()    {}
func (*CorsPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{11}
}
func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorsPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorsPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorsPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorsPolicy.Merge(m, src)
}
func (m *CorsPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CorsPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CorsPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CorsPolicy proto.InternalMessageInfo

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() []string {
	if m != nil {
		return m.AllowMethods
	}
	return nil
}

func (m *CorsPolicy) GetAllowHeaders() []string {
	if m != nil {
		return m.AllowHeaders
	}
	return nil
}

func (m *CorsPolicy) GetExposeHeaders() []string {
	if m != nil {
		return m.ExposeHeaders
	}
	return nil
}

func (m *CorsPolicy) GetMaxAge() *types.Duration {
	if m != nil {
		return m.MaxAge
	}
	return nil
}

func (m *CorsPolicy) GetAllowCredentials() *types.BoolValue {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

type ServerTLSSettings struct {
	// Set this to SIMPLE, or MUTUAL for one-way TLS, mutual TLS
	// respectively.
	Mode ServerTLSSettings_TLSMode `protobuf:"varint,1,opt,name=mode,proto3,enum=tetrateio.api.tsb.gateway.v1.ServerTLSSettings_TLSMode" json:"mode,omitempty"`
	// The name of the secret in Kubernetes that holds the TLS certs
	// including the CA certificates. The secret (type generic) should
	// contain the following keys and values: key: `<privateKey>`, cert:
	// `<serverCert>`, cacert: `<CACertificate>`.
	SecretName           string   `protobuf:"bytes,2,opt,name=secret_name,json=secretName,proto3" json:"secret_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerTLSSettings) Reset()         { *m = ServerTLSSettings{} }
func (m *ServerTLSSettings) String() string { return proto.CompactTextString(m) }
func (*ServerTLSSettings) ProtoMessage()    {}
func (*ServerTLSSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{12}
}
func (m *ServerTLSSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerTLSSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerTLSSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerTLSSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerTLSSettings.Merge(m, src)
}
func (m *ServerTLSSettings) XXX_Size() int {
	return m.Size()
}
func (m *ServerTLSSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerTLSSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ServerTLSSettings proto.InternalMessageInfo

func (m *ServerTLSSettings) GetMode() ServerTLSSettings_TLSMode {
	if m != nil {
		return m.Mode
	}
	return ServerTLSSettings_DISABLED
}

func (m *ServerTLSSettings) GetSecretName() string {
	if m != nil {
		return m.SecretName
	}
	return ""
}

type Authentication struct {
	// Types that are valid to be assigned to Authn:
	//	*Authentication_Jwt
	Authn                isAuthentication_Authn `protobuf_oneof:"authn"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Authentication) Reset()         { *m = Authentication{} }
func (m *Authentication) String() string { return proto.CompactTextString(m) }
func (*Authentication) ProtoMessage()    {}
func (*Authentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{13}
}
func (m *Authentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authentication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authentication.Merge(m, src)
}
func (m *Authentication) XXX_Size() int {
	return m.Size()
}
func (m *Authentication) XXX_DiscardUnknown() {
	xxx_messageInfo_Authentication.DiscardUnknown(m)
}

var xxx_messageInfo_Authentication proto.InternalMessageInfo

type isAuthentication_Authn interface {
	isAuthentication_Authn()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Authentication_Jwt struct {
	Jwt *Authentication_JWT `protobuf:"bytes,1,opt,name=jwt,proto3,oneof"`
}

func (*Authentication_Jwt) isAuthentication_Authn() {}

func (m *Authentication) GetAuthn() isAuthentication_Authn {
	if m != nil {
		return m.Authn
	}
	return nil
}

func (m *Authentication) GetJwt() *Authentication_JWT {
	if x, ok := m.GetAuthn().(*Authentication_Jwt); ok {
		return x.Jwt
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Authentication) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Authentication_Jwt)(nil),
	}
}

type Authentication_JWT struct {
	// Identifies the issuer that issued the JWT. See
	// [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1)
	// A JWT with different `iss` claim will be rejected.
	//
	// Example: https://foobar.auth0.com
	// Example: 1234567-compute@developer.gserviceaccount.com
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// The list of JWT
	// [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3).
	// that are allowed to access. A JWT containing any of these
	// audiences will be accepted.
	//
	// The service name will be accepted if audiences is empty.
	Audiences []string `protobuf:"bytes,2,rep,name=audiences,proto3" json:"audiences,omitempty"`
	// Types that are valid to be assigned to Keys:
	//	*Authentication_JWT_JwksUri
	//	*Authentication_JWT_Jwks
	Keys                 isAuthentication_JWT_Keys `protobuf_oneof:"keys"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Authentication_JWT) Reset()         { *m = Authentication_JWT{} }
func (m *Authentication_JWT) String() string { return proto.CompactTextString(m) }
func (*Authentication_JWT) ProtoMessage()    {}
func (*Authentication_JWT) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{13, 0}
}
func (m *Authentication_JWT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authentication_JWT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authentication_JWT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authentication_JWT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authentication_JWT.Merge(m, src)
}
func (m *Authentication_JWT) XXX_Size() int {
	return m.Size()
}
func (m *Authentication_JWT) XXX_DiscardUnknown() {
	xxx_messageInfo_Authentication_JWT.DiscardUnknown(m)
}

var xxx_messageInfo_Authentication_JWT proto.InternalMessageInfo

type isAuthentication_JWT_Keys interface {
	isAuthentication_JWT_Keys()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Authentication_JWT_JwksUri struct {
	JwksUri string `protobuf:"bytes,3,opt,name=jwks_uri,json=jwksUri,proto3,oneof"`
}
type Authentication_JWT_Jwks struct {
	Jwks string `protobuf:"bytes,4,opt,name=jwks,proto3,oneof"`
}

func (*Authentication_JWT_JwksUri) isAuthentication_JWT_Keys() {}
func (*Authentication_JWT_Jwks) isAuthentication_JWT_Keys()    {}

func (m *Authentication_JWT) GetKeys() isAuthentication_JWT_Keys {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Authentication_JWT) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *Authentication_JWT) GetAudiences() []string {
	if m != nil {
		return m.Audiences
	}
	return nil
}

func (m *Authentication_JWT) GetJwksUri() string {
	if x, ok := m.GetKeys().(*Authentication_JWT_JwksUri); ok {
		return x.JwksUri
	}
	return ""
}

func (m *Authentication_JWT) GetJwks() string {
	if x, ok := m.GetKeys().(*Authentication_JWT_Jwks); ok {
		return x.Jwks
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Authentication_JWT) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Authentication_JWT_JwksUri)(nil),
		(*Authentication_JWT_Jwks)(nil),
	}
}

type Authorization struct {
	// Types that are valid to be assigned to Authz:
	//	*Authorization_External
	//	*Authorization_Local
	Authz                isAuthorization_Authz `protobuf_oneof:"authz"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Authorization) Reset()         { *m = Authorization{} }
func (m *Authorization) String() string { return proto.CompactTextString(m) }
func (*Authorization) ProtoMessage()    {}
func (*Authorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{14}
}
func (m *Authorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorization.Merge(m, src)
}
func (m *Authorization) XXX_Size() int {
	return m.Size()
}
func (m *Authorization) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorization.DiscardUnknown(m)
}

var xxx_messageInfo_Authorization proto.InternalMessageInfo

type isAuthorization_Authz interface {
	isAuthorization_Authz()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Authorization_External struct {
	External *Authorization_ExternalAuthzBackend `protobuf:"bytes,1,opt,name=external,proto3,oneof"`
}
type Authorization_Local struct {
	Local *Authorization_LocalAuthz `protobuf:"bytes,2,opt,name=local,proto3,oneof"`
}

func (*Authorization_External) isAuthorization_Authz() {}
func (*Authorization_Local) isAuthorization_Authz()    {}

func (m *Authorization) GetAuthz() isAuthorization_Authz {
	if m != nil {
		return m.Authz
	}
	return nil
}

func (m *Authorization) GetExternal() *Authorization_ExternalAuthzBackend {
	if x, ok := m.GetAuthz().(*Authorization_External); ok {
		return x.External
	}
	return nil
}

func (m *Authorization) GetLocal() *Authorization_LocalAuthz {
	if x, ok := m.GetAuthz().(*Authorization_Local); ok {
		return x.Local
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Authorization) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Authorization_External)(nil),
		(*Authorization_Local)(nil),
	}
}

type Authorization_ExternalAuthzBackend struct {
	Uri                   string   `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	IncludeRequestHeaders []string `protobuf:"bytes,2,rep,name=include_request_headers,json=includeRequestHeaders,proto3" json:"include_request_headers,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Authorization_ExternalAuthzBackend) Reset()         { *m = Authorization_ExternalAuthzBackend{} }
func (m *Authorization_ExternalAuthzBackend) String() string { return proto.CompactTextString(m) }
func (*Authorization_ExternalAuthzBackend) ProtoMessage()    {}
func (*Authorization_ExternalAuthzBackend) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{14, 0}
}
func (m *Authorization_ExternalAuthzBackend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authorization_ExternalAuthzBackend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authorization_ExternalAuthzBackend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authorization_ExternalAuthzBackend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorization_ExternalAuthzBackend.Merge(m, src)
}
func (m *Authorization_ExternalAuthzBackend) XXX_Size() int {
	return m.Size()
}
func (m *Authorization_ExternalAuthzBackend) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorization_ExternalAuthzBackend.DiscardUnknown(m)
}

var xxx_messageInfo_Authorization_ExternalAuthzBackend proto.InternalMessageInfo

func (m *Authorization_ExternalAuthzBackend) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Authorization_ExternalAuthzBackend) GetIncludeRequestHeaders() []string {
	if m != nil {
		return m.IncludeRequestHeaders
	}
	return nil
}

type Authorization_LocalAuthz struct {
	Rules                []*LocalAuthzRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Authorization_LocalAuthz) Reset()         { *m = Authorization_LocalAuthz{} }
func (m *Authorization_LocalAuthz) String() string { return proto.CompactTextString(m) }
func (*Authorization_LocalAuthz) ProtoMessage()    {}
func (*Authorization_LocalAuthz) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{14, 1}
}
func (m *Authorization_LocalAuthz) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authorization_LocalAuthz) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authorization_LocalAuthz.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authorization_LocalAuthz) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorization_LocalAuthz.Merge(m, src)
}
func (m *Authorization_LocalAuthz) XXX_Size() int {
	return m.Size()
}
func (m *Authorization_LocalAuthz) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorization_LocalAuthz.DiscardUnknown(m)
}

var xxx_messageInfo_Authorization_LocalAuthz proto.InternalMessageInfo

func (m *Authorization_LocalAuthz) GetRules() []*LocalAuthzRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// LocalAuthzRule
//
// Bindings define the subjects that can access the resource a policy is attached to,
// and the conditions that need to be met for that access to be granted.
// A policy can have multiple bindings to configure different access controls for specific
// subjects.
type LocalAuthzRule struct {
	// A friendly name to identify the binding.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Subjects configure the actors (end users, other services)  that are allowed to access the
	// target resource.
	From []*Subject `protobuf:"bytes,2,rep,name=from,proto3" json:"from,omitempty"`
	// A set of HTTP rules that need to be satisfied by the HTTP requests to get access to the
	// target resource.
	To                   []*LocalAuthzRule_HttpOperation `protobuf:"bytes,3,rep,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *LocalAuthzRule) Reset()         { *m = LocalAuthzRule{} }
func (m *LocalAuthzRule) String() string { return proto.CompactTextString(m) }
func (*LocalAuthzRule) ProtoMessage()    {}
func (*LocalAuthzRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{15}
}
func (m *LocalAuthzRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalAuthzRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalAuthzRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalAuthzRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalAuthzRule.Merge(m, src)
}
func (m *LocalAuthzRule) XXX_Size() int {
	return m.Size()
}
func (m *LocalAuthzRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalAuthzRule.DiscardUnknown(m)
}

var xxx_messageInfo_LocalAuthzRule proto.InternalMessageInfo

func (m *LocalAuthzRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocalAuthzRule) GetFrom() []*Subject {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *LocalAuthzRule) GetTo() []*LocalAuthzRule_HttpOperation {
	if m != nil {
		return m.To
	}
	return nil
}

type LocalAuthzRule_HttpOperation struct {
	// The request path where the request is made against. E.g. ["/accounts"].
	Paths []string `protobuf:"bytes,2,rep,name=paths,proto3" json:"paths,omitempty"`
	// The HTTP methods that are allowed by this rule. E.g. ["GET", "HEAD"].
	Methods              []string `protobuf:"bytes,3,rep,name=methods,proto3" json:"methods,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalAuthzRule_HttpOperation) Reset()         { *m = LocalAuthzRule_HttpOperation{} }
func (m *LocalAuthzRule_HttpOperation) String() string { return proto.CompactTextString(m) }
func (*LocalAuthzRule_HttpOperation) ProtoMessage()    {}
func (*LocalAuthzRule_HttpOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{15, 0}
}
func (m *LocalAuthzRule_HttpOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalAuthzRule_HttpOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalAuthzRule_HttpOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalAuthzRule_HttpOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalAuthzRule_HttpOperation.Merge(m, src)
}
func (m *LocalAuthzRule_HttpOperation) XXX_Size() int {
	return m.Size()
}
func (m *LocalAuthzRule_HttpOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalAuthzRule_HttpOperation.DiscardUnknown(m)
}

var xxx_messageInfo_LocalAuthzRule_HttpOperation proto.InternalMessageInfo

func (m *LocalAuthzRule_HttpOperation) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *LocalAuthzRule_HttpOperation) GetMethods() []string {
	if m != nil {
		return m.Methods
	}
	return nil
}

// Subject
//
// A subject designates an actor (user, service, etc) that attempts to access a target resource.
// Subjects can be modeled with JWT tokens, service accounts, and decorated with attributes such as
// HTTP request headers, JWT token claims, etc.
// The fields that define a subject will be matched to incoming requests, to fully qualify where the
// request comes from, and to decide if the given request is allowed or not for the target resource.
// All the fields in a subject are evaluated as AND expressions.
type Subject struct {
	// JWT configuration to identity the subject.
	Jwt                  *Subject_JWTClaims `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Subject) Reset()         { *m = Subject{} }
func (m *Subject) String() string { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()    {}
func (*Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{16}
}
func (m *Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject.Merge(m, src)
}
func (m *Subject) XXX_Size() int {
	return m.Size()
}
func (m *Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Subject proto.InternalMessageInfo

func (m *Subject) GetJwt() *Subject_JWTClaims {
	if m != nil {
		return m.Jwt
	}
	return nil
}

// JWT based subject
//
// JWT based subjects qualify a subject by matching against a JWT token present in the request.
// By default the token is expected to be present in the 'Authorization' HTTP header, with the
// 'Bearer" prefix.
type Subject_JWTClaims struct {
	Iss string `protobuf:"bytes,1,opt,name=iss,proto3" json:"iss,omitempty"`
	Sub string `protobuf:"bytes,2,opt,name=sub,proto3" json:"sub,omitempty"`
	// A set of arbitrary claims that are required to qualify the subject.
	// E.g. "iss": "*@foo.com".
	Other                map[string]string `protobuf:"bytes,3,rep,name=other,proto3" json:"other,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Subject_JWTClaims) Reset()         { *m = Subject_JWTClaims{} }
func (m *Subject_JWTClaims) String() string { return proto.CompactTextString(m) }
func (*Subject_JWTClaims) ProtoMessage()    {}
func (*Subject_JWTClaims) Descriptor() ([]byte, []int) {
	return fileDescriptor_fadc6dad86532561, []int{16, 0}
}
func (m *Subject_JWTClaims) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject_JWTClaims) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject_JWTClaims.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject_JWTClaims) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject_JWTClaims.Merge(m, src)
}
func (m *Subject_JWTClaims) XXX_Size() int {
	return m.Size()
}
func (m *Subject_JWTClaims) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject_JWTClaims.DiscardUnknown(m)
}

var xxx_messageInfo_Subject_JWTClaims proto.InternalMessageInfo

func (m *Subject_JWTClaims) GetIss() string {
	if m != nil {
		return m.Iss
	}
	return ""
}

func (m *Subject_JWTClaims) GetSub() string {
	if m != nil {
		return m.Sub
	}
	return ""
}

func (m *Subject_JWTClaims) GetOther() map[string]string {
	if m != nil {
		return m.Other
	}
	return nil
}

func init() {
	proto.RegisterEnum("tetrateio.api.tsb.gateway.v1.ServerTLSSettings_TLSMode", ServerTLSSettings_TLSMode_name, ServerTLSSettings_TLSMode_value)
	proto.RegisterType((*IngressGateway)(nil), "tetrateio.api.tsb.gateway.v1.IngressGateway")
	proto.RegisterType((*HttpServer)(nil), "tetrateio.api.tsb.gateway.v1.HttpServer")
	proto.RegisterType((*HttpRouting)(nil), "tetrateio.api.tsb.gateway.v1.HttpRouting")
	proto.RegisterType((*HttpRouting_HTTPCookie)(nil), "tetrateio.api.tsb.gateway.v1.HttpRouting.HTTPCookie")
	proto.RegisterType((*HttpRouting_StickySession)(nil), "tetrateio.api.tsb.gateway.v1.HttpRouting.StickySession")
	proto.RegisterType((*HttpRule)(nil), "tetrateio.api.tsb.gateway.v1.HttpRule")
	proto.RegisterType((*HttpMatchCondition)(nil), "tetrateio.api.tsb.gateway.v1.HttpMatchCondition")
	proto.RegisterMapType((map[string]*StringMatch)(nil), "tetrateio.api.tsb.gateway.v1.HttpMatchCondition.HeadersEntry")
	proto.RegisterType((*StringMatch)(nil), "tetrateio.api.tsb.gateway.v1.StringMatch")
	proto.RegisterType((*HTTPRewrite)(nil), "tetrateio.api.tsb.gateway.v1.HTTPRewrite")
	proto.RegisterType((*Headers)(nil), "tetrateio.api.tsb.gateway.v1.Headers")
	proto.RegisterType((*Headers_HeaderOperations)(nil), "tetrateio.api.tsb.gateway.v1.Headers.HeaderOperations")
	proto.RegisterMapType((map[string]string)(nil), "tetrateio.api.tsb.gateway.v1.Headers.HeaderOperations.AddEntry")
	proto.RegisterMapType((map[string]string)(nil), "tetrateio.api.tsb.gateway.v1.Headers.HeaderOperations.SetEntry")
	proto.RegisterType((*HttpModifyAction)(nil), "tetrateio.api.tsb.gateway.v1.HttpModifyAction")
	proto.RegisterType((*Route)(nil), "tetrateio.api.tsb.gateway.v1.Route")
	proto.RegisterType((*Redirect)(nil), "tetrateio.api.tsb.gateway.v1.Redirect")
	proto.RegisterType((*CorsPolicy)(nil), "tetrateio.api.tsb.gateway.v1.CorsPolicy")
	proto.RegisterType((*ServerTLSSettings)(nil), "tetrateio.api.tsb.gateway.v1.ServerTLSSettings")
	proto.RegisterType((*Authentication)(nil), "tetrateio.api.tsb.gateway.v1.Authentication")
	proto.RegisterType((*Authentication_JWT)(nil), "tetrateio.api.tsb.gateway.v1.Authentication.JWT")
	proto.RegisterType((*Authorization)(nil), "tetrateio.api.tsb.gateway.v1.Authorization")
	proto.RegisterType((*Authorization_ExternalAuthzBackend)(nil), "tetrateio.api.tsb.gateway.v1.Authorization.ExternalAuthzBackend")
	proto.RegisterType((*Authorization_LocalAuthz)(nil), "tetrateio.api.tsb.gateway.v1.Authorization.LocalAuthz")
	proto.RegisterType((*LocalAuthzRule)(nil), "tetrateio.api.tsb.gateway.v1.LocalAuthzRule")
	proto.RegisterType((*LocalAuthzRule_HttpOperation)(nil), "tetrateio.api.tsb.gateway.v1.LocalAuthzRule.HttpOperation")
	proto.RegisterType((*Subject)(nil), "tetrateio.api.tsb.gateway.v1.Subject")
	proto.RegisterType((*Subject_JWTClaims)(nil), "tetrateio.api.tsb.gateway.v1.Subject.JWTClaims")
	proto.RegisterMapType((map[string]string)(nil), "tetrateio.api.tsb.gateway.v1.Subject.JWTClaims.OtherEntry")
}

func init() {
	proto.RegisterFile("tsb/gateway/v1/ingress_gateway.proto", fileDescriptor_fadc6dad86532561)
}

var fileDescriptor_fadc6dad86532561 = []byte{
	// 1791 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0xe8, 0xbf, 0x9e, 0x2c, 0x63, 0x37, 0x61, 0x57, 0x88, 0x2d, 0xef, 0xee, 0x6c, 0x76,
	0x09, 0x15, 0x76, 0x94, 0x18, 0x36, 0x84, 0x2c, 0x5b, 0x41, 0xb2, 0xb5, 0x91, 0x83, 0x1d, 0x6b,
	0x5b, 0x0a, 0xa9, 0x82, 0xc2, 0x62, 0x3c, 0xd3, 0x96, 0x26, 0x1e, 0xa9, 0x87, 0xee, 0x96, 0x6c,
	0xe5, 0xc8, 0x01, 0xaa, 0xb8, 0x91, 0xd3, 0x16, 0x55, 0x7c, 0x89, 0x14, 0xc5, 0x19, 0x8a, 0x0b,
	0xdc, 0xf8, 0x08, 0x5b, 0x29, 0xf8, 0x02, 0x1c, 0x53, 0x1c, 0xb6, 0xfa, 0xcf, 0xe8, 0x8f, 0x9d,
	0x44, 0x72, 0x2e, 0xf6, 0xcc, 0x7b, 0xef, 0xf7, 0xeb, 0xee, 0xd7, 0xbf, 0x7e, 0xfd, 0x46, 0x70,
	0x55, 0xf0, 0xa3, 0x4a, 0xd7, 0x15, 0xe4, 0xd4, 0x1d, 0x57, 0x46, 0x37, 0x2b, 0xc1, 0xa0, 0xcb,
	0x08, 0xe7, 0x1d, 0x63, 0x72, 0x22, 0x46, 0x05, 0x45, 0xef, 0x08, 0x22, 0x98, 0x2b, 0x48, 0x40,
	0x1d, 0x37, 0x0a, 0x1c, 0xc1, 0x8f, 0x9c, 0x38, 0x60, 0x74, 0xb3, 0xfc, 0x6e, 0x97, 0xd2, 0x6e,
	0x48, 0x2a, 0x6e, 0x14, 0x54, 0x8e, 0x03, 0x12, 0xfa, 0x9d, 0x23, 0xd2, 0x73, 0x47, 0x01, 0x65,
	0x1a, 0x5e, 0xde, 0x34, 0x01, 0xea, 0xed, 0x68, 0x78, 0x5c, 0xf1, 0x87, 0xcc, 0x15, 0x01, 0x1d,
	0xbc, 0xca, 0x7f, 0xca, 0xdc, 0x28, 0x22, 0x8c, 0x1b, 0x7f, 0xb5, 0x1b, 0x88, 0xde, 0xf0, 0xc8,
	0xf1, 0x68, 0xbf, 0x42, 0x06, 0x23, 0x3a, 0x8e, 0x18, 0x3d, 0x1b, 0xeb, 0x70, 0xef, 0xe3, 0x2e,
	0x19, 0x7c, 0x3c, 0x72, 0xc3, 0xc0, 0x77, 0x05, 0xa9, 0x5c, 0x78, 0x30, 0x14, 0x25, 0xb9, 0x4e,
	0x31, 0x8e, 0x08, 0x97, 0xab, 0x54, 0x0f, 0xda, 0x63, 0xff, 0xc3, 0x82, 0xb5, 0x5d, 0xbd, 0xea,
	0x7b, 0x7a, 0x4d, 0xe8, 0x18, 0x36, 0x4e, 0x29, 0x3b, 0x09, 0xa9, 0xeb, 0x77, 0x38, 0x09, 0x89,
	0x27, 0x28, 0x2b, 0x59, 0xef, 0x59, 0xd7, 0x0a, 0x5b, 0xdf, 0x77, 0x2e, 0xa6, 0x42, 0xb3, 0x8d,
	0x6e, 0x3a, 0x8f, 0x0c, 0xa8, 0x65, 0x30, 0xb5, 0xc2, 0x57, 0xd5, 0xc4, 0x8b, 0x5a, 0xfa, 0x0f,
	0x56, 0x62, 0xdd, 0xc2, 0xeb, 0xa7, 0xe7, 0xdc, 0x68, 0x17, 0x52, 0x3d, 0x21, 0xa2, 0x52, 0xe2,
	0xbd, 0xe4, 0xb5, 0xc2, 0xd6, 0x35, 0xe7, 0x75, 0x59, 0x76, 0x1a, 0x42, 0x44, 0x2d, 0xc2, 0x46,
	0x64, 0x42, 0xfb, 0xd4, 0x4a, 0xe4, 0x2c, 0xac, 0x28, 0xec, 0xff, 0x26, 0x00, 0xa6, 0x11, 0xe8,
	0x23, 0xc8, 0xf5, 0x28, 0x17, 0x03, 0xb7, 0x4f, 0xd4, 0xc4, 0xf3, 0x35, 0x50, 0x98, 0x14, 0x93,
	0x33, 0x99, 0xf8, 0x50, 0x15, 0x92, 0x22, 0xe4, 0xa5, 0x84, 0x5a, 0x5b, 0xe5, 0xf5, 0x13, 0xd0,
	0xd4, 0xed, 0xbd, 0x56, 0x8b, 0x08, 0x11, 0x0c, 0xba, 0x1c, 0x4b, 0x2c, 0x6a, 0xc3, 0x9a, 0x3b,
	0x14, 0x3d, 0x32, 0x10, 0x81, 0xa7, 0x36, 0xb5, 0x94, 0x7c, 0x65, 0xa6, 0x66, 0xd8, 0xaa, 0x73,
	0x18, 0x7c, 0x8e, 0x03, 0x7d, 0x01, 0x45, 0x69, 0xa1, 0x2c, 0x78, 0xa2, 0x49, 0x53, 0x8a, 0xf4,
	0xfa, 0x62, 0xd2, 0x09, 0x04, 0xcf, 0x33, 0xa0, 0x6d, 0xc8, 0x32, 0x3a, 0x94, 0x33, 0x2f, 0xa5,
	0x15, 0xd9, 0xf7, 0x16, 0x27, 0x1c, 0x6b, 0x00, 0x8e, 0x91, 0xf6, 0x5f, 0x53, 0x50, 0x98, 0x71,
	0xa0, 0x43, 0x58, 0xe3, 0x22, 0xf0, 0x4e, 0xc6, 0x1d, 0x4e, 0x38, 0x97, 0x13, 0xd5, 0x3a, 0xf9,
	0xd1, 0xd2, 0xdc, 0x4e, 0x4b, 0xe1, 0x5b, 0x1a, 0x8e, 0x8b, 0x7c, 0xf6, 0x15, 0xed, 0x42, 0xc1,
	0xa3, 0x8c, 0x77, 0x22, 0x1a, 0x06, 0xde, 0xd8, 0x6c, 0xd4, 0x02, 0xa5, 0x6c, 0x53, 0xc6, 0x9b,
	0x2a, 0x1e, 0x83, 0x37, 0x79, 0x46, 0x3f, 0x81, 0x34, 0x1b, 0x86, 0x84, 0x97, 0x92, 0x4a, 0x6e,
	0x1f, 0x2d, 0x31, 0xc3, 0x61, 0x48, 0xb0, 0x06, 0x95, 0x7f, 0x67, 0x01, 0x34, 0xda, 0xed, 0xe6,
	0x36, 0xa5, 0x27, 0x01, 0x41, 0x9b, 0x90, 0x7a, 0x85, 0xb8, 0x94, 0x5d, 0xfa, 0x23, 0x57, 0xf4,
	0xd4, 0x84, 0xcf, 0xf9, 0xa5, 0x1d, 0xdd, 0x86, 0xa4, 0x10, 0xa1, 0x91, 0xca, 0xb7, 0x1d, 0x5d,
	0x00, 0x9c, 0xb8, 0x00, 0x38, 0x3b, 0xa6, 0x40, 0xc4, 0x52, 0x7f, 0xa6, 0xa4, 0x2e, 0x21, 0xe5,
	0xbf, 0x58, 0x50, 0x9c, 0x4b, 0x19, 0x7a, 0x1f, 0x32, 0x3d, 0xe2, 0xfa, 0x84, 0x99, 0xd9, 0x64,
	0xcd, 0x50, 0x8d, 0x15, 0x6c, 0x1c, 0xe8, 0x01, 0x64, 0x3c, 0x35, 0x71, 0x93, 0xc1, 0x1f, 0x2e,
	0xbf, 0x3d, 0xd3, 0x45, 0x4b, 0x3e, 0xcd, 0x82, 0xae, 0x42, 0x71, 0xc8, 0x49, 0x87, 0xd3, 0x21,
	0xf3, 0x48, 0x27, 0x88, 0xd4, 0x42, 0x72, 0x8d, 0x15, 0x5c, 0x18, 0x72, 0xd2, 0x52, 0xd6, 0xdd,
	0xa8, 0x06, 0x90, 0xeb, 0xb9, 0xbc, 0xd7, 0x39, 0x21, 0x63, 0xfb, 0x59, 0x02, 0x72, 0x71, 0x4e,
	0xd1, 0xe7, 0x90, 0xee, 0xbb, 0xc2, 0xeb, 0x95, 0x2c, 0xb5, 0x15, 0x37, 0x16, 0xcf, 0x66, 0x5f,
	0x86, 0x6f, 0xd3, 0x81, 0x1f, 0x28, 0x69, 0x6b, 0x38, 0xfa, 0x1c, 0x32, 0x7d, 0xea, 0x07, 0xc7,
	0xb1, 0x30, 0x9c, 0x25, 0x88, 0x54, 0x7c, 0xd5, 0x53, 0x34, 0x06, 0x8d, 0x3e, 0x85, 0xb4, 0x14,
	0x38, 0x31, 0xfb, 0xf1, 0xc1, 0xeb, 0x69, 0x64, 0x66, 0x64, 0x32, 0x34, 0x06, 0xed, 0x40, 0x8e,
	0x11, 0x3f, 0x60, 0xc4, 0x13, 0xe6, 0x94, 0x2e, 0x90, 0x16, 0x36, 0xd1, 0x8d, 0x15, 0x3c, 0x41,
	0xd6, 0xbe, 0x09, 0x1b, 0x8a, 0xae, 0x43, 0x59, 0x27, 0x36, 0xda, 0x7f, 0x4c, 0x00, 0xba, 0xb8,
	0x7a, 0xf4, 0x29, 0x24, 0x87, 0x2c, 0x30, 0x27, 0x6d, 0xc1, 0x29, 0x6e, 0x09, 0x16, 0x0c, 0xba,
	0x8a, 0x00, 0x4b, 0x14, 0x7a, 0x04, 0x59, 0x2d, 0x0a, 0x6e, 0xea, 0xee, 0x67, 0x97, 0xcd, 0xbe,
	0xd3, 0xd0, 0xf8, 0xfa, 0x40, 0xb0, 0x31, 0x8e, 0xd9, 0xca, 0x04, 0x56, 0x67, 0x1d, 0x68, 0x1d,
	0x92, 0x27, 0x64, 0xac, 0x35, 0x89, 0xe5, 0x23, 0xba, 0x0b, 0xe9, 0x91, 0x1b, 0x0e, 0x63, 0x11,
	0x5e, 0x62, 0xe6, 0x1a, 0x77, 0x27, 0x71, 0xdb, 0xb2, 0x09, 0x14, 0x66, 0x3c, 0xe8, 0x2d, 0x48,
	0x93, 0x33, 0xd7, 0x13, 0x7a, 0x1c, 0xb9, 0x2b, 0xea, 0x15, 0x95, 0x20, 0x13, 0x31, 0x72, 0x1c,
	0x9c, 0xe9, 0x23, 0x28, 0xb5, 0xab, 0xdf, 0x25, 0x82, 0x91, 0x2e, 0x39, 0x53, 0x9b, 0xad, 0x10,
	0xea, 0xb5, 0xb6, 0x0a, 0xa0, 0x54, 0xd5, 0x91, 0xf7, 0x99, 0xfd, 0x19, 0x14, 0xa4, 0xf2, 0x31,
	0x39, 0x65, 0x81, 0x20, 0x72, 0x31, 0x71, 0xca, 0xf3, 0x3a, 0x8f, 0xef, 0x40, 0xde, 0xd4, 0x57,
	0xa1, 0xe5, 0x97, 0xc7, 0x53, 0x83, 0xfd, 0xbf, 0x24, 0x64, 0x4d, 0x36, 0x50, 0x13, 0xb2, 0x8c,
	0xfc, 0x66, 0x48, 0xb8, 0x30, 0x5b, 0x76, 0x6b, 0x41, 0xc6, 0x35, 0xce, 0xfc, 0x3f, 0x88, 0x88,
	0xae, 0x05, 0x1c, 0xc7, 0x34, 0x08, 0x4b, 0xc9, 0xf1, 0x88, 0x0e, 0x78, 0x9c, 0xcb, 0x37, 0xa5,
	0x9c, 0xf0, 0x94, 0xff, 0x96, 0x80, 0xf5, 0xf3, 0x6e, 0xf4, 0x05, 0x24, 0x39, 0x11, 0xe6, 0x98,
	0xde, 0x7d, 0xb3, 0x31, 0x9c, 0x16, 0x11, 0x5a, 0x2a, 0x92, 0x4b, 0x52, 0xba, 0xbe, 0x6f, 0xb4,
	0xf7, 0xa6, 0x94, 0x55, 0xdf, 0x37, 0x94, 0xae, 0xef, 0xa3, 0xb7, 0x20, 0xc3, 0x48, 0x9f, 0x8e,
	0x88, 0x2a, 0xed, 0x79, 0x6c, 0xde, 0xca, 0xb7, 0x20, 0x17, 0x8f, 0xfd, 0x12, 0x35, 0x5e, 0x99,
	0x55, 0x63, 0x7e, 0x46, 0x62, 0x12, 0x17, 0x0f, 0x70, 0x19, 0x9c, 0xfd, 0xa5, 0x05, 0xeb, 0xe7,
	0x6b, 0x8c, 0xba, 0x76, 0xb5, 0x88, 0x96, 0x3b, 0xb0, 0x33, 0xaa, 0xc3, 0x31, 0x12, 0xdd, 0x9d,
	0x3d, 0xb4, 0x92, 0xe4, 0xc3, 0xa5, 0x12, 0x37, 0x39, 0x9c, 0x76, 0x03, 0xd2, 0xaa, 0x6c, 0xa1,
	0xeb, 0x90, 0x92, 0xdd, 0x8f, 0xb9, 0x2a, 0xde, 0x56, 0xd7, 0xcb, 0x06, 0xfb, 0xc6, 0x56, 0xf1,
	0xf0, 0x97, 0x87, 0x95, 0x5f, 0x5d, 0xaf, 0xa8, 0xbf, 0x57, 0xb1, 0x0a, 0x42, 0x08, 0x52, 0x11,
	0x65, 0x42, 0x8d, 0x59, 0xc4, 0xea, 0xd9, 0xbe, 0x03, 0xb9, 0xb8, 0x80, 0x5d, 0xfa, 0x54, 0xfc,
	0x39, 0x01, 0x30, 0xbd, 0x9d, 0xd1, 0xfb, 0xb0, 0xea, 0x86, 0x21, 0x3d, 0xed, 0x50, 0x16, 0x74,
	0x83, 0x81, 0x92, 0x59, 0x1e, 0x17, 0x94, 0xed, 0x40, 0x99, 0xd0, 0x07, 0x50, 0xd4, 0x21, 0x7d,
	0x22, 0x7a, 0xd4, 0xd7, 0x35, 0x2b, 0x8f, 0x35, 0x6e, 0x5f, 0xdb, 0xa6, 0x41, 0x71, 0x8e, 0x92,
	0x33, 0x41, 0xf1, 0x29, 0xfc, 0x10, 0xd6, 0xc8, 0x59, 0x44, 0x39, 0x99, 0x44, 0xa5, 0x54, 0x54,
	0x51, 0x5b, 0xe3, 0xb0, 0x2d, 0xc8, 0xf6, 0xdd, 0xb3, 0x8e, 0xdb, 0x25, 0xa6, 0x4b, 0x7a, 0xf5,
	0xe5, 0x8c, 0x33, 0x7d, 0xf7, 0xac, 0xda, 0x25, 0xe8, 0x1e, 0x6c, 0xe8, 0xf1, 0x3d, 0x46, 0x7c,
	0xd9, 0xc4, 0xb9, 0x21, 0x2f, 0x65, 0x14, 0xba, 0x7c, 0x01, 0x5d, 0xa3, 0x34, 0xfc, 0xb9, 0x94,
	0x0c, 0x5e, 0x57, 0xa0, 0xed, 0x29, 0xc6, 0x7e, 0x66, 0xc1, 0xc6, 0x85, 0x36, 0x13, 0xfd, 0x0c,
	0x52, 0x7d, 0xea, 0x6b, 0xf9, 0xac, 0x2d, 0xea, 0xac, 0x2e, 0xc0, 0x9d, 0xf6, 0x5e, 0x6b, 0x9f,
	0xfa, 0x04, 0x2b, 0x12, 0xf4, 0x2e, 0x14, 0x38, 0xf1, 0x18, 0x11, 0x1d, 0xd5, 0xbf, 0xe8, 0x2d,
	0x02, 0x6d, 0x7a, 0xe0, 0xf6, 0x89, 0x5d, 0x81, 0xac, 0x41, 0xa0, 0x55, 0xc8, 0xed, 0xec, 0xb6,
	0xaa, 0xb5, 0xbd, 0xfa, 0xce, 0xfa, 0x0a, 0x02, 0xc8, 0xb4, 0x76, 0xf7, 0x9b, 0x7b, 0xf5, 0x75,
	0x4b, 0x3e, 0xef, 0x3f, 0x6c, 0x3f, 0xac, 0xee, 0xad, 0x27, 0xec, 0xff, 0x58, 0xb0, 0x36, 0xdf,
	0xcd, 0xa2, 0x1d, 0x48, 0x3e, 0x3e, 0x8d, 0xab, 0xdd, 0x8d, 0xcb, 0x34, 0xc2, 0xce, 0xfd, 0x47,
	0xed, 0xc6, 0x0a, 0x96, 0xf0, 0xf2, 0x6f, 0x2d, 0x48, 0xde, 0x7f, 0xd4, 0x46, 0x36, 0x64, 0x02,
	0xce, 0x87, 0x93, 0xfe, 0x66, 0xb6, 0x9b, 0x32, 0x1e, 0xad, 0x3b, 0x3f, 0x20, 0x03, 0x8f, 0xc4,
	0x1a, 0x99, 0x1a, 0xd0, 0x77, 0x20, 0xf7, 0xf8, 0xf4, 0x84, 0x77, 0xa4, 0x58, 0xe3, 0xaa, 0x9f,
	0x95, 0x96, 0x87, 0x2c, 0x40, 0x57, 0x20, 0x25, 0x1f, 0xd5, 0xdd, 0x2d, 0x1d, 0xea, 0xad, 0x96,
	0x81, 0xd4, 0x09, 0x19, 0xf3, 0x5a, 0x16, 0xd2, 0x52, 0xbf, 0x03, 0xfb, 0xff, 0x09, 0x28, 0xce,
	0xf5, 0xd7, 0xe8, 0x10, 0x72, 0xe4, 0x4c, 0x10, 0x36, 0x70, 0x43, 0xb3, 0xd4, 0x9f, 0x5e, 0xa2,
	0x3d, 0x77, 0xea, 0x06, 0x2b, 0xad, 0x4f, 0x6a, 0xae, 0x77, 0x42, 0x06, 0xbe, 0x6c, 0x09, 0x62,
	0x4e, 0xf4, 0x00, 0xd2, 0x21, 0xf5, 0xdc, 0x70, 0xb9, 0x12, 0x3f, 0x4f, 0xbe, 0x27, 0x81, 0x8a,
	0x59, 0x5e, 0x70, 0x8a, 0xa6, 0xfc, 0x6b, 0xb8, 0xf2, 0xb2, 0x31, 0x5f, 0x72, 0x8a, 0x6f, 0xc1,
	0xdb, 0xc1, 0xc0, 0x0b, 0x87, 0x3e, 0xe9, 0x98, 0x2b, 0xa7, 0x33, 0xdb, 0x33, 0xe4, 0xf1, 0xb7,
	0x8c, 0x1b, 0x6b, 0xaf, 0x39, 0x3c, 0xe5, 0x26, 0xc0, 0x74, 0x60, 0x54, 0x8b, 0x1b, 0x6e, 0x7d,
	0x7d, 0x2c, 0xf8, 0x20, 0x9a, 0x02, 0x67, 0xda, 0xee, 0x38, 0xfd, 0x4f, 0xec, 0xbf, 0x27, 0x60,
	0x6d, 0x3e, 0x64, 0x61, 0x0f, 0xfe, 0x63, 0x48, 0x1d, 0x33, 0xda, 0x37, 0x57, 0xcd, 0x82, 0x8a,
	0xd9, 0x1a, 0x1e, 0x3d, 0x26, 0x9e, 0xc0, 0x0a, 0x82, 0xee, 0x43, 0x42, 0x50, 0xf3, 0xa1, 0x70,
	0xe7, 0x32, 0xf3, 0x56, 0xed, 0xd2, 0xe4, 0xa2, 0xc2, 0x09, 0x41, 0xcb, 0xbf, 0xb7, 0xa0, 0x38,
	0x67, 0x45, 0x36, 0xa4, 0xe5, 0x47, 0x80, 0x49, 0x66, 0x6d, 0xf5, 0x45, 0x2d, 0xff, 0xd4, 0xca,
	0xd8, 0x7a, 0xee, 0xda, 0x85, 0x30, 0x64, 0xe3, 0x92, 0xa7, 0xaa, 0x59, 0xed, 0xf6, 0x8b, 0xda,
	0x27, 0x4f, 0xad, 0x2d, 0xfb, 0x06, 0x73, 0x70, 0xf2, 0x5e, 0xbd, 0x8d, 0x53, 0x8d, 0x7a, 0x75,
	0x07, 0xa7, 0x9a, 0x07, 0xad, 0x36, 0x4e, 0x36, 0x1f, 0xb6, 0x71, 0xba, 0x59, 0x6d, 0x6f, 0x37,
	0x70, 0x66, 0xa7, 0xbe, 0x57, 0x6f, 0xd7, 0x71, 0xf6, 0xa0, 0xd9, 0xde, 0x3d, 0x78, 0xd0, 0xc2,
	0x31, 0x91, 0xfd, 0x65, 0x02, 0xb2, 0x66, 0x9d, 0xf2, 0xcb, 0x77, 0x7a, 0x44, 0x2b, 0x4b, 0xe5,
	0x46, 0x9e, 0xcd, 0xed, 0xd0, 0x0d, 0xfa, 0x5c, 0x9f, 0xcf, 0x7f, 0x59, 0x90, 0x9f, 0x98, 0xa4,
	0x8a, 0x02, 0xce, 0x63, 0x15, 0x05, 0x5c, 0x59, 0xf8, 0xf0, 0xc8, 0x94, 0x18, 0xf9, 0x88, 0x0e,
	0x21, 0x4d, 0x45, 0x8f, 0xb0, 0xe5, 0x32, 0x7b, 0x61, 0x58, 0xe7, 0x40, 0x82, 0xd5, 0xbd, 0xac,
	0x92, 0xf6, 0xa7, 0x69, 0xd2, 0x14, 0x6d, 0xf9, 0x36, 0xc0, 0x34, 0xe4, 0x32, 0x57, 0x77, 0xed,
	0x93, 0x7f, 0x3e, 0xdf, 0xb4, 0xfe, 0xfd, 0x7c, 0xd3, 0xfa, 0xea, 0xf9, 0xa6, 0xf5, 0x8b, 0xef,
	0xce, 0xfc, 0xe0, 0x32, 0x99, 0xa2, 0xfa, 0x7d, 0x67, 0xfe, 0xe7, 0xa2, 0xa3, 0x8c, 0x2a, 0xeb,
	0x3f, 0xf8, 0x3a, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x99, 0xc8, 0xa4, 0x47, 0x12, 0x00, 0x00,
}

func (m *IngressGateway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGateway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressGateway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Http) > 0 {
		for iNdEx := len(m.Http) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Http[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.WorkloadSelector != nil {
		{
			size, err := m.WorkloadSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Routing != nil {
		{
			size, err := m.Routing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Authorization != nil {
		{
			size, err := m.Authorization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Tls != nil {
		{
			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpRouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StickySession != nil {
		{
			size, err := m.StickySession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpRouting_HTTPCookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRouting_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpRouting_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ttl != nil {
		{
			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpRouting_StickySession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRouting_StickySession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpRouting_StickySession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HashKey != nil {
		{
			size := m.HashKey.Size()
			i -= size
			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpRouting_StickySession_Header) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRouting_StickySession_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Header)
	copy(dAtA[i:], m.Header)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Header)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HttpRouting_StickySession_Cookie) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRouting_StickySession_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HttpRouting_StickySession_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRouting_StickySession_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UseSourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *HttpRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RouteOrRedirect != nil {
		{
			size := m.RouteOrRedirect.Size()
			i -= size
			if _, err := m.RouteOrRedirect.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Modify != nil {
		{
			size, err := m.Modify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpRule_Route) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRule_Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HttpRule_Redirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRule_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HttpMatchCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpMatchCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpMatchCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintIngressGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIngressGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Uri != nil {
		{
			size, err := m.Uri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchType != nil {
		{
			size := m.MatchType.Size()
			i -= size
			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Headers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Headers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Headers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Headers_HeaderOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Headers_HeaderOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Headers_HeaderOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Remove) > 0 {
		for iNdEx := len(m.Remove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Remove[iNdEx])
			copy(dAtA[i:], m.Remove[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Remove[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Add) > 0 {
		for k := range m.Add {
			v := m.Add[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIngressGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Set) > 0 {
		for k := range m.Set {
			v := m.Set[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIngressGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpModifyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpModifyAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpModifyAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Headers != nil {
		{
			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Rewrite != nil {
		{
			size, err := m.Rewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintIngressGateway(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Redirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowCredentials != nil {
		{
			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MaxAge != nil {
		{
			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExposeHeaders) > 0 {
		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExposeHeaders[iNdEx])
			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AllowHeaders) > 0 {
		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowHeaders[iNdEx])
			copy(dAtA[i:], m.AllowHeaders[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AllowMethods) > 0 {
		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowMethods[iNdEx])
			copy(dAtA[i:], m.AllowMethods[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowOrigin) > 0 {
		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOrigin[iNdEx])
			copy(dAtA[i:], m.AllowOrigin[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServerTLSSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerTLSSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SecretName) > 0 {
		i -= len(m.SecretName)
		copy(dAtA[i:], m.SecretName)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.SecretName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mode != 0 {
		i = encodeVarintIngressGateway(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Authentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Authn != nil {
		{
			size := m.Authn.Size()
			i -= size
			if _, err := m.Authn.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Authentication_Jwt) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authentication_Jwt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jwt != nil {
		{
			size, err := m.Jwt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Authentication_JWT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authentication_JWT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authentication_JWT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keys != nil {
		{
			size := m.Keys.Size()
			i -= size
			if _, err := m.Keys.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Audiences) > 0 {
		for iNdEx := len(m.Audiences) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Audiences[iNdEx])
			copy(dAtA[i:], m.Audiences[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Audiences[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Authentication_JWT_JwksUri) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authentication_JWT_JwksUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.JwksUri)
	copy(dAtA[i:], m.JwksUri)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.JwksUri)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Authentication_JWT_Jwks) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authentication_JWT_Jwks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jwks)
	copy(dAtA[i:], m.Jwks)
	i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Jwks)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *Authorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Authz != nil {
		{
			size := m.Authz.Size()
			i -= size
			if _, err := m.Authz.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Authorization_External) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authorization_External) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.External != nil {
		{
			size, err := m.External.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Authorization_Local) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authorization_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Authorization_ExternalAuthzBackend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization_ExternalAuthzBackend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authorization_ExternalAuthzBackend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IncludeRequestHeaders) > 0 {
		for iNdEx := len(m.IncludeRequestHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IncludeRequestHeaders[iNdEx])
			copy(dAtA[i:], m.IncludeRequestHeaders[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.IncludeRequestHeaders[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Authorization_LocalAuthz) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization_LocalAuthz) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authorization_LocalAuthz) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalAuthzRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalAuthzRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalAuthzRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.To) > 0 {
		for iNdEx := len(m.To) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.To[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.From) > 0 {
		for iNdEx := len(m.From) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.From[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngressGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalAuthzRule_HttpOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalAuthzRule_HttpOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalAuthzRule_HttpOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Methods[iNdEx])
			copy(dAtA[i:], m.Methods[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Methods[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Jwt != nil {
		{
			size, err := m.Jwt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIngressGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subject_JWTClaims) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject_JWTClaims) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_JWTClaims) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Other) > 0 {
		for k := range m.Other {
			v := m.Other[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIngressGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIngressGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sub) > 0 {
		i -= len(m.Sub)
		copy(dAtA[i:], m.Sub)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Sub)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iss) > 0 {
		i -= len(m.Iss)
		copy(dAtA[i:], m.Iss)
		i = encodeVarintIngressGateway(dAtA, i, uint64(len(m.Iss)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIngressGateway(dAtA []byte, offset int, v uint64) int {
	offset -= sovIngressGateway(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IngressGateway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadSelector != nil {
		l = m.WorkloadSelector.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.Http) > 0 {
		for _, e := range m.Http {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Authorization != nil {
		l = m.Authorization.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StickySession != nil {
		l = m.StickySession.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRouting_HTTPCookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Ttl != nil {
		l = m.Ttl.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRouting_StickySession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashKey != nil {
		n += m.HashKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRouting_StickySession_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *HttpRouting_StickySession_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *HttpRouting_StickySession_UseSourceIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HttpRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.Modify != nil {
		l = m.Modify.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.RouteOrRedirect != nil {
		n += m.RouteOrRedirect.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRule_Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *HttpRule_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *HttpMatchCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uri != nil {
		l = m.Uri.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovIngressGateway(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovIngressGateway(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovIngressGateway(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchType != nil {
		n += m.MatchType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *StringMatch_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *StringMatch_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *HTTPRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Headers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Headers_HeaderOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for k, v := range m.Set {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIngressGateway(uint64(len(k))) + 1 + len(v) + sovIngressGateway(uint64(len(v)))
			n += mapEntrySize + 1 + sovIngressGateway(uint64(mapEntrySize))
		}
	}
	if len(m.Add) > 0 {
		for k, v := range m.Add {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIngressGateway(uint64(len(k))) + 1 + len(v) + sovIngressGateway(uint64(len(v)))
			n += mapEntrySize + 1 + sovIngressGateway(uint64(mapEntrySize))
		}
	}
	if len(m.Remove) > 0 {
		for _, s := range m.Remove {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpModifyAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rewrite != nil {
		l = m.Rewrite.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovIngressGateway(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if len(m.AllowMethods) > 0 {
		for _, s := range m.AllowMethods {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if len(m.AllowHeaders) > 0 {
		for _, s := range m.AllowHeaders {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if len(m.ExposeHeaders) > 0 {
		for _, s := range m.ExposeHeaders {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.MaxAge != nil {
		l = m.MaxAge.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.AllowCredentials != nil {
		l = m.AllowCredentials.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerTLSSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovIngressGateway(uint64(m.Mode))
	}
	l = len(m.SecretName)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authn != nil {
		n += m.Authn.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Authentication_Jwt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jwt != nil {
		l = m.Jwt.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *Authentication_JWT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.Audiences) > 0 {
		for _, s := range m.Audiences {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.Keys != nil {
		n += m.Keys.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Authentication_JWT_JwksUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JwksUri)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *Authentication_JWT_Jwks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jwks)
	n += 1 + l + sovIngressGateway(uint64(l))
	return n
}
func (m *Authorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authz != nil {
		n += m.Authz.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Authorization_External) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.External != nil {
		l = m.External.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *Authorization_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	return n
}
func (m *Authorization_ExternalAuthzBackend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.IncludeRequestHeaders) > 0 {
		for _, s := range m.IncludeRequestHeaders {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Authorization_LocalAuthz) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalAuthzRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if len(m.To) > 0 {
		for _, e := range m.To {
			l = e.Size()
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalAuthzRule_HttpOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if len(m.Methods) > 0 {
		for _, s := range m.Methods {
			l = len(s)
			n += 1 + l + sovIngressGateway(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jwt != nil {
		l = m.Jwt.Size()
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject_JWTClaims) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iss)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	l = len(m.Sub)
	if l > 0 {
		n += 1 + l + sovIngressGateway(uint64(l))
	}
	if len(m.Other) > 0 {
		for k, v := range m.Other {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIngressGateway(uint64(len(k))) + 1 + len(v) + sovIngressGateway(uint64(len(v)))
			n += mapEntrySize + 1 + sovIngressGateway(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIngressGateway(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIngressGateway(x uint64) (n int) {
	return sovIngressGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IngressGateway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGateway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGateway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSelector == nil {
				m.WorkloadSelector = &v1.WorkloadSelector{}
			}
			if err := m.WorkloadSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Http = append(m.Http, &HttpServer{})
			if err := m.Http[len(m.Http)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tls == nil {
				m.Tls = &ServerTLSSettings{}
			}
			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authentication == nil {
				m.Authentication = &Authentication{}
			}
			if err := m.Authentication.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authorization == nil {
				m.Authorization = &Authorization{}
			}
			if err := m.Authorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &HttpRouting{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpRouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpRouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickySession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickySession == nil {
				m.StickySession = &HttpRouting_StickySession{}
			}
			if err := m.StickySession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &HttpRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRouting_HTTPCookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = &types.Duration{}
			}
			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRouting_StickySession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickySession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickySession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashKey = &HttpRouting_StickySession_Header{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpRouting_HTTPCookie{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HashKey = &HttpRouting_StickySession_Cookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HashKey = &HttpRouting_StickySession_UseSourceIp{b}
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &HttpMatchCondition{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modify == nil {
				m.Modify = &HttpModifyAction{}
			}
			if err := m.Modify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Route{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteOrRedirect = &HttpRule_Route{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Redirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteOrRedirect = &HttpRule_Redirect{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpMatchCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpMatchCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpMatchCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = &StringMatch{}
			}
			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*StringMatch)
			}
			var mapkey string
			var mapvalue *StringMatch
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIngressGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringMatch{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIngressGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Headers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &Headers_HeaderOperations{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Headers_HeaderOperations{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIngressGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIngressGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Set[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Add == nil {
				m.Add = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIngressGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIngressGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Add[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpModifyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpModifyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpModifyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewrite == nil {
				m.Rewrite = &HTTPRewrite{}
			}
			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &Headers{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Redirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Redirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Redirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxAge == nil {
				m.MaxAge = &types.Duration{}
			}
			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowCredentials == nil {
				m.AllowCredentials = &types.BoolValue{}
			}
			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerTLSSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerTLSSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerTLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ServerTLSSettings_TLSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Authentication_JWT{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authn = &Authentication_Jwt{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authentication_JWT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JWT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JWT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audiences", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audiences = append(m.Audiences, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwksUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = &Authentication_JWT_JwksUri{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = &Authentication_JWT_Jwks{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Authorization_ExternalAuthzBackend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authz = &Authorization_External{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Authorization_LocalAuthz{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Authz = &Authorization_Local{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization_ExternalAuthzBackend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalAuthzBackend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalAuthzBackend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRequestHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeRequestHeaders = append(m.IncludeRequestHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization_LocalAuthz) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalAuthz: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalAuthz: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &LocalAuthzRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalAuthzRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalAuthzRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalAuthzRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &Subject{})
			if err := m.From[len(m.From)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To, &LocalAuthzRule_HttpOperation{})
			if err := m.To[len(m.To)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalAuthzRule_HttpOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jwt == nil {
				m.Jwt = &Subject_JWTClaims{}
			}
			if err := m.Jwt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject_JWTClaims) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JWTClaims: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JWTClaims: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngressGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Other == nil {
				m.Other = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIngressGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIngressGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIngressGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIngressGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Other[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngressGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIngressGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIngressGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIngressGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIngressGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIngressGateway
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIngressGateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIngressGateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIngressGateway(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIngressGateway
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIngressGateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIngressGateway   = fmt.Errorf("proto: integer overflow")
)
