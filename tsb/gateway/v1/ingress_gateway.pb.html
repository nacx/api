---
title: Ingress Gateway
description: Configurations to build an ingress gateway.
location: https://tetrate.io/docs/reference/config/gateway/v1/ingress-gateway.html
layout: protoc-gen-docs
generator: protoc-gen-docs
number_of_entries: 26
---
<p><code>IngressGateway</code> configures a workload to act as a gateway for
traffic entering the mesh. The ingress gateway also provides basic
API gateway functionalities such as JWT token validation, rate
limiting, and request authorization. Gateways in privileged
workspaces can route to services outside the workspace while those
in unprivileged workspaces can only route to services inside the
workspace.</p>

<p>The following example declares an ingress gateway running on pods
with <code>app: gateway</code> labels in the <code>ns1</code> namespace. The gateway
exposes a host <code>bookinfo.com</code> on https port 8443. TLS is terminated
using the certificates in the Kubernetes secret
<code>bookinfo-certs</code>. Clients are authenticated using JWT tokens, whose
keys are obtained from the OIDC provider <code>www.googleapis.com</code>. The
request is then authorized by an the user&rsquo;s authorization engine
hosted at <code>https://internal.example.com</code> before being forwarded to
the <code>productpage</code> service in the backend.</p>

<pre><code class="language-yaml">apiVersion: gateway.tsb.tetrate.io/v1
kind: IngressGateway
metadata:
  name: ingress-bookinfo
  group: g1
  workspace: w1
  tenant: mycompany
spec:
  workloadSelector:
    namespace: ns1
    labels:
      app: gateway
  http:
  - hostname: bookinfo.com
    tls:
      mode: SIMPLE
      secretName: bookinfo-certs
    authentication:
      jwt:
        issuer: https://www.googleapis.com/oauth2/v1/certs
        audience: bookinfo
    authorization:
      external:
        uri: https://company.com/authz
        includeRequestHeaders:
        - Authorization # forwards the header to the authorization service.
    routing:
      rules:
      - route:
          host: ns1/productpage.ns1.svc.cluster.local
</code></pre>

<p>If the <code>productpage.ns1</code> service on Kubernetes has a <code>ServiceRoute</code>
with multiple subsets and weights, the traffic will be split across
the subsets accordingly.</p>

<p>TODO(rshriram): Add lot more examples in the gateway section.</p>

<h2 id="IngressGateway">IngressGateway</h2>
<section>
<p><code>IngressGateway</code> configures a workload to act as an ingress gateway into the mesh.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="IngressGateway-workload_selector">
<td><code>workloadSelector</code></td>
<td><code><a href="https://tetrate.io/docs/reference/config/types/v1/types.html#WorkloadSelector">WorkloadSelector</a></code></td>
<td>
<p>Specify the gateway workloads (pod labels and Kubernetes
namespace) under the gateway group that should be configured with
this ingress gateway. There can be only one ingress gateway for a
given workload selector.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="IngressGateway-http">
<td><code>http</code></td>
<td><code><a href="#HttpServer">HttpServer[]</a></code></td>
<td>
<p>One or more HTTP or HTTPS servers exposed by the gateway. The
server exposes configuration for TLS termination, request
authentication/authorization, HTTP routing, etc.</p>

</td>
<td>
Yes
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpServer">HttpServer</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpServer-hostname">
<td><code>hostname</code></td>
<td><code>string</code></td>
<td>
<p>Hostname with which the service can be expected to be accessed by clients.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="HttpServer-tls">
<td><code>tls</code></td>
<td><code><a href="#ServerTLSSettings">ServerTLSSettings</a></code></td>
<td>
<p>TLS certificate info. If omitted, the gateway will expose the host on port 80.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpServer-authentication">
<td><code>authentication</code></td>
<td><code><a href="#Authentication">Authentication</a></code></td>
<td>
<p>Configuration to authenticate clients.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpServer-authorization">
<td><code>authorization</code></td>
<td><code><a href="#Authorization">Authorization</a></code></td>
<td>
<p>Configuration to authorize a request.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpServer-routing">
<td><code>routing</code></td>
<td><code><a href="#HttpRouting">HttpRouting</a></code></td>
<td>
<p>Routing rules associated with HTTP traffic to this service.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpRouting">HttpRouting</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpRouting-sticky_session">
<td><code>stickySession</code></td>
<td><code><a href="#HttpRouting-StickySession">StickySession</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="HttpRouting-cors_policy">
<td><code>corsPolicy</code></td>
<td><code><a href="#CorsPolicy">CorsPolicy</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="HttpRouting-rules">
<td><code>rules</code></td>
<td><code><a href="#HttpRule">HttpRule[]</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpRule">HttpRule</h2>
<section>
<p>A single HTTP rule.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpRule-match">
<td><code>match</code></td>
<td><code><a href="#HttpMatchCondition">HttpMatchCondition[]</a></code></td>
<td>
<p>One or more match conditions (OR-ed).</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpRule-modify">
<td><code>modify</code></td>
<td><code><a href="#HttpModifyAction">HttpModifyAction</a></code></td>
<td>
<p>One or more mutations to be performed before forwarding. Includes typical modifications to be
done on a single request like URL rewrite, host rewrite, headers to add/remove/append.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpRule-route" class="oneof oneof-start">
<td><code>route</code></td>
<td><code><a href="#Route">Route (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="HttpRule-redirect" class="oneof">
<td><code>redirect</code></td>
<td><code><a href="#Redirect">Redirect (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpMatchCondition">HttpMatchCondition</h2>
<section>
<p>A single match clause to match all aspects of a request.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpMatchCondition-uri">
<td><code>uri</code></td>
<td><code><a href="#StringMatch">StringMatch</a></code></td>
<td>
<p>URI to match.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpMatchCondition-headers">
<td><code>headers</code></td>
<td><code>map&lt;string,&nbsp;<a href="#StringMatch">StringMatch</a>&gt;</code></td>
<td>
<p>The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="StringMatch">StringMatch</h2>
<section>
<p>Describes how to match a given string in HTTP headers. Match is case-sensitive.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="StringMatch-exact" class="oneof oneof-start">
<td><code>exact</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>Exact string match.</p>

</td>
<td>
No
</td>
</tr>
<tr id="StringMatch-prefix" class="oneof">
<td><code>prefix</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>Prefix-based match.</p>

</td>
<td>
No
</td>
</tr>
<tr id="StringMatch-regex" class="oneof">
<td><code>regex</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>ECMAscript style regex-based match.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HTTPRewrite">HTTPRewrite</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HTTPRewrite-uri">
<td><code>uri</code></td>
<td><code>string</code></td>
<td>
<p>Rewrite the path (or the prefix) portion of the URI with this value. If the original URI was
matched based on prefix, the value provided in this field will replace the corresponding
matched prefix.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HTTPRewrite-authority">
<td><code>authority</code></td>
<td><code>string</code></td>
<td>
<p>Rewrite the Authority/Host header with this value.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Headers">Headers</h2>
<section>
<p>Header manipulation rules.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Headers-request">
<td><code>request</code></td>
<td><code><a href="#Headers-HeaderOperations">HeaderOperations</a></code></td>
<td>
<p>Header manipulation rules to apply before forwarding a request to the destination service.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Headers-response">
<td><code>response</code></td>
<td><code><a href="#Headers-HeaderOperations">HeaderOperations</a></code></td>
<td>
<p>Header manipulation rules to apply before returning a response to the caller.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpModifyAction">HttpModifyAction</h2>
<section>
<p>HTTP path/url/header modification.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpModifyAction-rewrite">
<td><code>rewrite</code></td>
<td><code><a href="#HTTPRewrite">HTTPRewrite</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="HttpModifyAction-headers">
<td><code>headers</code></td>
<td><code><a href="#Headers">Headers</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Route">Route</h2>
<section>
<p>One or more destinations in a local cluster for the given request.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Route-host">
<td><code>host</code></td>
<td><code>string</code></td>
<td>
<p>The destination service in <code>&lt;namespace&gt;/&lt;fqdn&gt;</code> format.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="Route-port">
<td><code>port</code></td>
<td><code>uint32</code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Redirect">Redirect</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Redirect-uri">
<td><code>uri</code></td>
<td><code>string</code></td>
<td>
<p>On a redirect, overwrite the Path portion of the URL with this value.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Redirect-authority">
<td><code>authority</code></td>
<td><code>string</code></td>
<td>
<p>On a redirect, overwrite the Authority/Host portion of the URL with this value.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="CorsPolicy">CorsPolicy</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="CorsPolicy-allow_origin">
<td><code>allowOrigin</code></td>
<td><code>string[]</code></td>
<td>
<p>The list of origins that are allowed to perform CORS requests. The content will be serialized
into the Access-Control-Allow-Origin header. Wildcard * will allow all origins.</p>

</td>
<td>
No
</td>
</tr>
<tr id="CorsPolicy-allow_methods">
<td><code>allowMethods</code></td>
<td><code>string[]</code></td>
<td>
<p>List of HTTP methods allowed to access the resource. The content will be serialized into the
Access-Control-Allow-Methods header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="CorsPolicy-allow_headers">
<td><code>allowHeaders</code></td>
<td><code>string[]</code></td>
<td>
<p>List of HTTP headers that can be used when requesting the resource. Serialized to
Access-Control-Allow-Headers header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="CorsPolicy-expose_headers">
<td><code>exposeHeaders</code></td>
<td><code>string[]</code></td>
<td>
<p>A white list of HTTP headers that the browsers are allowed to access. Serialized into
Access-Control-Expose-Headers header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="CorsPolicy-max_age">
<td><code>maxAge</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Specifies how long the results of a preflight request can be cached. Translates to the
Access-Control-Max-Age header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="CorsPolicy-allow_credentials">
<td><code>allowCredentials</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#boolvalue">BoolValue</a></code></td>
<td>
<p>Indicates whether the caller is allowed to send the actual request (not the preflight) using
credentials. Translates to Access-Control-Allow-Credentials header.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ServerTLSSettings">ServerTLSSettings</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ServerTLSSettings-mode">
<td><code>mode</code></td>
<td><code><a href="#ServerTLSSettings-TLSMode">TLSMode</a></code></td>
<td>
<p>Set this to SIMPLE, or MUTUAL for one-way TLS, mutual TLS
respectively.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ServerTLSSettings-secret_name">
<td><code>secretName</code></td>
<td><code>string</code></td>
<td>
<p>The name of the secret in Kubernetes that holds the TLS certs
including the CA certificates. The secret (type generic) should
contain the following keys and values: key: <code>&lt;privateKey&gt;</code>, cert:
<code>&lt;serverCert&gt;</code>, cacert: <code>&lt;CACertificate&gt;</code>.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Authentication">Authentication</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Authentication-jwt" class="oneof oneof-start">
<td><code>jwt</code></td>
<td><code><a href="#Authentication-JWT">JWT (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Authorization">Authorization</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Authorization-external" class="oneof oneof-start">
<td><code>external</code></td>
<td><code><a href="#Authorization-ExternalAuthzBackend">ExternalAuthzBackend (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="Authorization-local" class="oneof">
<td><code>local</code></td>
<td><code><a href="#Authorization-LocalAuthz">LocalAuthz (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LocalAuthzRule">LocalAuthzRule</h2>
<section>
<p>LocalAuthzRule</p>

<p>Bindings define the subjects that can access the resource a policy is attached to,
and the conditions that need to be met for that access to be granted.
A policy can have multiple bindings to configure different access controls for specific
subjects.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LocalAuthzRule-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>A friendly name to identify the binding.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="LocalAuthzRule-from">
<td><code>from</code></td>
<td><code><a href="#Subject">Subject[]</a></code></td>
<td>
<p>Subjects configure the actors (end users, other services)  that are allowed to access the
target resource.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalAuthzRule-to">
<td><code>to</code></td>
<td><code><a href="#LocalAuthzRule-HttpOperation">HttpOperation[]</a></code></td>
<td>
<p>A set of HTTP rules that need to be satisfied by the HTTP requests to get access to the
target resource.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Subject">Subject</h2>
<section>
<p>Subject</p>

<p>A subject designates an actor (user, service, etc) that attempts to access a target resource.
Subjects can be modeled with JWT tokens, service accounts, and decorated with attributes such as
HTTP request headers, JWT token claims, etc.
The fields that define a subject will be matched to incoming requests, to fully qualify where the
request comes from, and to decide if the given request is allowed or not for the target resource.
All the fields in a subject are evaluated as AND expressions.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Subject-jwt">
<td><code>jwt</code></td>
<td><code><a href="#Subject-JWTClaims">JWTClaims</a></code></td>
<td>
<p>JWT configuration to identity the subject.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpRouting-HTTPCookie">HttpRouting.HTTPCookie</h2>
<section>
<p>Describes a HTTP cookie that will be used for sticky sessions. If the cookie is not present, it
will be generated.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpRouting-HTTPCookie-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>Name of the cookie.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="HttpRouting-HTTPCookie-path">
<td><code>path</code></td>
<td><code>string</code></td>
<td>
<p>Path to set for the cookie.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="HttpRouting-HTTPCookie-ttl">
<td><code>ttl</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Lifetime of the cookie.</p>

</td>
<td>
Yes
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="HttpRouting-StickySession">HttpRouting.StickySession</h2>
<section>
<p>If set, the load balancer will route all requests from a particular client to the same backend
of the service.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="HttpRouting-StickySession-header" class="oneof oneof-start">
<td><code>header</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>Hash based on a specific HTTP header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpRouting-StickySession-cookie" class="oneof">
<td><code>cookie</code></td>
<td><code><a href="#HttpRouting-HTTPCookie">HTTPCookie (oneof)</a></code></td>
<td>
<p>Hash based on HTTP cookie.</p>

</td>
<td>
No
</td>
</tr>
<tr id="HttpRouting-StickySession-use_source_ip" class="oneof">
<td><code>useSourceIp</code></td>
<td><code>bool (oneof)</code></td>
<td>
<p>Hash based on the source IP address.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Headers-HeaderOperations">Headers.HeaderOperations</h2>
<section>
<p>HeaderOperations Describes the header manipulations to apply.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Headers-HeaderOperations-set">
<td><code>set</code></td>
<td><code>map&lt;string,&nbsp;string&gt;</code></td>
<td>
<p>Overwrite the headers specified by key with the given values.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Headers-HeaderOperations-add">
<td><code>add</code></td>
<td><code>map&lt;string,&nbsp;string&gt;</code></td>
<td>
<p>Append the given values to the headers specified by keys (will create a comma-separated list
of values).</p>

</td>
<td>
No
</td>
</tr>
<tr id="Headers-HeaderOperations-remove">
<td><code>remove</code></td>
<td><code>string[]</code></td>
<td>
<p>Remove a the specified headers.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Authentication-JWT">Authentication.JWT</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Authentication-JWT-issuer">
<td><code>issuer</code></td>
<td><code>string</code></td>
<td>
<p>Identifies the issuer that issued the JWT. See
<a href="https://tools.ietf.org/html/rfc7519#section-4.1.1">issuer</a>
A JWT with different <code>iss</code> claim will be rejected.</p>

<p>Example: https://foobar.auth0.com
Example: 1234567-compute@developer.gserviceaccount.com</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="Authentication-JWT-audiences">
<td><code>audiences</code></td>
<td><code>string[]</code></td>
<td>
<p>The list of JWT
<a href="https://tools.ietf.org/html/rfc7519#section-4.1.3">audiences</a>.
that are allowed to access. A JWT containing any of these
audiences will be accepted.</p>

<p>The service name will be accepted if audiences is empty.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Authentication-JWT-jwks_uri" class="oneof oneof-start">
<td><code>jwksUri</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>URL of the provider&rsquo;s public key set to validate signature of
the JWT. See <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID
Discovery</a>.</p>

<p>Optional if the key set document can either (a) be retrieved
from <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID
Discovery</a>
of the issuer or (b) inferred from the email domain of the
issuer (e.g. a Google service account).</p>

<p>Example: <code>https://www.googleapis.com/oauth2/v1/certs</code></p>

<p>Note: Only one of jwks<em>uri and jwks should be used. jwks</em>uri
will be ignored if it does.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Authentication-JWT-jwks" class="oneof">
<td><code>jwks</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>JSON Web Key Set of public keys to validate signature of the JWT.
See https://auth0.com/docs/jwks.</p>

<p>Note: Only one of jwks<em>uri and jwks should be used. jwks</em>uri will be ignored if it does.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Authorization-ExternalAuthzBackend">Authorization.ExternalAuthzBackend</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Authorization-ExternalAuthzBackend-uri">
<td><code>uri</code></td>
<td><code>string</code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="Authorization-ExternalAuthzBackend-include_request_headers">
<td><code>includeRequestHeaders</code></td>
<td><code>string[]</code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Authorization-LocalAuthz">Authorization.LocalAuthz</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Authorization-LocalAuthz-rules">
<td><code>rules</code></td>
<td><code><a href="#LocalAuthzRule">LocalAuthzRule[]</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LocalAuthzRule-HttpOperation">LocalAuthzRule.HttpOperation</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LocalAuthzRule-HttpOperation-paths">
<td><code>paths</code></td>
<td><code>string[]</code></td>
<td>
<p>The request path where the request is made against. E.g. [&ldquo;/accounts&rdquo;].</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalAuthzRule-HttpOperation-methods">
<td><code>methods</code></td>
<td><code>string[]</code></td>
<td>
<p>The HTTP methods that are allowed by this rule. E.g. [&ldquo;GET&rdquo;, &ldquo;HEAD&rdquo;].</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Subject-JWTClaims">Subject.JWTClaims</h2>
<section>
<p>JWT based subject</p>

<p>JWT based subjects qualify a subject by matching against a JWT token present in the request.
By default the token is expected to be present in the &lsquo;Authorization&rsquo; HTTP header, with the
&lsquo;Bearer&rdquo; prefix.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Subject-JWTClaims-iss">
<td><code>iss</code></td>
<td><code>string</code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="Subject-JWTClaims-sub">
<td><code>sub</code></td>
<td><code>string</code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="Subject-JWTClaims-other">
<td><code>other</code></td>
<td><code>map&lt;string,&nbsp;string&gt;</code></td>
<td>
<p>A set of arbitrary claims that are required to qualify the subject.
E.g. &ldquo;iss&rdquo;: &ldquo;*@foo.com&rdquo;.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ServerTLSSettings-TLSMode">ServerTLSSettings.TLSMode</h2>
<section>
<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="ServerTLSSettings-TLSMode-DISABLED">
<td><code>DISABLED</code></td>
<td>
</td>
</tr>
<tr id="ServerTLSSettings-TLSMode-SIMPLE">
<td><code>SIMPLE</code></td>
<td>
</td>
</tr>
<tr id="ServerTLSSettings-TLSMode-MUTUAL">
<td><code>MUTUAL</code></td>
<td>
</td>
</tr>
</tbody>
</table>
</section>
