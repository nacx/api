// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package invv1 // import "github.com/tetrateio/tetrate/api/inventory/v1"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ServiceKind represents a service's type; whether it's a one-shot job,
// a traditional service, stateful set, etc.
type Service_Kind int32

const (
	// A Service, a long running job that answers many requests
	Service_SERVICE        Service_Kind = 0
	Service_JOB            Service_Kind = 1
	Service_VIRTUALSERVICE Service_Kind = 2
)

var Service_Kind_name = map[int32]string{
	0: "SERVICE",
	1: "JOB",
	2: "VIRTUALSERVICE",
}
var Service_Kind_value = map[string]int32{
	"SERVICE":        0,
	"JOB":            1,
	"VIRTUALSERVICE": 2,
}

func (x Service_Kind) String() string {
	return proto.EnumName(Service_Kind_name, int32(x))
}
func (Service_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{0, 0}
}

// ServiceStatus represents the health status of this service
type Service_Status int32

const (
	Service_UNHEALTHY Service_Status = 0
	Service_HEALTHY   Service_Status = 1
)

var Service_Status_name = map[int32]string{
	0: "UNHEALTHY",
	1: "HEALTHY",
}
var Service_Status_value = map[string]int32{
	"UNHEALTHY": 0,
	"HEALTHY":   1,
}

func (x Service_Status) String() string {
	return proto.EnumName(Service_Status_name, int32(x))
}
func (Service_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{0, 1}
}

// Transport protocols that are currently supported
type PortSpec_Protocol int32

const (
	PortSpec_TCP   PortSpec_Protocol = 0
	PortSpec_HTTP  PortSpec_Protocol = 1
	PortSpec_GRPC  PortSpec_Protocol = 2
	PortSpec_REDIS PortSpec_Protocol = 3
)

var PortSpec_Protocol_name = map[int32]string{
	0: "TCP",
	1: "HTTP",
	2: "GRPC",
	3: "REDIS",
}
var PortSpec_Protocol_value = map[string]int32{
	"TCP":   0,
	"HTTP":  1,
	"GRPC":  2,
	"REDIS": 3,
}

func (x PortSpec_Protocol) String() string {
	return proto.EnumName(PortSpec_Protocol_name, int32(x))
}
func (PortSpec_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{7, 0}
}

// Tetrate service definition that uniquely identifies services
type Service struct {
	// Unique name of this service to identify it. This name must be a
	// fully qualified one, e.g. `foo.bar.com`, and should be a valid DNS (RFC 1035) name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This Service's kind
	Kind Service_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=tetrate.api.inventory.v1.Service_Kind" json:"kind,omitempty"`
	// This Service's health status
	Status Service_Status `protobuf:"varint,3,opt,name=status,proto3,enum=tetrate.api.inventory.v1.Service_Status" json:"status,omitempty"`
	// Transport port spec
	Ports []*PortSpec `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// Service's metadata attributes
	Metadata *Metadata `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Service's cluster participation
	Cluster []*Cluster `protobuf:"bytes,6,rep,name=cluster,proto3" json:"cluster,omitempty"`
	// Service's workload presence
	Workload             *Workload            `protobuf:"bytes,7,opt,name=workload,proto3" json:"workload,omitempty"`
	LastModified         *timestamp.Timestamp `protobuf:"bytes,8,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{0}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Service.Unmarshal(m, b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Service.Marshal(b, m, deterministic)
}
func (dst *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(dst, src)
}
func (m *Service) XXX_Size() int {
	return xxx_messageInfo_Service.Size(m)
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetKind() Service_Kind {
	if m != nil {
		return m.Kind
	}
	return Service_SERVICE
}

func (m *Service) GetStatus() Service_Status {
	if m != nil {
		return m.Status
	}
	return Service_UNHEALTHY
}

func (m *Service) GetPorts() []*PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Service) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Service) GetCluster() []*Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *Service) GetWorkload() *Workload {
	if m != nil {
		return m.Workload
	}
	return nil
}

func (m *Service) GetLastModified() *timestamp.Timestamp {
	if m != nil {
		return m.LastModified
	}
	return nil
}

// ListServicesRequest
type ListServicesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListServicesRequest) Reset()         { *m = ListServicesRequest{} }
func (m *ListServicesRequest) String() string { return proto.CompactTextString(m) }
func (*ListServicesRequest) ProtoMessage()    {}
func (*ListServicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{1}
}
func (m *ListServicesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListServicesRequest.Unmarshal(m, b)
}
func (m *ListServicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListServicesRequest.Marshal(b, m, deterministic)
}
func (dst *ListServicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServicesRequest.Merge(dst, src)
}
func (m *ListServicesRequest) XXX_Size() int {
	return xxx_messageInfo_ListServicesRequest.Size(m)
}
func (m *ListServicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListServicesRequest proto.InternalMessageInfo

// ListServicesResponse is a collection of Tetrate-discovered services
type ListServicesResponse struct {
	Services             []*Service `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListServicesResponse) Reset()         { *m = ListServicesResponse{} }
func (m *ListServicesResponse) String() string { return proto.CompactTextString(m) }
func (*ListServicesResponse) ProtoMessage()    {}
func (*ListServicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{2}
}
func (m *ListServicesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListServicesResponse.Unmarshal(m, b)
}
func (m *ListServicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListServicesResponse.Marshal(b, m, deterministic)
}
func (dst *ListServicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServicesResponse.Merge(dst, src)
}
func (m *ListServicesResponse) XXX_Size() int {
	return xxx_messageInfo_ListServicesResponse.Size(m)
}
func (m *ListServicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListServicesResponse proto.InternalMessageInfo

func (m *ListServicesResponse) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

// Metadata extends object definitions by substaintiating them with
// additional attributes
type Metadata struct {
	// Generic metadata name
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Specific domain associated with this entity e.g. "svc.cluster.local"
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// Entities can be versioned e.g. "v1alpha1"
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Labels represent any "key" ==> "value" attached to entities.
	// These identify and query meaningful attributes of entities
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Annotations represent "key" ==> "value" attached to entities.
	// These are non-identifying information of entities
	Annotation map[string]string `protobuf:"bytes,5,rep,name=annotation,proto3" json:"annotation,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Organizational Unit associated with service e.g. "OU=ApplicationServers"
	Ou                   string   `protobuf:"bytes,6,opt,name=ou,proto3" json:"ou,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{3}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (dst *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(dst, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Metadata) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Metadata) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Metadata) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metadata) GetAnnotation() map[string]string {
	if m != nil {
		return m.Annotation
	}
	return nil
}

func (m *Metadata) GetOu() string {
	if m != nil {
		return m.Ou
	}
	return ""
}

// Cluster is a collection of distributed endpoints serving certain
// functionality, that is typically bounded by administrative domain
type Cluster struct {
	// Cluster name e.g. "clusterA.local"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// One of more endpoints serving as part of cluster
	Endpoints            []*Endpoint          `protobuf:"bytes,2,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	LastModified         *timestamp.Timestamp `protobuf:"bytes,3,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{4}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Cluster.Unmarshal(m, b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
}
func (dst *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(dst, src)
}
func (m *Cluster) XXX_Size() int {
	return xxx_messageInfo_Cluster.Size(m)
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *Cluster) GetLastModified() *timestamp.Timestamp {
	if m != nil {
		return m.LastModified
	}
	return nil
}

// Workload represents the location of a specific instance of a service,
// identified by its provider (a public cloud like GCP or AWS or a private cloud),
// location, and node.
type Workload struct {
	// Generic name representing cloud workload
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Workload provider info e.g. AWS, GCP, Azure
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// Cloud region this service resides e.g. "us-west-2"
	Region string `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	// Specific physical cloud node e.g. "gke-testing-default-pool-842099ce-7rdn"
	Node                 string   `protobuf:"bytes,4,opt,name=node,proto3" json:"node,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Workload) Reset()         { *m = Workload{} }
func (m *Workload) String() string { return proto.CompactTextString(m) }
func (*Workload) ProtoMessage()    {}
func (*Workload) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{5}
}
func (m *Workload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Workload.Unmarshal(m, b)
}
func (m *Workload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Workload.Marshal(b, m, deterministic)
}
func (dst *Workload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workload.Merge(dst, src)
}
func (m *Workload) XXX_Size() int {
	return xxx_messageInfo_Workload.Size(m)
}
func (m *Workload) XXX_DiscardUnknown() {
	xxx_messageInfo_Workload.DiscardUnknown(m)
}

var xxx_messageInfo_Workload proto.InternalMessageInfo

func (m *Workload) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Workload) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Workload) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Workload) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

// Endpoint represents
type Endpoint struct {
	// Endpoint represents one of IP or DNS name
	//
	// Types that are valid to be assigned to Address:
	//	*Endpoint_Ipv4
	//	*Endpoint_Ipv6
	//	*Endpoint_DnsName
	Address isEndpoint_Address `protobuf_oneof:"address"`
	// Endpoint port for this entity
	Port                 *PortSpec `protobuf:"bytes,4,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{6}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Endpoint.Unmarshal(m, b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
}
func (dst *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(dst, src)
}
func (m *Endpoint) XXX_Size() int {
	return xxx_messageInfo_Endpoint.Size(m)
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

type isEndpoint_Address interface {
	isEndpoint_Address()
}

type Endpoint_Ipv4 struct {
	Ipv4 []byte `protobuf:"bytes,1,opt,name=ipv4,proto3,oneof"`
}

type Endpoint_Ipv6 struct {
	Ipv6 []byte `protobuf:"bytes,2,opt,name=ipv6,proto3,oneof"`
}

type Endpoint_DnsName struct {
	DnsName string `protobuf:"bytes,3,opt,name=dns_name,json=dnsName,proto3,oneof"`
}

func (*Endpoint_Ipv4) isEndpoint_Address() {}

func (*Endpoint_Ipv6) isEndpoint_Address() {}

func (*Endpoint_DnsName) isEndpoint_Address() {}

func (m *Endpoint) GetAddress() isEndpoint_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Endpoint) GetIpv4() []byte {
	if x, ok := m.GetAddress().(*Endpoint_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *Endpoint) GetIpv6() []byte {
	if x, ok := m.GetAddress().(*Endpoint_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

func (m *Endpoint) GetDnsName() string {
	if x, ok := m.GetAddress().(*Endpoint_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *Endpoint) GetPort() *PortSpec {
	if m != nil {
		return m.Port
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Endpoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Endpoint_OneofMarshaler, _Endpoint_OneofUnmarshaler, _Endpoint_OneofSizer, []interface{}{
		(*Endpoint_Ipv4)(nil),
		(*Endpoint_Ipv6)(nil),
		(*Endpoint_DnsName)(nil),
	}
}

func _Endpoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Endpoint)
	// address
	switch x := m.Address.(type) {
	case *Endpoint_Ipv4:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ipv4)
	case *Endpoint_Ipv6:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ipv6)
	case *Endpoint_DnsName:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.DnsName)
	case nil:
	default:
		return fmt.Errorf("Endpoint.Address has unexpected type %T", x)
	}
	return nil
}

func _Endpoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Endpoint)
	switch tag {
	case 1: // address.ipv4
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Address = &Endpoint_Ipv4{x}
		return true, err
	case 2: // address.ipv6
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Address = &Endpoint_Ipv6{x}
		return true, err
	case 3: // address.dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Address = &Endpoint_DnsName{x}
		return true, err
	default:
		return false, nil
	}
}

func _Endpoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Endpoint)
	// address
	switch x := m.Address.(type) {
	case *Endpoint_Ipv4:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Ipv4)))
		n += len(x.Ipv4)
	case *Endpoint_Ipv6:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Ipv6)))
		n += len(x.Ipv6)
	case *Endpoint_DnsName:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.DnsName)))
		n += len(x.DnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PortSpec represents an endpoint's port details. A single endpoint can have
// one or more port specs.
type PortSpec struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This spec's protocol
	Protocol PortSpec_Protocol `protobuf:"varint,2,opt,name=protocol,proto3,enum=tetrate.api.inventory.v1.PortSpec_Protocol" json:"protocol,omitempty"`
	// Port facing external network
	ExternalPort int32 `protobuf:"varint,3,opt,name=external_port,json=externalPort,proto3" json:"external_port,omitempty"`
	// Container port that services this request
	ContainerPort        int32    `protobuf:"varint,5,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortSpec) Reset()         { *m = PortSpec{} }
func (m *PortSpec) String() string { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()    {}
func (*PortSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{7}
}
func (m *PortSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PortSpec.Unmarshal(m, b)
}
func (m *PortSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PortSpec.Marshal(b, m, deterministic)
}
func (dst *PortSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortSpec.Merge(dst, src)
}
func (m *PortSpec) XXX_Size() int {
	return xxx_messageInfo_PortSpec.Size(m)
}
func (m *PortSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PortSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PortSpec proto.InternalMessageInfo

func (m *PortSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortSpec) GetProtocol() PortSpec_Protocol {
	if m != nil {
		return m.Protocol
	}
	return PortSpec_TCP
}

func (m *PortSpec) GetExternalPort() int32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *PortSpec) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

// BindServicesRequest is a request to bind a service to a given policy
type BindServicesRequest struct {
	// The service to bind
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	// The name of the policy to bind the service to
	Binding              string   `protobuf:"bytes,2,opt,name=binding,proto3" json:"binding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BindServicesRequest) Reset()         { *m = BindServicesRequest{} }
func (m *BindServicesRequest) String() string { return proto.CompactTextString(m) }
func (*BindServicesRequest) ProtoMessage()    {}
func (*BindServicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{8}
}
func (m *BindServicesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindServicesRequest.Unmarshal(m, b)
}
func (m *BindServicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindServicesRequest.Marshal(b, m, deterministic)
}
func (dst *BindServicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindServicesRequest.Merge(dst, src)
}
func (m *BindServicesRequest) XXX_Size() int {
	return xxx_messageInfo_BindServicesRequest.Size(m)
}
func (m *BindServicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BindServicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BindServicesRequest proto.InternalMessageInfo

func (m *BindServicesRequest) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *BindServicesRequest) GetBinding() string {
	if m != nil {
		return m.Binding
	}
	return ""
}

// ListServicesResponse is a collection of Tetrate-discovered services
type BindServicesResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BindServicesResponse) Reset()         { *m = BindServicesResponse{} }
func (m *BindServicesResponse) String() string { return proto.CompactTextString(m) }
func (*BindServicesResponse) ProtoMessage()    {}
func (*BindServicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_service_13e67eaeaa84f357, []int{9}
}
func (m *BindServicesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindServicesResponse.Unmarshal(m, b)
}
func (m *BindServicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindServicesResponse.Marshal(b, m, deterministic)
}
func (dst *BindServicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindServicesResponse.Merge(dst, src)
}
func (m *BindServicesResponse) XXX_Size() int {
	return xxx_messageInfo_BindServicesResponse.Size(m)
}
func (m *BindServicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BindServicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BindServicesResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Service)(nil), "tetrate.api.inventory.v1.Service")
	proto.RegisterType((*ListServicesRequest)(nil), "tetrate.api.inventory.v1.ListServicesRequest")
	proto.RegisterType((*ListServicesResponse)(nil), "tetrate.api.inventory.v1.ListServicesResponse")
	proto.RegisterType((*Metadata)(nil), "tetrate.api.inventory.v1.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.inventory.v1.Metadata.AnnotationEntry")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.inventory.v1.Metadata.LabelsEntry")
	proto.RegisterType((*Cluster)(nil), "tetrate.api.inventory.v1.Cluster")
	proto.RegisterType((*Workload)(nil), "tetrate.api.inventory.v1.Workload")
	proto.RegisterType((*Endpoint)(nil), "tetrate.api.inventory.v1.Endpoint")
	proto.RegisterType((*PortSpec)(nil), "tetrate.api.inventory.v1.PortSpec")
	proto.RegisterType((*BindServicesRequest)(nil), "tetrate.api.inventory.v1.BindServicesRequest")
	proto.RegisterType((*BindServicesResponse)(nil), "tetrate.api.inventory.v1.BindServicesResponse")
	proto.RegisterEnum("tetrate.api.inventory.v1.Service_Kind", Service_Kind_name, Service_Kind_value)
	proto.RegisterEnum("tetrate.api.inventory.v1.Service_Status", Service_Status_name, Service_Status_value)
	proto.RegisterEnum("tetrate.api.inventory.v1.PortSpec_Protocol", PortSpec_Protocol_name, PortSpec_Protocol_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InventoryServiceClient is the client API for InventoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InventoryServiceClient interface {
	ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
	// ImpoBindServicertUsers binds a service to a given policy
	BindService(ctx context.Context, in *BindServicesRequest, opts ...grpc.CallOption) (*BindServicesResponse, error)
}

type inventoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewInventoryServiceClient(cc *grpc.ClientConn) InventoryServiceClient {
	return &inventoryServiceClient{cc}
}

func (c *inventoryServiceClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	out := new(ListServicesResponse)
	err := c.cc.Invoke(ctx, "/tetrate.api.inventory.v1.InventoryService/ListServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) BindService(ctx context.Context, in *BindServicesRequest, opts ...grpc.CallOption) (*BindServicesResponse, error) {
	out := new(BindServicesResponse)
	err := c.cc.Invoke(ctx, "/tetrate.api.inventory.v1.InventoryService/BindService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServiceServer is the server API for InventoryService service.
type InventoryServiceServer interface {
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
	// ImpoBindServicertUsers binds a service to a given policy
	BindService(context.Context, *BindServicesRequest) (*BindServicesResponse, error)
}

func RegisterInventoryServiceServer(s *grpc.Server, srv InventoryServiceServer) {
	s.RegisterService(&_InventoryService_serviceDesc, srv)
}

func _InventoryService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tetrate.api.inventory.v1.InventoryService/ListServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).ListServices(ctx, req.(*ListServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_BindService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).BindService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tetrate.api.inventory.v1.InventoryService/BindService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).BindService(ctx, req.(*BindServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InventoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tetrate.api.inventory.v1.InventoryService",
	HandlerType: (*InventoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListServices",
			Handler:    _InventoryService_ListServices_Handler,
		},
		{
			MethodName: "BindService",
			Handler:    _InventoryService_BindService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_service_13e67eaeaa84f357) }

var fileDescriptor_service_13e67eaeaa84f357 = []byte{
	// 960 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xcf, 0xf9, 0xef, 0x79, 0xf2, 0x07, 0x6b, 0x6b, 0xaa, 0x93, 0xa9, 0x84, 0x39, 0x28, 0x8a,
	0xa8, 0x38, 0x13, 0x17, 0xa2, 0x92, 0xaa, 0xd0, 0x24, 0x98, 0xda, 0x90, 0x16, 0x6b, 0xed, 0x14,
	0xc1, 0x4b, 0xb4, 0xf6, 0x6d, 0xcc, 0x2a, 0xf6, 0xee, 0x71, 0xbb, 0x3e, 0x88, 0xaa, 0x4a, 0x08,
	0x3e, 0x02, 0x12, 0x12, 0x6f, 0xbc, 0xf3, 0xca, 0x37, 0xe1, 0x2b, 0x20, 0xf1, 0x35, 0xd0, 0xed,
	0xed, 0x3a, 0x6e, 0x71, 0xe2, 0xf4, 0x6d, 0x67, 0x6e, 0x7e, 0xf3, 0x9b, 0x9d, 0xf9, 0xed, 0xd8,
	0xb0, 0x29, 0x69, 0x9c, 0xb0, 0x11, 0x0d, 0xa2, 0x58, 0x28, 0x81, 0x3c, 0x45, 0x55, 0x4c, 0x14,
	0x0d, 0x48, 0xc4, 0x02, 0xc6, 0x13, 0xca, 0x95, 0x88, 0xcf, 0x83, 0x64, 0xa7, 0x7e, 0x6b, 0x2c,
	0xc4, 0x78, 0x42, 0x9b, 0x24, 0x62, 0x4d, 0xc2, 0xb9, 0x50, 0x44, 0x31, 0xc1, 0x65, 0x86, 0xab,
	0xbf, 0x69, 0xbe, 0x6a, 0x6b, 0x38, 0x3b, 0x6d, 0x2a, 0x36, 0xa5, 0x52, 0x91, 0x69, 0x94, 0x05,
	0xf8, 0x7f, 0x16, 0xa0, 0xdc, 0xcf, 0xa8, 0x10, 0x82, 0x02, 0x27, 0x53, 0xea, 0x39, 0x0d, 0x67,
	0xbb, 0x82, 0xf5, 0x19, 0xed, 0x41, 0xe1, 0x8c, 0xf1, 0xd0, 0xcb, 0x35, 0x9c, 0xed, 0xad, 0xd6,
	0xbb, 0xc1, 0x65, 0x75, 0x04, 0x26, 0x49, 0xf0, 0x25, 0xe3, 0x21, 0xd6, 0x18, 0xf4, 0x10, 0x4a,
	0x52, 0x11, 0x35, 0x93, 0x5e, 0x5e, 0xa3, 0xb7, 0x57, 0xa3, 0xfb, 0x3a, 0x1e, 0x1b, 0x1c, 0xba,
	0x07, 0xc5, 0x48, 0xc4, 0x4a, 0x7a, 0x85, 0x46, 0x7e, 0x7b, 0xbd, 0xe5, 0x5f, 0x9e, 0xa0, 0x27,
	0x62, 0xd5, 0x8f, 0xe8, 0x08, 0x67, 0x00, 0xf4, 0x09, 0xb8, 0x53, 0xaa, 0x48, 0x48, 0x14, 0xf1,
	0x8a, 0x0d, 0xe7, 0x6a, 0xf0, 0x63, 0x13, 0x89, 0xe7, 0x18, 0x74, 0x1f, 0xca, 0xa3, 0xc9, 0x4c,
	0x2a, 0x1a, 0x7b, 0x25, 0xcd, 0xfd, 0xd6, 0xe5, 0xf0, 0xc3, 0x2c, 0x10, 0x5b, 0x44, 0x4a, 0xfe,
	0x83, 0x88, 0xcf, 0x26, 0x82, 0x84, 0x5e, 0x79, 0x15, 0xf9, 0xd7, 0x26, 0x12, 0xcf, 0x31, 0xe8,
	0x53, 0xd8, 0x9c, 0x10, 0xa9, 0x4e, 0xa6, 0x22, 0x64, 0xa7, 0x8c, 0x86, 0x9e, 0xab, 0x93, 0xd4,
	0x83, 0x6c, 0x9a, 0x81, 0x9d, 0x66, 0x30, 0xb0, 0xd3, 0xc4, 0x1b, 0x29, 0xe0, 0xb1, 0x89, 0xf7,
	0x3f, 0x80, 0x42, 0x3a, 0x07, 0xb4, 0x0e, 0xe5, 0x7e, 0x1b, 0x3f, 0xed, 0x1e, 0xb6, 0xab, 0x6b,
	0xa8, 0x0c, 0xf9, 0x2f, 0xbe, 0x3a, 0xa8, 0x3a, 0x08, 0xc1, 0xd6, 0xd3, 0x2e, 0x1e, 0x1c, 0xef,
	0x1f, 0xd9, 0x8f, 0x39, 0xff, 0x1d, 0x28, 0x65, 0xbd, 0x47, 0x9b, 0x50, 0x39, 0x7e, 0xd2, 0x69,
	0xef, 0x1f, 0x0d, 0x3a, 0xdf, 0x54, 0xd7, 0xd2, 0x14, 0xd6, 0x70, 0xfc, 0xd7, 0xe1, 0xc6, 0x11,
	0x93, 0xca, 0x4c, 0x4b, 0x62, 0xfa, 0xfd, 0x8c, 0x4a, 0xe5, 0x1f, 0x43, 0xed, 0x45, 0xb7, 0x8c,
	0x04, 0x97, 0x14, 0x3d, 0x00, 0xd7, 0xc8, 0x58, 0x7a, 0xce, 0xaa, 0x2e, 0x1a, 0x34, 0x9e, 0x43,
	0xfc, 0x9f, 0xf2, 0xe0, 0xda, 0xd1, 0xa0, 0x5b, 0x50, 0x49, 0x05, 0x29, 0x23, 0x32, 0xb2, 0x0a,
	0xbd, 0x70, 0xa0, 0x9b, 0x50, 0x0a, 0xc5, 0x94, 0x30, 0xae, 0x85, 0x5a, 0xc1, 0xc6, 0x42, 0x1e,
	0x94, 0x13, 0x1a, 0x4b, 0x26, 0xb8, 0xd6, 0x60, 0x05, 0x5b, 0x13, 0x7d, 0x0e, 0xa5, 0x09, 0x19,
	0xd2, 0x89, 0xd5, 0x56, 0xb0, 0x5a, 0x1e, 0xc1, 0x91, 0x06, 0xb4, 0xb9, 0x8a, 0xcf, 0xb1, 0x41,
	0x23, 0x0c, 0x70, 0xf1, 0xec, 0xbc, 0xa2, 0xce, 0xd5, 0xba, 0x46, 0xae, 0xfd, 0x39, 0x28, 0xcb,
	0xb7, 0x90, 0x05, 0x6d, 0x41, 0x4e, 0xcc, 0xbc, 0x92, 0x2e, 0x38, 0x27, 0x66, 0xf5, 0x8f, 0x61,
	0x7d, 0x81, 0x1a, 0x55, 0x21, 0x7f, 0x46, 0xcf, 0x4d, 0x13, 0xd2, 0x23, 0xaa, 0x41, 0x31, 0x21,
	0x93, 0x19, 0x35, 0xb7, 0xcf, 0x8c, 0xbd, 0xdc, 0x3d, 0xa7, 0xfe, 0x00, 0x5e, 0x7b, 0x89, 0xe9,
	0x55, 0xe0, 0xfe, 0x1f, 0x0e, 0x94, 0x8d, 0xbc, 0x97, 0xae, 0x87, 0x87, 0x50, 0xa1, 0x3c, 0x8c,
	0x04, 0xe3, 0x4a, 0x7a, 0xb9, 0x55, 0x8f, 0xb4, 0x6d, 0x42, 0xf1, 0x05, 0xe8, 0xff, 0x5a, 0xcf,
	0xbf, 0xa2, 0xd6, 0x4f, 0xc1, 0xb5, 0x4f, 0x68, 0x69, 0x89, 0x75, 0x70, 0xa3, 0x58, 0x24, 0x2c,
	0xa4, 0xb1, 0xb9, 0xdf, 0xdc, 0x4e, 0x65, 0x13, 0xd3, 0xf1, 0x85, 0x3a, 0x8c, 0xa5, 0xf3, 0x88,
	0x90, 0x7a, 0x05, 0x93, 0x47, 0x84, 0xd4, 0xff, 0xcd, 0x01, 0xd7, 0x5e, 0x00, 0xd5, 0xa0, 0xc0,
	0xa2, 0xe4, 0x43, 0x4d, 0xb4, 0xd1, 0x59, 0xc3, 0xda, 0x32, 0xde, 0x5d, 0x4d, 0x63, 0xbd, 0xbb,
	0xe8, 0x0d, 0x70, 0x43, 0x2e, 0x4f, 0x74, 0x61, 0x9a, 0xa6, 0xb3, 0x86, 0xcb, 0x21, 0x97, 0x4f,
	0xd2, 0xea, 0x76, 0xa1, 0x90, 0x2e, 0x2c, 0xcd, 0x74, 0xbd, 0x05, 0xa7, 0xe3, 0x0f, 0x2a, 0x50,
	0x26, 0x61, 0x18, 0x53, 0x29, 0xfd, 0x7f, 0x1d, 0x70, 0xed, 0xd7, 0xa5, 0x1d, 0x78, 0xa4, 0x3b,
	0xa0, 0xc4, 0x48, 0x4c, 0xcc, 0x1e, 0xbf, 0xb3, 0x9a, 0x27, 0xe8, 0x19, 0x08, 0x9e, 0x83, 0xd1,
	0xdb, 0xb0, 0x49, 0x7f, 0x54, 0x34, 0xe6, 0x64, 0x72, 0xa2, 0xab, 0x4e, 0xaf, 0x53, 0xc4, 0x1b,
	0xd6, 0x99, 0x62, 0xd1, 0x6d, 0xd8, 0x1a, 0x09, 0xae, 0x08, 0xe3, 0x34, 0xce, 0xa2, 0x8a, 0x3a,
	0x6a, 0x73, 0xee, 0x4d, 0xc3, 0xfc, 0x16, 0xb8, 0x96, 0x21, 0xdd, 0x4c, 0x83, 0xc3, 0x5e, 0x75,
	0x0d, 0xb9, 0x50, 0xe8, 0x0c, 0x06, 0xbd, 0xaa, 0x93, 0x9e, 0x1e, 0xe1, 0xde, 0x61, 0x35, 0x87,
	0x2a, 0x50, 0xc4, 0xed, 0xcf, 0xba, 0xfd, 0x6a, 0xde, 0xef, 0xc2, 0x8d, 0x03, 0xc6, 0xc3, 0x97,
	0xd6, 0x4f, 0xfa, 0xc8, 0xcd, 0xce, 0x30, 0xd7, 0xb6, 0x66, 0xfa, 0x65, 0xc8, 0x78, 0xc8, 0xf8,
	0xd8, 0x8c, 0xde, 0x9a, 0xfe, 0x4d, 0xa8, 0xbd, 0x98, 0x2a, 0x5b, 0x59, 0xad, 0xbf, 0x72, 0x50,
	0xed, 0xda, 0x7e, 0xd8, 0x1f, 0xc6, 0x5f, 0x1c, 0xd8, 0x58, 0x5c, 0x70, 0xe8, 0xfd, 0xcb, 0xfb,
	0xb7, 0x64, 0x3f, 0xd6, 0x83, 0xeb, 0x86, 0x67, 0x45, 0xf8, 0xb5, 0x9f, 0xff, 0xfe, 0xe7, 0xd7,
	0xdc, 0x16, 0xda, 0x68, 0x26, 0x3b, 0x4d, 0xbb, 0x0e, 0xd1, 0xef, 0x0e, 0xac, 0x2f, 0xd4, 0x7c,
	0x55, 0x11, 0x4b, 0xba, 0x74, 0x55, 0x11, 0xcb, 0x3a, 0xe1, 0xdf, 0xd1, 0x45, 0xdc, 0xf6, 0x1b,
	0x8b, 0x45, 0x34, 0x9f, 0x99, 0xd3, 0xf3, 0xe6, 0x33, 0xd3, 0xca, 0xe7, 0x7b, 0xce, 0x7b, 0x07,
	0x1f, 0x7d, 0x7b, 0x77, 0xcc, 0xd4, 0x77, 0xb3, 0x61, 0x30, 0x12, 0xd3, 0xa6, 0x21, 0x62, 0xc2,
	0x9e, 0xf4, 0xbf, 0x93, 0x39, 0x65, 0x33, 0xd9, 0xb9, 0xcf, 0x78, 0x92, 0xec, 0x0c, 0x4b, 0x5a,
	0x5a, 0x77, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x03, 0x9b, 0x57, 0xee, 0x08, 0x00, 0x00,
}
