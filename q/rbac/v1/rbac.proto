// Copyright (c) Tetrate, Inc 2019 All Rights Reserved.

syntax = "proto3";

package tetrate.api.q.rbac.v1;
option go_package = "github.com/tetrateio/tetrate/api/q/rbac/v1";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "validate/validate.proto";

// RBAC service
//
// The RBAC service provides a high level API to model Q RBAC policies.
//
// Policies in this API are resource centric; i.e. they are applied to a resource. All resources
// will have one and only one policy that describes how the resource can be accessed and under in
// which conditions.
service RBAC {
  // Creates a Role in the system.
  rpc CreateRole(CreateRoleRequest) returns (Role) {
    option (google.api.http) = {
      post: "/v1/roles"
      body: "*"
    };
  };

  // List all existing roles in the system.
  rpc ListRoles(ListRolesRequest) returns (ListRolesResponse) {
    option (google.api.http).get = "/v1/roles";
  };

  // Get the details of the role with the given name.
  rpc GetRole(GetRoleRequest) returns (Role) {
    option (google.api.http).get = "/v1/roles/{name}";
  };

  // Delete the role with the given name.
  //
  // Roles that are assigned to policies cannot be deleted. Policies need to be deleted first
  rpc DeleteRole(DeleteRoleRequest) returns (google.protobuf.Empty) {
    option (google.api.http).delete = "/v1/roles/{name}";
  };
}

// Permission
//
// A permission defines an action that can be performed on a resource. By default access to
// resources is denied unless an explicit permission grants access to perform an operation against
// it.
enum Permission {
  // Default value to designate no value was explicitly set for the permission.
  INVALID = 0;
  // The read permission grants read-only access to the resource.
  READ = 1;
  // The write permission allows the subject to modify an existing resource.
  WRITE = 2;
  // The create permission allows subjects to create child resources on the resource.
  CREATE = 3;
  // The delete permission grants permissions to delete the resource.
  DELETE = 4;
  // The set-policy permission allows subjects to manage the access policies for the resources.
  SET_POLICY = 5;
}

// Role
//
// A role configures a set of permissions and gives them a name. Permissions are grouped into roles
// and then can be bound to different resources to configure the access policies.
message Role {
  // A unique name for the role in the system.
  string name = 1 [(validate.rules).string.min_len = 1];

  // Details of what the role does and what the configured permissions allow.
  string description = 2;

  // The list of permissions that will be granted by this role on all resources that are bound to
  // it.
  repeated Permission permissions = 3 [(validate.rules).repeated = {
    min_items: 1,
    items: {enum: {defined_only: true}},
  }];

  // List of resource types where the role applies.
  // The permission system is hierarchical and allows permissions to be applied at the root elements
  // of the configuration hierarchy, so all child objects inherit them. This allows for easy and
  // flexible permission configuration. There are, however, many scenarios in which permissions only
  // make sense in certain types of resources instead of applying to the entire hierarchy. In those
  // cases, the resources field can be populated with the types of resources that are affected by
  // the role, and the permission set defined by the role will only apply to those resources. If
  // this field is omitted, the permissions apply to all resource types.
  repeated string resources = 4;
}

// Policy
//
// A policy defines the set of subjects that can access a resource and under which conditions that
// access is granted.
message Policy {
  // The list of bindings configures the different access profiles that are allowed on the resource
  // configured by the policy.
  repeated Binding bindings = 1 [(validate.rules).repeated = {min_items: 1}];
}

// Binding
//
// A binding associates a role with a set of subjects.
//
// Bindings are used to configure policies, where different roles can be assigned to different sets
// of subjects to configure a fine-grained access control to the resource protected by the policy.
message Binding {
  // The role that defines the permissions that will be granted to the target resource.
  string role = 1 [(validate.rules).string.min_len = 1];

  // The set of subjects that will be allowed to access the target resource with the permissions
  // defined by the role.
  repeated string subjects = 2 [(validate.rules).repeated = {
    min_items: 1,
    items: {string: {min_len: 1}},
  }];
}

// Request to create a role.
message CreateRoleRequest {
  string name = 1 [(validate.rules).string.pattern = "^[0-9A-Za-z]+$"];
  string description = 2;
  repeated Permission permissions = 3 [(validate.rules).repeated = {
    min_items: 1,
    items: {enum: {defined_only: true}},
    // TODO(nacx); Investigate why the following (to blacklist the INVALID value) does not work:
    //    items: { enum: { defined_only: true, not_in: [0] } }
    // The generated proto does not compile and presents this error:
    //    /rbac.pb.validate.go:336:15: undefined: _CreateRoleRequest_Permissions_NotInLookup
  }];
  repeated string resources = 4;
}

// Request to get the list of all existing roles.
message ListRolesRequest {
}

// Response to the list roles request with all existing roles.
message ListRolesResponse {
  repeated Role roles = 1;
}

// Request to get a role by name.
message GetRoleRequest {
  string name = 1 [(validate.rules).string.min_len = 1];
}

// Request to delete the role with the given name.
message DeleteRoleRequest {
  string name = 1 [(validate.rules).string.min_len = 1];
}
