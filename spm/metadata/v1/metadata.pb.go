// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: spm/metadata/v1/metadata.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EntityType int32

const (
	EntityType_SERVICE  EntityType = 0
	EntityType_INSTANCE EntityType = 1
	EntityType_ENDPOINT EntityType = 2
)

var EntityType_name = map[int32]string{
	0: "SERVICE",
	1: "INSTANCE",
	2: "ENDPOINT",
}

var EntityType_value = map[string]int32{
	"SERVICE":  0,
	"INSTANCE": 1,
	"ENDPOINT": 2,
}

func (x EntityType) String() string {
	return proto.EnumName(EntityType_name, int32(x))
}

func (EntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{0}
}

type Step int32

const (
	Step_MONTH  Step = 0
	Step_DAY    Step = 1
	Step_HOUR   Step = 2
	Step_MINUTE Step = 3
	Step_SECOND Step = 4
)

var Step_name = map[int32]string{
	0: "MONTH",
	1: "DAY",
	2: "HOUR",
	3: "MINUTE",
	4: "SECOND",
}

var Step_value = map[string]int32{
	"MONTH":  0,
	"DAY":    1,
	"HOUR":   2,
	"MINUTE": 3,
	"SECOND": 4,
}

func (x Step) String() string {
	return proto.EnumName(Step_name, int32(x))
}

func (Step) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{1}
}

// The entity requests the register.
type EntityRegisterMetadata struct {
	// This name follows SPM nouns doc, https://github.com/tetrateio/SPM/blob/spm2/doc/spm-nouns.md
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 EntityType `protobuf:"varint,2,opt,name=type,proto3,enum=EntityType" json:"type,omitempty"`
	OwnerService         int32      `protobuf:"varint,3,opt,name=ownerService,proto3" json:"ownerService,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EntityRegisterMetadata) Reset()         { *m = EntityRegisterMetadata{} }
func (m *EntityRegisterMetadata) String() string { return proto.CompactTextString(m) }
func (*EntityRegisterMetadata) ProtoMessage()    {}
func (*EntityRegisterMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{0}
}
func (m *EntityRegisterMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityRegisterMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityRegisterMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityRegisterMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityRegisterMetadata.Merge(m, src)
}
func (m *EntityRegisterMetadata) XXX_Size() int {
	return m.Size()
}
func (m *EntityRegisterMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityRegisterMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_EntityRegisterMetadata proto.InternalMessageInfo

func (m *EntityRegisterMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EntityRegisterMetadata) GetType() EntityType {
	if m != nil {
		return m.Type
	}
	return EntityType_SERVICE
}

func (m *EntityRegisterMetadata) GetOwnerService() int32 {
	if m != nil {
		return m.OwnerService
	}
	return 0
}

// Registered metadata. This ID should be unchanged and unique.
type EntityMetadata struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntityMetadata) Reset()         { *m = EntityMetadata{} }
func (m *EntityMetadata) String() string { return proto.CompactTextString(m) }
func (*EntityMetadata) ProtoMessage()    {}
func (*EntityMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{1}
}
func (m *EntityMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityMetadata.Merge(m, src)
}
func (m *EntityMetadata) XXX_Size() int {
	return m.Size()
}
func (m *EntityMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_EntityMetadata proto.InternalMessageInfo

func (m *EntityMetadata) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Request the TSB to update last heartbeat time to current based on TSB time.
type EntityPingPackage struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Only INSTANCE should be used for now.
	Type                 EntityType `protobuf:"varint,2,opt,name=type,proto3,enum=EntityType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EntityPingPackage) Reset()         { *m = EntityPingPackage{} }
func (m *EntityPingPackage) String() string { return proto.CompactTextString(m) }
func (*EntityPingPackage) ProtoMessage()    {}
func (*EntityPingPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{2}
}
func (m *EntityPingPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityPingPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityPingPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityPingPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityPingPackage.Merge(m, src)
}
func (m *EntityPingPackage) XXX_Size() int {
	return m.Size()
}
func (m *EntityPingPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityPingPackage.DiscardUnknown(m)
}

var xxx_messageInfo_EntityPingPackage proto.InternalMessageInfo

func (m *EntityPingPackage) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EntityPingPackage) GetType() EntityType {
	if m != nil {
		return m.Type
	}
	return EntityType_SERVICE
}

// Empty response only.
type TSBDefaultResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TSBDefaultResp) Reset()         { *m = TSBDefaultResp{} }
func (m *TSBDefaultResp) String() string { return proto.CompactTextString(m) }
func (*TSBDefaultResp) ProtoMessage()    {}
func (*TSBDefaultResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{3}
}
func (m *TSBDefaultResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TSBDefaultResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TSBDefaultResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TSBDefaultResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TSBDefaultResp.Merge(m, src)
}
func (m *TSBDefaultResp) XXX_Size() int {
	return m.Size()
}
func (m *TSBDefaultResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TSBDefaultResp.DiscardUnknown(m)
}

var xxx_messageInfo_TSBDefaultResp proto.InternalMessageInfo

type InstanceListCondition struct {
	Duration             *Duration `protobuf:"bytes,1,opt,name=duration,proto3" json:"duration,omitempty"`
	ServiceId            int32     `protobuf:"varint,2,opt,name=serviceId,proto3" json:"serviceId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstanceListCondition) Reset()         { *m = InstanceListCondition{} }
func (m *InstanceListCondition) String() string { return proto.CompactTextString(m) }
func (*InstanceListCondition) ProtoMessage()    {}
func (*InstanceListCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{4}
}
func (m *InstanceListCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceListCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceListCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceListCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceListCondition.Merge(m, src)
}
func (m *InstanceListCondition) XXX_Size() int {
	return m.Size()
}
func (m *InstanceListCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceListCondition.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceListCondition proto.InternalMessageInfo

func (m *InstanceListCondition) GetDuration() *Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *InstanceListCondition) GetServiceId() int32 {
	if m != nil {
		return m.ServiceId
	}
	return 0
}

type EntityList struct {
	List                 []*Entity `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EntityList) Reset()         { *m = EntityList{} }
func (m *EntityList) String() string { return proto.CompactTextString(m) }
func (*EntityList) ProtoMessage()    {}
func (*EntityList) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{5}
}
func (m *EntityList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityList.Merge(m, src)
}
func (m *EntityList) XXX_Size() int {
	return m.Size()
}
func (m *EntityList) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityList.DiscardUnknown(m)
}

var xxx_messageInfo_EntityList proto.InternalMessageInfo

func (m *EntityList) GetList() []*Entity {
	if m != nil {
		return m.List
	}
	return nil
}

type Entity struct {
	Type                 EntityType `protobuf:"varint,1,opt,name=type,proto3,enum=EntityType" json:"type,omitempty"`
	Id                   int32      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Entity) Reset()         { *m = Entity{} }
func (m *Entity) String() string { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()    {}
func (*Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{6}
}
func (m *Entity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity.Merge(m, src)
}
func (m *Entity) XXX_Size() int {
	return m.Size()
}
func (m *Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Entity proto.InternalMessageInfo

func (m *Entity) GetType() EntityType {
	if m != nil {
		return m.Type
	}
	return EntityType_SERVICE
}

func (m *Entity) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Duration struct {
	Start                string   `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  string   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	Step                 Step     `protobuf:"varint,3,opt,name=step,proto3,enum=Step" json:"step,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Duration) Reset()         { *m = Duration{} }
func (m *Duration) String() string { return proto.CompactTextString(m) }
func (*Duration) ProtoMessage()    {}
func (*Duration) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa720133b69c0cb4, []int{7}
}
func (m *Duration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Duration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Duration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Duration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Duration.Merge(m, src)
}
func (m *Duration) XXX_Size() int {
	return m.Size()
}
func (m *Duration) XXX_DiscardUnknown() {
	xxx_messageInfo_Duration.DiscardUnknown(m)
}

var xxx_messageInfo_Duration proto.InternalMessageInfo

func (m *Duration) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *Duration) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

func (m *Duration) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_MONTH
}

func init() {
	proto.RegisterEnum("EntityType", EntityType_name, EntityType_value)
	proto.RegisterEnum("Step", Step_name, Step_value)
	proto.RegisterType((*EntityRegisterMetadata)(nil), "EntityRegisterMetadata")
	proto.RegisterType((*EntityMetadata)(nil), "EntityMetadata")
	proto.RegisterType((*EntityPingPackage)(nil), "EntityPingPackage")
	proto.RegisterType((*TSBDefaultResp)(nil), "TSBDefaultResp")
	proto.RegisterType((*InstanceListCondition)(nil), "InstanceListCondition")
	proto.RegisterType((*EntityList)(nil), "EntityList")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*Duration)(nil), "Duration")
}

func init() { proto.RegisterFile("spm/metadata/v1/metadata.proto", fileDescriptor_fa720133b69c0cb4) }

var fileDescriptor_fa720133b69c0cb4 = []byte{
	// 646 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xcd, 0x38, 0x49, 0x63, 0xdf, 0x54, 0xa9, 0xb9, 0x40, 0x1b, 0x82, 0x08, 0x91, 0x25, 0x24,
	0xb7, 0x48, 0xb6, 0x08, 0x8f, 0x55, 0x37, 0x71, 0x62, 0xa9, 0x91, 0x88, 0x13, 0xd9, 0x2e, 0x15,
	0xec, 0xdc, 0x78, 0x08, 0xa3, 0x26, 0xb6, 0x65, 0x4f, 0x83, 0xba, 0x65, 0xcf, 0x8f, 0xf0, 0x25,
	0x2c, 0xf9, 0x04, 0xd4, 0x35, 0x5f, 0xd0, 0x15, 0xf2, 0xab, 0xa1, 0x8f, 0x05, 0xbb, 0x3b, 0x77,
	0xce, 0x9c, 0x39, 0xd7, 0xe7, 0x78, 0xa0, 0x9b, 0x44, 0x2b, 0x7d, 0x45, 0xb9, 0xe7, 0x7b, 0xdc,
	0xd3, 0xd7, 0xaf, 0xae, 0x6b, 0x2d, 0x8a, 0x43, 0x1e, 0x76, 0xf6, 0xd6, 0xde, 0x92, 0xf9, 0x1e,
	0xa7, 0x7a, 0x59, 0xe4, 0x1b, 0xca, 0x77, 0x02, 0xbb, 0x66, 0xc0, 0x19, 0xbf, 0xb0, 0xe9, 0x82,
	0x25, 0x9c, 0xc6, 0x93, 0xe2, 0x24, 0x3e, 0x85, 0x5a, 0xe0, 0xad, 0x68, 0x9b, 0xf4, 0x88, 0x2a,
	0x19, 0x8d, 0x2b, 0xa3, 0x16, 0x0b, 0x32, 0xb1, 0xb3, 0x26, 0xee, 0x43, 0x8d, 0x5f, 0x44, 0xb4,
	0x2d, 0xf4, 0x88, 0xda, 0xea, 0x37, 0xb5, 0x9c, 0xc3, 0xbd, 0x88, 0xa8, 0x21, 0x5e, 0x19, 0xf5,
	0x6f, 0x24, 0x83, 0xa6, 0x10, 0x7c, 0x09, 0xdb, 0xe1, 0xd7, 0x80, 0xc6, 0x0e, 0x8d, 0xd7, 0x6c,
	0x4e, 0xdb, 0xd5, 0x1e, 0x51, 0xeb, 0x19, 0x5f, 0x47, 0x50, 0x2b, 0xf6, 0x8d, 0x4d, 0xa5, 0x07,
	0xad, 0x9c, 0xea, 0x5a, 0x46, 0x0b, 0x04, 0xe6, 0x67, 0x22, 0xea, 0xb6, 0xc0, 0x7c, 0xe5, 0x04,
	0x1e, 0xe4, 0x88, 0x19, 0x0b, 0x16, 0x33, 0x6f, 0x7e, 0xe6, 0x2d, 0x28, 0xee, 0x6d, 0x40, 0x1b,
	0x66, 0x81, 0xf9, 0xff, 0xa1, 0x53, 0x2c, 0x74, 0x2a, 0x32, 0xb4, 0x5c, 0xc7, 0x18, 0xd1, 0xcf,
	0xde, 0xf9, 0x92, 0xdb, 0x34, 0x89, 0x94, 0x10, 0x1e, 0x8f, 0x83, 0x84, 0x7b, 0xc1, 0x9c, 0xbe,
	0x67, 0x09, 0x1f, 0x86, 0x81, 0xcf, 0x38, 0x0b, 0x03, 0xd4, 0x41, 0xf4, 0xcf, 0x63, 0x2f, 0xad,
	0xb3, 0x4b, 0x9b, 0x7d, 0x49, 0x1b, 0x15, 0x8d, 0x8c, 0xf7, 0x47, 0xc6, 0x7b, 0x0d, 0xc2, 0x17,
	0x20, 0x25, 0xf9, 0x84, 0x63, 0x3f, 0xd3, 0xf2, 0x8f, 0xcc, 0xcd, 0x8e, 0xb2, 0x0f, 0x90, 0x0b,
	0x4c, 0xaf, 0x4b, 0x0d, 0x58, 0xb2, 0x84, 0xb7, 0x49, 0xaf, 0xaa, 0x36, 0xfb, 0x8d, 0x42, 0xbb,
	0x9d, 0x35, 0x95, 0x09, 0x6c, 0xe5, 0x6b, 0x7c, 0x5e, 0x8c, 0x48, 0xee, 0x8c, 0x58, 0x18, 0x90,
	0x7f, 0x41, 0xa1, 0xfc, 0x82, 0x88, 0x85, 0xb1, 0xa9, 0x11, 0x52, 0xee, 0xa7, 0x32, 0x01, 0xb1,
	0x1c, 0x00, 0x1f, 0x41, 0x3d, 0xe1, 0x5e, 0xcc, 0x73, 0xe7, 0xed, 0x7c, 0x81, 0x32, 0x54, 0x69,
	0x90, 0xd3, 0x48, 0x76, 0x5a, 0xe2, 0x13, 0xa8, 0x25, 0x9c, 0x46, 0x19, 0x4f, 0xab, 0x5f, 0xd7,
	0x1c, 0x4e, 0x23, 0x3b, 0x6b, 0x1d, 0xbc, 0x2d, 0x07, 0x49, 0x65, 0x60, 0x13, 0x1a, 0x8e, 0x69,
	0x7f, 0x18, 0x0f, 0x4d, 0xb9, 0x82, 0xdb, 0x20, 0x8e, 0x2d, 0xc7, 0x1d, 0x58, 0x43, 0x53, 0x26,
	0xe9, 0xca, 0xb4, 0x46, 0xb3, 0xe9, 0xd8, 0x72, 0x65, 0xe1, 0xe0, 0x10, 0x6a, 0x29, 0x09, 0x4a,
	0x50, 0x9f, 0x4c, 0x2d, 0xf7, 0x48, 0xae, 0x60, 0x03, 0xaa, 0xa3, 0xc1, 0x47, 0x99, 0xa0, 0x08,
	0xb5, 0xa3, 0xe9, 0xb1, 0x2d, 0x0b, 0x08, 0xb0, 0x35, 0x19, 0x5b, 0xc7, 0xae, 0x29, 0x57, 0xd3,
	0xda, 0x31, 0x87, 0x53, 0x6b, 0x24, 0xd7, 0xfa, 0x7f, 0x08, 0xa0, 0xeb, 0x18, 0x65, 0x72, 0x8a,
	0x48, 0xe1, 0x3b, 0x10, 0xe3, 0x22, 0xdb, 0xb8, 0xa7, 0xdd, 0x1f, 0xf6, 0xce, 0x8e, 0x76, 0x33,
	0x76, 0x4a, 0x05, 0xdf, 0x80, 0x74, 0x46, 0x69, 0x34, 0x58, 0xb2, 0x35, 0x45, 0xd4, 0xee, 0x84,
	0xae, 0xb3, 0xa3, 0xdd, 0xca, 0x4b, 0x45, 0x25, 0x78, 0x00, 0xad, 0x05, 0xe5, 0x83, 0xe5, 0xb2,
	0xb8, 0x3e, 0xc1, 0x4d, 0x34, 0x3a, 0xa5, 0x39, 0xa9, 0xbd, 0x4a, 0x05, 0x0f, 0xe1, 0xe1, 0x82,
	0xf2, 0x02, 0x58, 0x26, 0x2d, 0xc1, 0x5d, 0xed, 0xde, 0xd4, 0xdd, 0x3a, 0x6d, 0x9c, 0xfc, 0xbc,
	0xec, 0x92, 0x5f, 0x97, 0x5d, 0xf2, 0xfb, 0xb2, 0x4b, 0xe0, 0x19, 0x0b, 0x35, 0x4e, 0x79, 0x9c,
	0xfe, 0xda, 0x49, 0xb4, 0xd2, 0x78, 0x72, 0xaa, 0xa5, 0x8f, 0x40, 0xfe, 0x9f, 0xcf, 0xc8, 0x27,
	0x75, 0xc1, 0xf8, 0x97, 0xf3, 0x53, 0x6d, 0x1e, 0xae, 0xf4, 0x02, 0xc8, 0x42, 0xdd, 0x8b, 0x98,
	0x7e, 0xeb, 0xed, 0x38, 0xdd, 0xca, 0x8e, 0xbc, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x65, 0x0c,
	0xcc, 0xaa, 0x55, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TSBMetadataServiceClient is the client API for TSBMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TSBMetadataServiceClient interface {
	// Register new service, instance and endpoint
	// when SPM can't find it from central ES storage.
	// This could be a concurrency OP, so implementation should use the lock to avoid duplicated IDs.
	Register(ctx context.Context, in *EntityRegisterMetadata, opts ...grpc.CallOption) (*EntityMetadata, error)
	// Keep the given instances online.
	KeepAlive(ctx context.Context, opts ...grpc.CallOption) (TSBMetadataService_KeepAliveClient, error)
	// Get all service based on TSB definition.
	GetAllServices(ctx context.Context, in *Duration, opts ...grpc.CallOption) (*EntityList, error)
	// Get all online instance list.
	GetServiceInstances(ctx context.Context, in *InstanceListCondition, opts ...grpc.CallOption) (*EntityList, error)
}

type tSBMetadataServiceClient struct {
	cc *grpc.ClientConn
}

func NewTSBMetadataServiceClient(cc *grpc.ClientConn) TSBMetadataServiceClient {
	return &tSBMetadataServiceClient{cc}
}

func (c *tSBMetadataServiceClient) Register(ctx context.Context, in *EntityRegisterMetadata, opts ...grpc.CallOption) (*EntityMetadata, error) {
	out := new(EntityMetadata)
	err := c.cc.Invoke(ctx, "/TSBMetadataService/register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tSBMetadataServiceClient) KeepAlive(ctx context.Context, opts ...grpc.CallOption) (TSBMetadataService_KeepAliveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TSBMetadataService_serviceDesc.Streams[0], "/TSBMetadataService/keepAlive", opts...)
	if err != nil {
		return nil, err
	}
	x := &tSBMetadataServiceKeepAliveClient{stream}
	return x, nil
}

type TSBMetadataService_KeepAliveClient interface {
	Send(*EntityPingPackage) error
	CloseAndRecv() (*TSBDefaultResp, error)
	grpc.ClientStream
}

type tSBMetadataServiceKeepAliveClient struct {
	grpc.ClientStream
}

func (x *tSBMetadataServiceKeepAliveClient) Send(m *EntityPingPackage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tSBMetadataServiceKeepAliveClient) CloseAndRecv() (*TSBDefaultResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TSBDefaultResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tSBMetadataServiceClient) GetAllServices(ctx context.Context, in *Duration, opts ...grpc.CallOption) (*EntityList, error) {
	out := new(EntityList)
	err := c.cc.Invoke(ctx, "/TSBMetadataService/getAllServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tSBMetadataServiceClient) GetServiceInstances(ctx context.Context, in *InstanceListCondition, opts ...grpc.CallOption) (*EntityList, error) {
	out := new(EntityList)
	err := c.cc.Invoke(ctx, "/TSBMetadataService/getServiceInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TSBMetadataServiceServer is the server API for TSBMetadataService service.
type TSBMetadataServiceServer interface {
	// Register new service, instance and endpoint
	// when SPM can't find it from central ES storage.
	// This could be a concurrency OP, so implementation should use the lock to avoid duplicated IDs.
	Register(context.Context, *EntityRegisterMetadata) (*EntityMetadata, error)
	// Keep the given instances online.
	KeepAlive(TSBMetadataService_KeepAliveServer) error
	// Get all service based on TSB definition.
	GetAllServices(context.Context, *Duration) (*EntityList, error)
	// Get all online instance list.
	GetServiceInstances(context.Context, *InstanceListCondition) (*EntityList, error)
}

// UnimplementedTSBMetadataServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTSBMetadataServiceServer struct {
}

func (*UnimplementedTSBMetadataServiceServer) Register(ctx context.Context, req *EntityRegisterMetadata) (*EntityMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedTSBMetadataServiceServer) KeepAlive(srv TSBMetadataService_KeepAliveServer) error {
	return status.Errorf(codes.Unimplemented, "method KeepAlive not implemented")
}
func (*UnimplementedTSBMetadataServiceServer) GetAllServices(ctx context.Context, req *Duration) (*EntityList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllServices not implemented")
}
func (*UnimplementedTSBMetadataServiceServer) GetServiceInstances(ctx context.Context, req *InstanceListCondition) (*EntityList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServiceInstances not implemented")
}

func RegisterTSBMetadataServiceServer(s *grpc.Server, srv TSBMetadataServiceServer) {
	s.RegisterService(&_TSBMetadataService_serviceDesc, srv)
}

func _TSBMetadataService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntityRegisterMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TSBMetadataServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TSBMetadataService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TSBMetadataServiceServer).Register(ctx, req.(*EntityRegisterMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _TSBMetadataService_KeepAlive_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TSBMetadataServiceServer).KeepAlive(&tSBMetadataServiceKeepAliveServer{stream})
}

type TSBMetadataService_KeepAliveServer interface {
	SendAndClose(*TSBDefaultResp) error
	Recv() (*EntityPingPackage, error)
	grpc.ServerStream
}

type tSBMetadataServiceKeepAliveServer struct {
	grpc.ServerStream
}

func (x *tSBMetadataServiceKeepAliveServer) SendAndClose(m *TSBDefaultResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tSBMetadataServiceKeepAliveServer) Recv() (*EntityPingPackage, error) {
	m := new(EntityPingPackage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TSBMetadataService_GetAllServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Duration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TSBMetadataServiceServer).GetAllServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TSBMetadataService/GetAllServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TSBMetadataServiceServer).GetAllServices(ctx, req.(*Duration))
	}
	return interceptor(ctx, in, info, handler)
}

func _TSBMetadataService_GetServiceInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceListCondition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TSBMetadataServiceServer).GetServiceInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TSBMetadataService/GetServiceInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TSBMetadataServiceServer).GetServiceInstances(ctx, req.(*InstanceListCondition))
	}
	return interceptor(ctx, in, info, handler)
}

var _TSBMetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "TSBMetadataService",
	HandlerType: (*TSBMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "register",
			Handler:    _TSBMetadataService_Register_Handler,
		},
		{
			MethodName: "getAllServices",
			Handler:    _TSBMetadataService_GetAllServices_Handler,
		},
		{
			MethodName: "getServiceInstances",
			Handler:    _TSBMetadataService_GetServiceInstances_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "keepAlive",
			Handler:       _TSBMetadataService_KeepAlive_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "spm/metadata/v1/metadata.proto",
}

func (m *EntityRegisterMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityRegisterMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityRegisterMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OwnerService != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.OwnerService))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntityMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EntityPingPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityPingPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityPingPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TSBDefaultResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TSBDefaultResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TSBDefaultResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InstanceListCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceListCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceListCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceId != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ServiceId))
		i--
		dAtA[i] = 0x10
	}
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntityList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Duration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Duration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Duration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Step != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x18
	}
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Start) > 0 {
		i -= len(m.Start)
		copy(dAtA[i:], m.Start)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Start)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EntityRegisterMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMetadata(uint64(m.Type))
	}
	if m.OwnerService != 0 {
		n += 1 + sovMetadata(uint64(m.OwnerService))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntityMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetadata(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntityPingPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetadata(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovMetadata(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TSBDefaultResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceListCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ServiceId != 0 {
		n += 1 + sovMetadata(uint64(m.ServiceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntityList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Entity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMetadata(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovMetadata(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Duration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Step != 0 {
		n += 1 + sovMetadata(uint64(m.Step))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EntityRegisterMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityRegisterMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityRegisterMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerService", wireType)
			}
			m.OwnerService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerService |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityPingPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityPingPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityPingPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TSBDefaultResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TSBDefaultResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TSBDefaultResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceListCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceListCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceListCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			m.ServiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Entity{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Duration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Duration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Duration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetadata(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMetadata
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetadata = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata   = fmt.Errorf("proto: integer overflow")
)
