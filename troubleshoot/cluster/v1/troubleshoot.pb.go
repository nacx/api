// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: troubleshoot.proto

package clustertroubleshootv1

import (
	context "context"
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ClusterTroubleshootRequest struct {
	// Must be unique for a given connection, used to map requests to responses.
	// Think TCP sequence number.
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The time after which the requester will assume the request is lost, used to avoid unecessary
	// computation.
	Timeout *types.Duration `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*ClusterTroubleshootRequest_GetResources
	Request              isClusterTroubleshootRequest_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ClusterTroubleshootRequest) Reset()         { *m = ClusterTroubleshootRequest{} }
func (m *ClusterTroubleshootRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterTroubleshootRequest) ProtoMessage()    {}
func (*ClusterTroubleshootRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{0}
}
func (m *ClusterTroubleshootRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterTroubleshootRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterTroubleshootRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterTroubleshootRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterTroubleshootRequest.Merge(m, src)
}
func (m *ClusterTroubleshootRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterTroubleshootRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterTroubleshootRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterTroubleshootRequest proto.InternalMessageInfo

type isClusterTroubleshootRequest_Request interface {
	isClusterTroubleshootRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClusterTroubleshootRequest_GetResources struct {
	GetResources *GetResourcesRequest `protobuf:"bytes,101,opt,name=get_resources,json=getResources,proto3,oneof"`
}

func (*ClusterTroubleshootRequest_GetResources) isClusterTroubleshootRequest_Request() {}

func (m *ClusterTroubleshootRequest) GetRequest() isClusterTroubleshootRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ClusterTroubleshootRequest) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *ClusterTroubleshootRequest) GetTimeout() *types.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *ClusterTroubleshootRequest) GetGetResources() *GetResourcesRequest {
	if x, ok := m.GetRequest().(*ClusterTroubleshootRequest_GetResources); ok {
		return x.GetResources
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClusterTroubleshootRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClusterTroubleshootRequest_OneofMarshaler, _ClusterTroubleshootRequest_OneofUnmarshaler, _ClusterTroubleshootRequest_OneofSizer, []interface{}{
		(*ClusterTroubleshootRequest_GetResources)(nil),
	}
}

func _ClusterTroubleshootRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClusterTroubleshootRequest)
	// request
	switch x := m.Request.(type) {
	case *ClusterTroubleshootRequest_GetResources:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetResources); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClusterTroubleshootRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _ClusterTroubleshootRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClusterTroubleshootRequest)
	switch tag {
	case 101: // request.get_resources
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetResourcesRequest)
		err := b.DecodeMessage(msg)
		m.Request = &ClusterTroubleshootRequest_GetResources{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClusterTroubleshootRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClusterTroubleshootRequest)
	// request
	switch x := m.Request.(type) {
	case *ClusterTroubleshootRequest_GetResources:
		s := proto.Size(x.GetResources)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ClusterTroubleshootResponse struct {
	// Matches the request ID that triggered this response.
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*ClusterTroubleshootResponse_ResourcesStatus
	Request              isClusterTroubleshootResponse_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ClusterTroubleshootResponse) Reset()         { *m = ClusterTroubleshootResponse{} }
func (m *ClusterTroubleshootResponse) String() string { return proto.CompactTextString(m) }
func (*ClusterTroubleshootResponse) ProtoMessage()    {}
func (*ClusterTroubleshootResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{1}
}
func (m *ClusterTroubleshootResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterTroubleshootResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterTroubleshootResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterTroubleshootResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterTroubleshootResponse.Merge(m, src)
}
func (m *ClusterTroubleshootResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClusterTroubleshootResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterTroubleshootResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterTroubleshootResponse proto.InternalMessageInfo

type isClusterTroubleshootResponse_Request interface {
	isClusterTroubleshootResponse_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClusterTroubleshootResponse_ResourcesStatus struct {
	ResourcesStatus *ResourcesStatusResponse `protobuf:"bytes,101,opt,name=resources_status,json=resourcesStatus,proto3,oneof"`
}

func (*ClusterTroubleshootResponse_ResourcesStatus) isClusterTroubleshootResponse_Request() {}

func (m *ClusterTroubleshootResponse) GetRequest() isClusterTroubleshootResponse_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ClusterTroubleshootResponse) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *ClusterTroubleshootResponse) GetResourcesStatus() *ResourcesStatusResponse {
	if x, ok := m.GetRequest().(*ClusterTroubleshootResponse_ResourcesStatus); ok {
		return x.ResourcesStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClusterTroubleshootResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClusterTroubleshootResponse_OneofMarshaler, _ClusterTroubleshootResponse_OneofUnmarshaler, _ClusterTroubleshootResponse_OneofSizer, []interface{}{
		(*ClusterTroubleshootResponse_ResourcesStatus)(nil),
	}
}

func _ClusterTroubleshootResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClusterTroubleshootResponse)
	// request
	switch x := m.Request.(type) {
	case *ClusterTroubleshootResponse_ResourcesStatus:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResourcesStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClusterTroubleshootResponse.Request has unexpected type %T", x)
	}
	return nil
}

func _ClusterTroubleshootResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClusterTroubleshootResponse)
	switch tag {
	case 101: // request.resources_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResourcesStatusResponse)
		err := b.DecodeMessage(msg)
		m.Request = &ClusterTroubleshootResponse_ResourcesStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClusterTroubleshootResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClusterTroubleshootResponse)
	// request
	switch x := m.Request.(type) {
	case *ClusterTroubleshootResponse_ResourcesStatus:
		s := proto.Size(x.ResourcesStatus)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetResourcesRequest struct {
	// An array of logical resources to retrieve the propagation status of
	Resources            []*ResourceRequest `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetResourcesRequest) Reset()         { *m = GetResourcesRequest{} }
func (m *GetResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*GetResourcesRequest) ProtoMessage()    {}
func (*GetResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{2}
}
func (m *GetResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResourcesRequest.Merge(m, src)
}
func (m *GetResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetResourcesRequest proto.InternalMessageInfo

func (m *GetResourcesRequest) GetResources() []*ResourceRequest {
	if m != nil {
		return m.Resources
	}
	return nil
}

type ResourceRequest struct {
	// The name of the logical resource. Needs to be fully qualified to determine resource type.
	// e.g. tenants/tetrate/environments/staging/applications/bookinfo/services/reviews
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Version of the logical resource to check propagation of. This will be resource type specific.
	// For environment, application and service it is Etag.
	// If no version is provided, the propagation status of all configuration in that domain at the
	// latest version received by tsbd is returned. For example, if the bookinfo application
	// is requested the response will include the application object as well as every service that
	// belongs to the bookinfo application.
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceRequest) Reset()         { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()    {}
func (*ResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{3}
}
func (m *ResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceRequest.Merge(m, src)
}
func (m *ResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceRequest proto.InternalMessageInfo

func (m *ResourceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ResourcesStatusResponse struct {
	// Map of resource name (fully qualified) to resource propagation status
	Resources            map[string]*ResourceStatus `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ResourcesStatusResponse) Reset()         { *m = ResourcesStatusResponse{} }
func (m *ResourcesStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ResourcesStatusResponse) ProtoMessage()    {}
func (*ResourcesStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{4}
}
func (m *ResourcesStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesStatusResponse.Merge(m, src)
}
func (m *ResourcesStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesStatusResponse proto.InternalMessageInfo

func (m *ResourcesStatusResponse) GetResources() map[string]*ResourceStatus {
	if m != nil {
		return m.Resources
	}
	return nil
}

type ResourceStatus struct {
	// The name of the logical resource. This will match the name in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Version of the logical resource. This will match the version in the request.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Number of endpoints with configuration that matches the logical name/version tuple provided.
	// Endpoints here is anything Pilot configures: Envoys or any other xDS clients
	// Note: this is across all endpoints, NOT just the number of endpoints the config is relevant to.
	ActiveEndpoints uint64 `protobuf:"varint,100,opt,name=active_endpoints,json=activeEndpoints,proto3" json:"active_endpoints,omitempty"`
	// Total number of endpoints in the system/cluster
	// Note: this is all endpoints, NOT the number of endpoints the config is relevant to.
	TotalEndpoints       uint64   `protobuf:"varint,101,opt,name=total_endpoints,json=totalEndpoints,proto3" json:"total_endpoints,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceStatus) Reset()         { *m = ResourceStatus{} }
func (m *ResourceStatus) String() string { return proto.CompactTextString(m) }
func (*ResourceStatus) ProtoMessage()    {}
func (*ResourceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed10eac57682819a, []int{5}
}
func (m *ResourceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceStatus.Merge(m, src)
}
func (m *ResourceStatus) XXX_Size() int {
	return m.Size()
}
func (m *ResourceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceStatus proto.InternalMessageInfo

func (m *ResourceStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResourceStatus) GetActiveEndpoints() uint64 {
	if m != nil {
		return m.ActiveEndpoints
	}
	return 0
}

func (m *ResourceStatus) GetTotalEndpoints() uint64 {
	if m != nil {
		return m.TotalEndpoints
	}
	return 0
}

func init() {
	proto.RegisterType((*ClusterTroubleshootRequest)(nil), "tetrate.api.troubleshoot.cluster.v1.ClusterTroubleshootRequest")
	proto.RegisterType((*ClusterTroubleshootResponse)(nil), "tetrate.api.troubleshoot.cluster.v1.ClusterTroubleshootResponse")
	proto.RegisterType((*GetResourcesRequest)(nil), "tetrate.api.troubleshoot.cluster.v1.GetResourcesRequest")
	proto.RegisterType((*ResourceRequest)(nil), "tetrate.api.troubleshoot.cluster.v1.ResourceRequest")
	proto.RegisterType((*ResourcesStatusResponse)(nil), "tetrate.api.troubleshoot.cluster.v1.ResourcesStatusResponse")
	proto.RegisterMapType((map[string]*ResourceStatus)(nil), "tetrate.api.troubleshoot.cluster.v1.ResourcesStatusResponse.ResourcesEntry")
	proto.RegisterType((*ResourceStatus)(nil), "tetrate.api.troubleshoot.cluster.v1.ResourceStatus")
}

func init() { proto.RegisterFile("troubleshoot.proto", fileDescriptor_ed10eac57682819a) }

var fileDescriptor_ed10eac57682819a = []byte{
	// 587 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x3f, 0x6f, 0xd3, 0x5e,
	0x14, 0xed, 0x6b, 0xf2, 0xfb, 0x45, 0xb9, 0x2d, 0x4d, 0xf4, 0x18, 0x1a, 0x8c, 0x12, 0x45, 0x2e,
	0x12, 0x61, 0xb1, 0x49, 0xc2, 0x50, 0x01, 0x12, 0x28, 0xb4, 0xa2, 0x15, 0x12, 0x83, 0x0b, 0x0b,
	0x42, 0x8a, 0x5e, 0xe2, 0x8b, 0xfb, 0x84, 0xe3, 0x97, 0x3e, 0x3f, 0x5b, 0xea, 0x27, 0x61, 0xe0,
	0x0b, 0x30, 0xb3, 0xc1, 0xc4, 0xc0, 0xc0, 0xc8, 0x07, 0x60, 0x40, 0xd9, 0xf8, 0x04, 0xac, 0xa8,
	0x7e, 0x76, 0xe2, 0x40, 0x0a, 0x29, 0x61, 0xbb, 0xba, 0xe7, 0xde, 0x73, 0xcf, 0x39, 0xfe, 0x03,
	0x54, 0x49, 0x11, 0x0d, 0x7c, 0x0c, 0x8f, 0x85, 0x50, 0xd6, 0x58, 0x0a, 0x25, 0xe8, 0x8e, 0x42,
	0x25, 0x99, 0x42, 0x8b, 0x8d, 0xb9, 0x35, 0x87, 0x0f, 0xfd, 0x28, 0x54, 0x28, 0xad, 0xb8, 0x6d,
	0x34, 0x3c, 0x21, 0x3c, 0x1f, 0xed, 0x64, 0x65, 0x10, 0xbd, 0xb0, 0xdd, 0x48, 0x32, 0xc5, 0x45,
	0xa0, 0x49, 0x8c, 0xed, 0x98, 0xf9, 0xdc, 0x65, 0x0a, 0xed, 0xac, 0xd0, 0x80, 0xf9, 0x85, 0x80,
	0xf1, 0x40, 0xf3, 0x3c, 0xc9, 0x71, 0x3b, 0x78, 0x12, 0x61, 0xa8, 0x68, 0x1d, 0x40, 0xea, 0xb2,
	0xcf, 0xdd, 0x1a, 0x69, 0x92, 0x56, 0xd1, 0x29, 0xa7, 0x9d, 0x43, 0x97, 0x76, 0xa1, 0xa4, 0xf8,
	0x08, 0x45, 0xa4, 0x6a, 0xeb, 0x4d, 0xd2, 0xda, 0xe8, 0x5c, 0xb1, 0xb4, 0x10, 0x2b, 0x13, 0x62,
	0xed, 0xa5, 0x42, 0x9c, 0x6c, 0x92, 0xf6, 0xe1, 0x92, 0x87, 0xaa, 0x2f, 0x31, 0x14, 0x91, 0x1c,
	0x62, 0x58, 0xc3, 0x64, 0x75, 0xd7, 0x5a, 0xc2, 0xa8, 0xf5, 0x10, 0x95, 0x93, 0x2d, 0xa6, 0x22,
	0x0f, 0xd6, 0x9c, 0x4d, 0x2f, 0xd7, 0xee, 0x95, 0xa1, 0x94, 0x4a, 0x34, 0xdf, 0x12, 0xb8, 0xba,
	0xd0, 0x5e, 0x38, 0x16, 0x41, 0x88, 0x7f, 0xf2, 0xc7, 0xa1, 0x3a, 0x95, 0xd9, 0x0f, 0x15, 0x53,
	0x51, 0xa6, 0xf6, 0xee, 0x52, 0x6a, 0xa7, 0x9a, 0x8e, 0x92, 0xdd, 0xec, 0xec, 0xc1, 0x9a, 0x53,
	0x91, 0xf3, 0x50, 0x5e, 0x34, 0x87, 0xcb, 0x0b, 0x6c, 0x52, 0x07, 0xca, 0xb3, 0xcc, 0x48, 0xb3,
	0xd0, 0xda, 0xe8, 0xdc, 0xba, 0x90, 0x8a, 0x94, 0xc8, 0x99, 0xd1, 0x98, 0x4f, 0xa1, 0xf2, 0x13,
	0x4a, 0xeb, 0x50, 0x0c, 0xd8, 0x08, 0x93, 0x30, 0xca, 0xbd, 0xf2, 0xfb, 0x6f, 0x1f, 0x0a, 0x45,
	0xb9, 0x5e, 0x25, 0x4e, 0xd2, 0xa6, 0x3b, 0x50, 0x8a, 0x51, 0x86, 0x5c, 0x04, 0xc9, 0x23, 0x9f,
	0x9b, 0xc8, 0x10, 0xf3, 0x3b, 0x81, 0xed, 0x73, 0xbc, 0x53, 0xfe, 0xab, 0x8d, 0x47, 0xab, 0x84,
	0x39, 0xeb, 0xef, 0x07, 0x4a, 0x9e, 0xe6, 0xdc, 0x19, 0x27, 0xb0, 0x35, 0x0f, 0xd2, 0x2a, 0x14,
	0x5e, 0xe2, 0xa9, 0xf6, 0xe6, 0x9c, 0x95, 0xf4, 0x10, 0xfe, 0x8b, 0x99, 0x1f, 0x61, 0xfa, 0x02,
	0x77, 0x2f, 0x24, 0x25, 0x55, 0xa2, 0x19, 0x6e, 0xaf, 0xef, 0x12, 0xf3, 0x0d, 0x99, 0xdd, 0xd4,
	0xe8, 0xbf, 0x08, 0x94, 0xde, 0x80, 0x2a, 0x1b, 0x2a, 0x1e, 0x63, 0x1f, 0x03, 0x77, 0x2c, 0x78,
	0xa0, 0xc2, 0x9a, 0x9b, 0xbc, 0xad, 0x15, 0xdd, 0xdf, 0xcf, 0xda, 0xf4, 0x3a, 0x54, 0x94, 0x50,
	0xcc, 0xcf, 0x4d, 0x62, 0x32, 0xb9, 0x95, 0xb4, 0xa7, 0x83, 0x9d, 0x77, 0x04, 0xea, 0x0b, 0xbe,
	0x0d, 0x1e, 0x78, 0x47, 0x28, 0x63, 0x3e, 0x44, 0xfa, 0x8a, 0xc0, 0x66, 0x1e, 0xa2, 0xf7, 0x96,
	0x4a, 0xe7, 0xfc, 0xff, 0x89, 0x71, 0xff, 0xef, 0x09, 0xf4, 0xd3, 0x36, 0xd7, 0x5a, 0xe4, 0x26,
	0xe9, 0x7c, 0x24, 0x70, 0xcd, 0xc1, 0xb3, 0x74, 0xf0, 0xf7, 0x16, 0x5e, 0x13, 0xa8, 0xe6, 0xa1,
	0x3d, 0xce, 0x7c, 0xba, 0xb2, 0x0a, 0x63, 0xd5, 0x20, 0xb4, 0x8d, 0xde, 0xf3, 0x4f, 0x93, 0x06,
	0xf9, 0x3c, 0x69, 0x90, 0xaf, 0x93, 0x06, 0x79, 0xf6, 0xd8, 0xe3, 0xea, 0x38, 0x1a, 0x58, 0x43,
	0x31, 0xb2, 0x53, 0x7a, 0x2e, 0xb2, 0xca, 0x66, 0x63, 0x6e, 0xe7, 0x0f, 0xd9, 0xe9, 0x21, 0x3b,
	0x6e, 0xdf, 0x49, 0xcb, 0x3c, 0x1c, 0xb7, 0x07, 0xff, 0x27, 0x3f, 0xe1, 0xee, 0x8f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x8f, 0xa4, 0x3d, 0xac, 0x56, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterTroubleshootingServiceClient is the client API for ClusterTroubleshootingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterTroubleshootingServiceClient interface {
	// TODO: Enforce authz with Q when feasible (i.e. has a cluster local enforcement point).
	Troubleshoot(ctx context.Context, opts ...grpc.CallOption) (ClusterTroubleshootingService_TroubleshootClient, error)
}

type clusterTroubleshootingServiceClient struct {
	cc *grpc.ClientConn
}

func NewClusterTroubleshootingServiceClient(cc *grpc.ClientConn) ClusterTroubleshootingServiceClient {
	return &clusterTroubleshootingServiceClient{cc}
}

func (c *clusterTroubleshootingServiceClient) Troubleshoot(ctx context.Context, opts ...grpc.CallOption) (ClusterTroubleshootingService_TroubleshootClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterTroubleshootingService_serviceDesc.Streams[0], "/tetrate.api.troubleshoot.cluster.v1.ClusterTroubleshootingService/Troubleshoot", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterTroubleshootingServiceTroubleshootClient{stream}
	return x, nil
}

type ClusterTroubleshootingService_TroubleshootClient interface {
	Send(*ClusterTroubleshootRequest) error
	Recv() (*ClusterTroubleshootResponse, error)
	grpc.ClientStream
}

type clusterTroubleshootingServiceTroubleshootClient struct {
	grpc.ClientStream
}

func (x *clusterTroubleshootingServiceTroubleshootClient) Send(m *ClusterTroubleshootRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *clusterTroubleshootingServiceTroubleshootClient) Recv() (*ClusterTroubleshootResponse, error) {
	m := new(ClusterTroubleshootResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClusterTroubleshootingServiceServer is the server API for ClusterTroubleshootingService service.
type ClusterTroubleshootingServiceServer interface {
	// TODO: Enforce authz with Q when feasible (i.e. has a cluster local enforcement point).
	Troubleshoot(ClusterTroubleshootingService_TroubleshootServer) error
}

// UnimplementedClusterTroubleshootingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedClusterTroubleshootingServiceServer struct {
}

func (*UnimplementedClusterTroubleshootingServiceServer) Troubleshoot(srv ClusterTroubleshootingService_TroubleshootServer) error {
	return status.Errorf(codes.Unimplemented, "method Troubleshoot not implemented")
}

func RegisterClusterTroubleshootingServiceServer(s *grpc.Server, srv ClusterTroubleshootingServiceServer) {
	s.RegisterService(&_ClusterTroubleshootingService_serviceDesc, srv)
}

func _ClusterTroubleshootingService_Troubleshoot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ClusterTroubleshootingServiceServer).Troubleshoot(&clusterTroubleshootingServiceTroubleshootServer{stream})
}

type ClusterTroubleshootingService_TroubleshootServer interface {
	Send(*ClusterTroubleshootResponse) error
	Recv() (*ClusterTroubleshootRequest, error)
	grpc.ServerStream
}

type clusterTroubleshootingServiceTroubleshootServer struct {
	grpc.ServerStream
}

func (x *clusterTroubleshootingServiceTroubleshootServer) Send(m *ClusterTroubleshootResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *clusterTroubleshootingServiceTroubleshootServer) Recv() (*ClusterTroubleshootRequest, error) {
	m := new(ClusterTroubleshootRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ClusterTroubleshootingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tetrate.api.troubleshoot.cluster.v1.ClusterTroubleshootingService",
	HandlerType: (*ClusterTroubleshootingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Troubleshoot",
			Handler:       _ClusterTroubleshootingService_Troubleshoot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "troubleshoot.proto",
}

// ReverseClusterTroubleshootingServiceClient is the client API for ReverseClusterTroubleshootingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReverseClusterTroubleshootingServiceClient interface {
	TroubleshootDial(ctx context.Context, opts ...grpc.CallOption) (ReverseClusterTroubleshootingService_TroubleshootDialClient, error)
}

type reverseClusterTroubleshootingServiceClient struct {
	cc *grpc.ClientConn
}

func NewReverseClusterTroubleshootingServiceClient(cc *grpc.ClientConn) ReverseClusterTroubleshootingServiceClient {
	return &reverseClusterTroubleshootingServiceClient{cc}
}

func (c *reverseClusterTroubleshootingServiceClient) TroubleshootDial(ctx context.Context, opts ...grpc.CallOption) (ReverseClusterTroubleshootingService_TroubleshootDialClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ReverseClusterTroubleshootingService_serviceDesc.Streams[0], "/tetrate.api.troubleshoot.cluster.v1.ReverseClusterTroubleshootingService/TroubleshootDial", opts...)
	if err != nil {
		return nil, err
	}
	x := &reverseClusterTroubleshootingServiceTroubleshootDialClient{stream}
	return x, nil
}

type ReverseClusterTroubleshootingService_TroubleshootDialClient interface {
	Send(*ClusterTroubleshootResponse) error
	Recv() (*ClusterTroubleshootRequest, error)
	grpc.ClientStream
}

type reverseClusterTroubleshootingServiceTroubleshootDialClient struct {
	grpc.ClientStream
}

func (x *reverseClusterTroubleshootingServiceTroubleshootDialClient) Send(m *ClusterTroubleshootResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *reverseClusterTroubleshootingServiceTroubleshootDialClient) Recv() (*ClusterTroubleshootRequest, error) {
	m := new(ClusterTroubleshootRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ReverseClusterTroubleshootingServiceServer is the server API for ReverseClusterTroubleshootingService service.
type ReverseClusterTroubleshootingServiceServer interface {
	TroubleshootDial(ReverseClusterTroubleshootingService_TroubleshootDialServer) error
}

// UnimplementedReverseClusterTroubleshootingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReverseClusterTroubleshootingServiceServer struct {
}

func (*UnimplementedReverseClusterTroubleshootingServiceServer) TroubleshootDial(srv ReverseClusterTroubleshootingService_TroubleshootDialServer) error {
	return status.Errorf(codes.Unimplemented, "method TroubleshootDial not implemented")
}

func RegisterReverseClusterTroubleshootingServiceServer(s *grpc.Server, srv ReverseClusterTroubleshootingServiceServer) {
	s.RegisterService(&_ReverseClusterTroubleshootingService_serviceDesc, srv)
}

func _ReverseClusterTroubleshootingService_TroubleshootDial_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReverseClusterTroubleshootingServiceServer).TroubleshootDial(&reverseClusterTroubleshootingServiceTroubleshootDialServer{stream})
}

type ReverseClusterTroubleshootingService_TroubleshootDialServer interface {
	Send(*ClusterTroubleshootRequest) error
	Recv() (*ClusterTroubleshootResponse, error)
	grpc.ServerStream
}

type reverseClusterTroubleshootingServiceTroubleshootDialServer struct {
	grpc.ServerStream
}

func (x *reverseClusterTroubleshootingServiceTroubleshootDialServer) Send(m *ClusterTroubleshootRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *reverseClusterTroubleshootingServiceTroubleshootDialServer) Recv() (*ClusterTroubleshootResponse, error) {
	m := new(ClusterTroubleshootResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ReverseClusterTroubleshootingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tetrate.api.troubleshoot.cluster.v1.ReverseClusterTroubleshootingService",
	HandlerType: (*ReverseClusterTroubleshootingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TroubleshootDial",
			Handler:       _ReverseClusterTroubleshootingService_TroubleshootDial_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "troubleshoot.proto",
}

func (m *ClusterTroubleshootRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterTroubleshootRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterTroubleshootRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Timeout != nil {
		{
			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTroubleshoot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RequestId != 0 {
		i = encodeVarintTroubleshoot(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterTroubleshootRequest_GetResources) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ClusterTroubleshootRequest_GetResources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetResources != nil {
		{
			size, err := m.GetResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTroubleshoot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ClusterTroubleshootResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterTroubleshootResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterTroubleshootResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RequestId != 0 {
		i = encodeVarintTroubleshoot(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterTroubleshootResponse_ResourcesStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ClusterTroubleshootResponse_ResourcesStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResourcesStatus != nil {
		{
			size, err := m.ResourcesStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTroubleshoot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResourcesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTroubleshoot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTroubleshoot(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTroubleshoot(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcesStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcesStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTroubleshoot(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTroubleshoot(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTroubleshoot(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalEndpoints != 0 {
		i = encodeVarintTroubleshoot(dAtA, i, uint64(m.TotalEndpoints))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.ActiveEndpoints != 0 {
		i = encodeVarintTroubleshoot(dAtA, i, uint64(m.ActiveEndpoints))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTroubleshoot(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTroubleshoot(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTroubleshoot(dAtA []byte, offset int, v uint64) int {
	offset -= sovTroubleshoot(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterTroubleshootRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovTroubleshoot(uint64(m.RequestId))
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovTroubleshoot(uint64(l))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterTroubleshootRequest_GetResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetResources != nil {
		l = m.GetResources.Size()
		n += 2 + l + sovTroubleshoot(uint64(l))
	}
	return n
}
func (m *ClusterTroubleshootResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovTroubleshoot(uint64(m.RequestId))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterTroubleshootResponse_ResourcesStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourcesStatus != nil {
		l = m.ResourcesStatus.Size()
		n += 2 + l + sovTroubleshoot(uint64(l))
	}
	return n
}
func (m *GetResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovTroubleshoot(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTroubleshoot(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTroubleshoot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcesStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTroubleshoot(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTroubleshoot(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTroubleshoot(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTroubleshoot(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTroubleshoot(uint64(l))
	}
	if m.ActiveEndpoints != 0 {
		n += 2 + sovTroubleshoot(uint64(m.ActiveEndpoints))
	}
	if m.TotalEndpoints != 0 {
		n += 2 + sovTroubleshoot(uint64(m.TotalEndpoints))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTroubleshoot(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTroubleshoot(x uint64) (n int) {
	return sovTroubleshoot(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterTroubleshootRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterTroubleshootRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterTroubleshootRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &types.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetResourcesRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClusterTroubleshootRequest_GetResources{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterTroubleshootResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterTroubleshootResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterTroubleshootResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResourcesStatusResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClusterTroubleshootResponse_ResourcesStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &ResourceRequest{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcesStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]*ResourceStatus)
			}
			var mapkey string
			var mapvalue *ResourceStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTroubleshoot
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTroubleshoot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTroubleshoot
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTroubleshoot
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTroubleshoot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTroubleshoot
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTroubleshoot
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResourceStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTroubleshoot(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTroubleshoot
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveEndpoints", wireType)
			}
			m.ActiveEndpoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveEndpoints |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEndpoints", wireType)
			}
			m.TotalEndpoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalEndpoints |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshoot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTroubleshoot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTroubleshoot(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTroubleshoot
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTroubleshoot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTroubleshoot
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTroubleshoot
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTroubleshoot
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTroubleshoot(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTroubleshoot
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTroubleshoot = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTroubleshoot   = fmt.Errorf("proto: integer overflow")
)
