// tslint:disable
/**
 * TCC Workflows API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 * Contact: info@tetrate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    TetrateApiTccCoreV1TLSMode,
    TetrateApiTccCoreV1TLSModeFromJSON,
    TetrateApiTccCoreV1TLSModeToJSON,
} from './';

/**
 * 
 * @export
 * @interface TetrateApiTccCoreV1TLSSettings
 */
export interface TetrateApiTccCoreV1TLSSettings {
    /**
     * 
     * @type {TetrateApiTccCoreV1TLSMode}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    tlsMode?: TetrateApiTccCoreV1TLSMode;
    /**
     * Enable TLS settings for the application.
     * @type {boolean}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    tlsEnabled?: boolean;
    /**
     * If set, the load balancer will redirect HTTP connections on port 80 to HTTPS port 443.
     * @type {boolean}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    redirectToHttps?: boolean;
    /**
     * For proxies running on VMs, the path to the file holding the server-side TLS certificate to use.
     * @type {string}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    serverCertificate?: string;
    /**
     * For proxies running on VMs, the path to the file holding the server\'s private key.
     * @type {string}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    privateKey?: string;
    /**
     * For proxies running on VMs, the path to a file containing certificate authority certificates to use in verifying a presented client side certificate for mutual TLS connections.
     * @type {string}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    caCertificates?: string;
    /**
     * For proxies running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Currently applicable only on Kubernetes. The secret (type generic) should contain the following keys and values: key: <privateKey>, cert: <serverCert>, cacert: <CACertificate>.  If the service is exposed via a load balancer, the secret must be accessible to it.
     * @type {string}
     * @memberof TetrateApiTccCoreV1TLSSettings
     */
    secretName?: string;
}

export function TetrateApiTccCoreV1TLSSettingsFromJSON(json: any): TetrateApiTccCoreV1TLSSettings {
    return {
        'tlsMode': !exists(json, 'tlsMode') ? undefined : TetrateApiTccCoreV1TLSModeFromJSON(json['tlsMode']),
        'tlsEnabled': !exists(json, 'tlsEnabled') ? undefined : json['tlsEnabled'],
        'redirectToHttps': !exists(json, 'redirectToHttps') ? undefined : json['redirectToHttps'],
        'serverCertificate': !exists(json, 'serverCertificate') ? undefined : json['serverCertificate'],
        'privateKey': !exists(json, 'privateKey') ? undefined : json['privateKey'],
        'caCertificates': !exists(json, 'caCertificates') ? undefined : json['caCertificates'],
        'secretName': !exists(json, 'secretName') ? undefined : json['secretName'],
    };
}

export function TetrateApiTccCoreV1TLSSettingsToJSON(value?: TetrateApiTccCoreV1TLSSettings): any {
    if (value === undefined) {
        return undefined;
    }
    return {
        'tlsMode': TetrateApiTccCoreV1TLSModeToJSON(value.tlsMode),
        'tlsEnabled': value.tlsEnabled,
        'redirectToHttps': value.redirectToHttps,
        'serverCertificate': value.serverCertificate,
        'privateKey': value.privateKey,
        'caCertificates': value.caCertificates,
        'secretName': value.secretName,
    };
}


