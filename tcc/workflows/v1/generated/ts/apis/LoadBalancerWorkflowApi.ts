// tslint:disable
/**
 * loadbalancer.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    TetrateApiTccWorkflowsV1ApproveRequest,
    TetrateApiTccWorkflowsV1ApproveRequestFromJSON,
    TetrateApiTccWorkflowsV1ApproveRequestToJSON,
    TetrateApiTccWorkflowsV1ApproveResponse,
    TetrateApiTccWorkflowsV1ApproveResponseFromJSON,
    TetrateApiTccWorkflowsV1ApproveResponseToJSON,
    TetrateApiTccWorkflowsV1CancelRequest,
    TetrateApiTccWorkflowsV1CancelRequestFromJSON,
    TetrateApiTccWorkflowsV1CancelRequestToJSON,
    TetrateApiTccWorkflowsV1CancelResponse,
    TetrateApiTccWorkflowsV1CancelResponseFromJSON,
    TetrateApiTccWorkflowsV1CancelResponseToJSON,
    TetrateApiTccWorkflowsV1DenyRequest,
    TetrateApiTccWorkflowsV1DenyRequestFromJSON,
    TetrateApiTccWorkflowsV1DenyRequestToJSON,
    TetrateApiTccWorkflowsV1DenyResponse,
    TetrateApiTccWorkflowsV1DenyResponseFromJSON,
    TetrateApiTccWorkflowsV1DenyResponseToJSON,
    TetrateApiTccWorkflowsV1ListPendingResponse,
    TetrateApiTccWorkflowsV1ListPendingResponseFromJSON,
    TetrateApiTccWorkflowsV1ListPendingResponseToJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequest,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestFromJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestToJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestFromJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON,
    TetrateApiTccWorkflowsV1Status,
    TetrateApiTccWorkflowsV1StatusFromJSON,
    TetrateApiTccWorkflowsV1StatusToJSON,
} from '../models';

export interface ApproveRequest {
    requestid: string;
    body: TetrateApiTccWorkflowsV1ApproveRequest;
}

export interface AttachRequest {
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest;
}

export interface CancelRequest {
    requestid: string;
    body: TetrateApiTccWorkflowsV1CancelRequest;
}

export interface DenyRequest {
    requestid: string;
    body: TetrateApiTccWorkflowsV1DenyRequest;
}

export interface DetachRequest {
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest;
}

export interface GetRequestStatusRequest {
    requestid: string;
}

export interface PublishRequest {
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequest;
}

/**
 * no description
 */
export class LoadBalancerWorkflowApi extends runtime.BaseAPI {

    /**
     * namespace members who own the load balancer & admins.
     */
    async approveRaw(requestParameters: ApproveRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1ApproveResponse>> {
        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling approve.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling approve.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/request/{requestid}/approve`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1ApproveRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1ApproveResponseFromJSON(jsonValue));
    }

    /**
     * namespace members who own the load balancer & admins.
     */
    async approve(requestParameters: ApproveRequest): Promise<TetrateApiTccWorkflowsV1ApproveResponse> {
        const response = await this.approveRaw(requestParameters);
        return await response.value();
    }

    /**
     * namespace members of the service being requested & admins. The API call must be made either by the admin or by owners of the namespaces whose services are being exposed. It is assumed that the load balancer has been created, deployed and imported into TCC through out of band mechanisms [for F5] or through service registry imports. The parameters should list the set of services that need to be exposed. Services will not be exposed until its approved by the namespace owner where the load balancer resides.
     */
    async attachRaw(requestParameters: AttachRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1Status>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling attach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/attach`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     * namespace members of the service being requested & admins. The API call must be made either by the admin or by owners of the namespaces whose services are being exposed. It is assumed that the load balancer has been created, deployed and imported into TCC through out of band mechanisms [for F5] or through service registry imports. The parameters should list the set of services that need to be exposed. Services will not be exposed until its approved by the namespace owner where the load balancer resides.
     */
    async attach(requestParameters: AttachRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.attachRaw(requestParameters);
        return await response.value();
    }

    /**
     * namespace members who own the load balancer & admins.
     */
    async cancelRaw(requestParameters: CancelRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1CancelResponse>> {
        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling cancel.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling cancel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/request/{requestid}/cancel`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1CancelRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1CancelResponseFromJSON(jsonValue));
    }

    /**
     * namespace members who own the load balancer & admins.
     */
    async cancel(requestParameters: CancelRequest): Promise<TetrateApiTccWorkflowsV1CancelResponse> {
        const response = await this.cancelRaw(requestParameters);
        return await response.value();
    }

    /**
     * namespace members who own the load balancer & admins.
     */
    async denyRaw(requestParameters: DenyRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1DenyResponse>> {
        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling deny.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deny.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/request/{requestid}/deny`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1DenyRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1DenyResponseFromJSON(jsonValue));
    }

    /**
     * namespace members who own the load balancer & admins.
     */
    async deny(requestParameters: DenyRequest): Promise<TetrateApiTccWorkflowsV1DenyResponse> {
        const response = await this.denyRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async detachRaw(requestParameters: DetachRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1Status>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling detach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/detach`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     */
    async detach(requestParameters: DetachRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.detachRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getRequestStatusRaw(requestParameters: GetRequestStatusRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1Status>> {
        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling getRequestStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/request/{requestid}/status`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     */
    async getRequestStatus(requestParameters: GetRequestStatusRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.getRequestStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async listPendingRequestsRaw(): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1ListPendingResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/pending`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1ListPendingResponseFromJSON(jsonValue));
    }

    /**
     */
    async listPendingRequests(): Promise<TetrateApiTccWorkflowsV1ListPendingResponse> {
        const response = await this.listPendingRequestsRaw();
        return await response.value();
    }

    /**
     * LB owner calls this API with additional settings like TLS, to finally expose the service on the load balancer
     */
    async publishRaw(requestParameters: PublishRequest): Promise<runtime.ApiResponse<TetrateApiTccWorkflowsV1Status>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling publish.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/workflows/loadbalancer/publish`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     * LB owner calls this API with additional settings like TLS, to finally expose the service on the load balancer
     */
    async publish(requestParameters: PublishRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.publishRaw(requestParameters);
        return await response.value();
    }

}
