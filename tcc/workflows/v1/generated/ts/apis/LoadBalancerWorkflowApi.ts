// tslint:disable
/**
 * TCC Workflows API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 * Contact: info@tetrate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    TetrateApiTccWorkflowsV1ApproveRequest,
    TetrateApiTccWorkflowsV1ApproveRequestFromJSON,
    TetrateApiTccWorkflowsV1ApproveRequestToJSON,
    TetrateApiTccWorkflowsV1ApproveResponse,
    TetrateApiTccWorkflowsV1ApproveResponseFromJSON,
    TetrateApiTccWorkflowsV1ApproveResponseToJSON,
    TetrateApiTccWorkflowsV1CancelRequest,
    TetrateApiTccWorkflowsV1CancelRequestFromJSON,
    TetrateApiTccWorkflowsV1CancelRequestToJSON,
    TetrateApiTccWorkflowsV1CancelResponse,
    TetrateApiTccWorkflowsV1CancelResponseFromJSON,
    TetrateApiTccWorkflowsV1CancelResponseToJSON,
    TetrateApiTccWorkflowsV1DenyRequest,
    TetrateApiTccWorkflowsV1DenyRequestFromJSON,
    TetrateApiTccWorkflowsV1DenyRequestToJSON,
    TetrateApiTccWorkflowsV1DenyResponse,
    TetrateApiTccWorkflowsV1DenyResponseFromJSON,
    TetrateApiTccWorkflowsV1DenyResponseToJSON,
    TetrateApiTccWorkflowsV1ListPendingResponse,
    TetrateApiTccWorkflowsV1ListPendingResponseFromJSON,
    TetrateApiTccWorkflowsV1ListPendingResponseToJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequest,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestFromJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestToJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestFromJSON,
    TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON,
    TetrateApiTccWorkflowsV1Status,
    TetrateApiTccWorkflowsV1StatusFromJSON,
    TetrateApiTccWorkflowsV1StatusToJSON,
} from '../models';

export interface ApproveRequest {
    tenant: string;
    cluster: string;
    requestid: string;
    body: TetrateApiTccWorkflowsV1ApproveRequest;
}

export interface AttachRequest {
    tenant: string;
    cluster: string;
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest;
}

export interface CancelRequest {
    tenant: string;
    cluster: string;
    requestid: string;
    body: TetrateApiTccWorkflowsV1CancelRequest;
}

export interface DenyRequest {
    tenant: string;
    cluster: string;
    requestid: string;
    body: TetrateApiTccWorkflowsV1DenyRequest;
}

export interface DetachRequest {
    tenant: string;
    cluster: string;
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequest;
}

export interface GetRequestStatusRequest {
    tenant: string;
    cluster: string;
    requestid: string;
}

export interface ListPendingRequestsRequest {
    tenant: string;
    cluster: string;
}

export interface PublishRequest {
    tenant: string;
    cluster: string;
    body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequest;
}

/**
 * no description
 */
export class LoadBalancerWorkflowApi extends runtime.BaseAPI {

    /**
     */
    async approveRaw(requestParameters: ApproveRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling approve.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling approve.');
        }

        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling approve.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling approve.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/approve`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))).replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1ApproveRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1ApproveResponseFromJSON(jsonValue));
    }

    /**
     */
    async approve(requestParameters: ApproveRequest): Promise<TetrateApiTccWorkflowsV1ApproveResponse> {
        const response = await this.approveRaw(requestParameters);
        return await response.value();
    }

    /**
     * namespace members of the service being requested & admins. The API call must be made either by the admin or by owners of the namespaces whose services are being exposed. It is assumed that the load balancer has been created, deployed and imported into TCC through out of band mechanisms [for F5] or through service registry imports. The parameters should list the set of services that need to be exposed. Services will not be exposed until its approved by the namespace owner where the load balancer resides.
     */
    async attachRaw(requestParameters: AttachRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling attach.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling attach.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling attach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/attach`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     * namespace members of the service being requested & admins. The API call must be made either by the admin or by owners of the namespaces whose services are being exposed. It is assumed that the load balancer has been created, deployed and imported into TCC through out of band mechanisms [for F5] or through service registry imports. The parameters should list the set of services that need to be exposed. Services will not be exposed until its approved by the namespace owner where the load balancer resides.
     */
    async attach(requestParameters: AttachRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.attachRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async cancelRaw(requestParameters: CancelRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling cancel.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling cancel.');
        }

        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling cancel.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling cancel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/cancel`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))).replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1CancelRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1CancelResponseFromJSON(jsonValue));
    }

    /**
     */
    async cancel(requestParameters: CancelRequest): Promise<TetrateApiTccWorkflowsV1CancelResponse> {
        const response = await this.cancelRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async denyRaw(requestParameters: DenyRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling deny.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling deny.');
        }

        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling deny.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling deny.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/deny`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))).replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1DenyRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1DenyResponseFromJSON(jsonValue));
    }

    /**
     */
    async deny(requestParameters: DenyRequest): Promise<TetrateApiTccWorkflowsV1DenyResponse> {
        const response = await this.denyRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async detachRaw(requestParameters: DetachRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling detach.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling detach.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling detach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/detach`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowUserRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     */
    async detach(requestParameters: DetachRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.detachRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async getRequestStatusRaw(requestParameters: GetRequestStatusRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling getRequestStatus.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling getRequestStatus.');
        }

        if (requestParameters.requestid === null || requestParameters.requestid === undefined) {
            throw new runtime.RequiredError('requestid','Required parameter requestParameters.requestid was null or undefined when calling getRequestStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/status`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))).replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     */
    async getRequestStatus(requestParameters: GetRequestStatusRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.getRequestStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async listPendingRequestsRaw(requestParameters: ListPendingRequestsRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling listPendingRequests.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling listPendingRequests.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/pending`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1ListPendingResponseFromJSON(jsonValue));
    }

    /**
     */
    async listPendingRequests(requestParameters: ListPendingRequestsRequest): Promise<TetrateApiTccWorkflowsV1ListPendingResponse> {
        const response = await this.listPendingRequestsRaw(requestParameters);
        return await response.value();
    }

    /**
     * LB owner calls this API with additional settings like TLS, to finally expose the service on the load balancer
     */
    async publishRaw(requestParameters: PublishRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling publish.');
        }

        if (requestParameters.cluster === null || requestParameters.cluster === undefined) {
            throw new runtime.RequiredError('cluster','Required parameter requestParameters.cluster was null or undefined when calling publish.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling publish.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/publish`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))).replace(`{${"cluster"}}`, encodeURIComponent(String(requestParameters.cluster))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TetrateApiTccWorkflowsV1LoadBalancerWorkflowOwnerRequestToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TetrateApiTccWorkflowsV1StatusFromJSON(jsonValue));
    }

    /**
     * LB owner calls this API with additional settings like TLS, to finally expose the service on the load balancer
     */
    async publish(requestParameters: PublishRequest): Promise<TetrateApiTccWorkflowsV1Status> {
        const response = await this.publishRaw(requestParameters);
        return await response.value();
    }

}
