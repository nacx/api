// tslint:disable
/**
 * loadbalancer.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists } from '../runtime';
/**
 * 
 * @export
 * @interface TetrateApiTccWorkflowsV1TLSSettings
 */
export interface TetrateApiTccWorkflowsV1TLSSettings {
    /**
     * If specified, only allow requests that match the SNI value.
     * @type {string}
     * @memberof TetrateApiTccWorkflowsV1TLSSettings
     */
    sni?: string;
    /**
     * For proxies running on VMs, the path to the file holding the server-side TLS certificate to use.
     * @type {string}
     * @memberof TetrateApiTccWorkflowsV1TLSSettings
     */
    serverCertificate?: string;
    /**
     * For proxies running on VMs, the path to the file holding the server's private key.
     * @type {string}
     * @memberof TetrateApiTccWorkflowsV1TLSSettings
     */
    privateKey?: string;
    /**
     * For proxies running on VMs, the path to a file containing certificate authority certificates to use in verifying a presented client side certificate for mutual TLS connections.
     * @type {string}
     * @memberof TetrateApiTccWorkflowsV1TLSSettings
     */
    caCertificates?: string;
    /**
     * For proxies running on Kubernetes, the name of the secret that holds the TLS certs. Currently applicable only on Kubernetes. The secret should contain the server certificate and the private key. If mutual TLS is being used, an additional secret with name secretName-cacert should be created with the CaCertificates that the server will use to verify client side certificates. If the service is exposed via a load balancer, the secret must be accessible to it.
     * @type {string}
     * @memberof TetrateApiTccWorkflowsV1TLSSettings
     */
    secretName?: string;
}

export function TetrateApiTccWorkflowsV1TLSSettingsFromJSON(json: any): TetrateApiTccWorkflowsV1TLSSettings {
    return {
        'sni': !exists(json, 'sni') ? undefined : json['sni'],
        'serverCertificate': !exists(json, 'serverCertificate') ? undefined : json['serverCertificate'],
        'privateKey': !exists(json, 'privateKey') ? undefined : json['privateKey'],
        'caCertificates': !exists(json, 'caCertificates') ? undefined : json['caCertificates'],
        'secretName': !exists(json, 'secretName') ? undefined : json['secretName'],
    };
}

export function TetrateApiTccWorkflowsV1TLSSettingsToJSON(value?: TetrateApiTccWorkflowsV1TLSSettings): any {
    if (value === undefined) {
        return undefined;
    }
    return {
        'sni': value.sni,
        'serverCertificate': value.serverCertificate,
        'privateKey': value.privateKey,
        'caCertificates': value.caCertificates,
        'secretName': value.secretName,
    };
}


