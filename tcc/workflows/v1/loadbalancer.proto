syntax = "proto3";

package tetrate.api.tcc.workflows.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/workflows/v1";

import "google/api/annotations.proto";

service LoadBalancerWorkflow {
  //    service owner   |  network admin
  // -------------------|-----------------
  // REQUESTED -> PENDING_APPROVAL -> APPROVED -> PUBLISHED
  //     V                       | -> DENIED
  //  REJECTED                   | -> CANCEL

  // namespace members of the service being requested & admins.
  // The API call must be made either by the admin or by owners of the
  // namespaces whose services are being exposed. It is assumed that
  // the load balancer has been created, deployed and imported into TCC
  // through out of band mechanisms [for F5] or through service registry
  // imports. The parameters should list the set of services that need
  // to be exposed. Services will not be exposed until its approved by
  // the namespace owner where the load balancer resides.
  rpc Attach(LoadBalancerWorkflowUserRequest) returns (Status) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/attach"
      body: "*"
    };
  };

  rpc Detach(LoadBalancerWorkflowUserRequest) returns (Status) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/detach"
      body: "*"
    };
  };

  // LB owner calls this API with additional settings like TLS, to
  // finally expose the service on the load balancer
  rpc Publish(LoadBalancerWorkflowOwnerRequest) returns (Status) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/publish"
      body: "*"
    };
  };

  rpc ListPendingRequests(ListRequests) returns (ListPendingResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/pending"
    };
  };

  rpc GetRequestStatus(GetStatus) returns (Status) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/status"
    };
  }

  rpc Approve(ApproveRequest) returns (ApproveResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/approve"
      body: "*"
    };
  };

  rpc Deny(DenyRequest) returns (DenyResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/deny"
      body: "*"
    };
  };

  rpc Cancel(CancelRequest) returns (CancelResponse) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/workflows/clusters/{cluster}/loadbalancer/request/{requestid}/cancel"
      body: "*"
    };
  };
}

message LoadBalancerWorkflowUserRequest {
  string loadbalancer_name = 1;
  string loadbalancer_namespace = 2;

  string service_hostname = 3;
  string service_namespace = 4;

  string cluster = 5;
  string tenant = 6;
}

message Status {
  string cluster = 1;
  // e.g. attach-789
  string requestid = 2;

  bool approved = 3;
  bool published = 4;
  string note = 5;
}

message GetStatus {
  // e.g. attach-789
  string requestid = 1;
  string cluster = 2;
  string tenant = 3;
}

message ListRequests {
  string cluster = 1;
  string tenant = 2;
}

message ListPendingResponse {
  message PendingRequest {
    string loadbalancer_name = 1;
    string loadbalancer_namespace = 2;
    string service_hostname = 3;
    string service_namespace = 4;
    enum OP {
      ATTACH = 0;
      DETACH = 1;
    }
    OP operation = 5;
  }

  string cluster = 1;
  repeated PendingRequest pending_requests = 2;
}

message ApproveRequest {
  string requestid = 1;
  string cluster = 2;
  string tenant = 3;
}

message DenyRequest {
  string requestid = 1;
  string cluster = 2;
  string tenant = 3;
}

message CancelRequest {
  string requestid = 1;
  string cluster = 2;
  string tenant = 3;
}

message ApproveResponse {
  string requestid = 1;
  string cluster = 2;
  // optional description of the approval (e.g. to be recorded in audit logs)
  string note = 3;
}

message DenyResponse {
  string requestid = 1;
  string cluster = 2;
  // optional description of the denial (e.g. to be recorded in audit logs)
  string note = 3;
}

message CancelResponse {
  string requestid = 1;
  string cluster = 2;
  // optional description of the cancelation (e.g. to be recorded in audit logs)
  string note = 3;
}

message LoadBalancerWorkflowOwnerRequest {
  string loadbalancer_name = 1;
  string loadbalancer_namespace = 2;
  string service_name = 3;
  string service_namespace = 4;
  string cluster = 5;
  string tenant = 6;
  TLSSettings tls = 7;
}

message TLSSettings {
  // If specified, only allow requests that match the SNI value.
  string sni = 1;

  // For proxies running on VMs, the path to the file holding the
  // server-side TLS certificate to use.
  string server_certificate = 2;

  // For proxies running on VMs, the path to the file holding the
  // server's private key.
  string private_key = 3;

  // For proxies running on VMs, the path to a file containing
  // certificate authority certificates to use in verifying a
  // presented client side certificate for mutual TLS connections.
  string ca_certificates = 4;

  // For proxies running on Kubernetes, the name of the secret that
  // holds the TLS certs. Currently applicable only on Kubernetes.
  // The secret should contain the server certificate and the private
  // key. If mutual TLS is being used, an additional secret with name
  // secretName-cacert should be created with the CaCertificates that
  // the server will use to verify client side certificates. If the
  // service is exposed via a load balancer, the secret must be
  // accessible to it.
  string secret_name = 5;
}
