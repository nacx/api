// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service_definition_crd.proto

package v1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ServiceDefinition describes the properties of services running on
// VMs or services outside the mesh. This service definition is
// intended to be authored by the cluster operator where access to
// this service is desired.
//
// The following example declares a VM service called `details` in the
// `bookinfo` namespace. The service has no sidecars and requires
// simple TLS connections. The VM service is expected to receive
// traffic from the ingress Gateway.
//
// ```yaml
// apiVersion: registry.tetrate.io/v1alpha1
// kind: ServiceDefinition
// metadata:
//   name: details
//   namespace: bookinfo
// spec:
//   hostname: details.prod.internal.company.com
//   ports:
//   - number: 80
//     name: http
//     protocol: HTTP
//   - number: 443
//     name: https
//     protocol: HTTPS
//   sidecarsPresent: false
//   externalServiceTlsSettings:
//     tlsMode: SIMPLE
//     caCertificates: /path/to/ca/cert/to/verify/server/cert
//   endpointSource:
//     manual:
//       values:
//       - address: 1.1.1.1
//       - address: 2.2.2.2
// ```
//
// In the above example, services in the bookinfo namespace can access
// the details service by using
// https://details.prod.internal.company.com . The sidecar would do a
// SNI Passthrough and load balance the traffic among the two
// endpoints. Alternatively, they could also access the service as
// plaintext http://details.prod.internal.company.com. The Sidecar in
// a kubernetes pod would intercept the traffic, and initiate simple
// TLS connection to the destination appropriately.
//
// The following example declares a `ratings` service in the
// `bookinfo` namespace that represents workloads running on a VM with
// sidecars installed with IPtables traffic capture, with access to
// mutual TLS certificates.
//
// ```yaml
// apiVersion: registry.tetrate.io/v1alpha1
// kind: ServiceDefinition
// metadata:
//   name: ratings
//   namespace: bookinfo
// spec:
//   hostname: ratings.prod.internal.company.com
//   ports:
//   - number: 80
//     name: http
//     protocol: HTTP
//   sidecarsPresent: true
//   endpointSource:
//     manual:
//       values:
//       - address: 3.3.3.3
//       - address: 4.4.4.4
// ```
//
// In the above example, services in the bookinfo namespace can access
// the ratings service by using
// http://ratings.prod.internal.company.com . The sidecar on
// kubernetes would intercept the traffic and initiate mutual TLS
// connection to the VM sidecar on port 80. The VM sidecar, after TLS
// termination, would forward the traffic to the application process
// on 127.0.0.1:80.
//
// Developing on the previous example, if the VM Service does not have
// IPtables based traffic capture, the application process has to
// either listen on a different port than port 80, or it has to listen
// only on 127.0.0.1 and not on 0.0.0.0. Let us assume that the
// application process is listening on port 9080. The sidecar would
// receive traffic on port 80, do TLS termination and forward the
// traffic to the application process on 127.0.0.1:9080.
//
// ```yaml
// apiVersion: registry.tetrate.io/v1alpha1
// kind: ServiceDefinition
// metadata:
//   name: ratings
//   namespace: bookinfo
// spec:
//   hostname: ratings.prod.internal.company.com
//   ports:
//   - number: 80
//     name: http
//     protocol: HTTP
//     applicationPort: 9080 # where the app process is listening
//   sidecarsPresent: true
//   sidecarSettings:
//     usingIptablesCapture: false
//   endpointSource:
//     manual:
//       values:
//       - address: 3.3.3.3
//       - address: 4.4.4.4
// ```
//
// In the above example, all outbound traffic from the application
// process will not transit through the sidecar. Let us assume that
// the application wishes to interact with the `details` VM services in the
// same namespace using the sidecar. The application process can
// choose to use the sidecar in the outbound path as well by treating
// it as a HTTP Proxy on localhost. By setting the HTTP_PROXY
// environment variable to http://localhost:15080, or using a language
// runtime specific option, all outbound plaintext HTTP traffic from
// the application process will be forwarded to the sidecar on port
// 15080. The sidecar would then initiate mutual TLS connections or simple TLS connections as
// appropriate to other services in the mesh.
//
// ```yaml
// apiVersion: registry.tetrate.io/v1alpha1
// kind: ServiceDefinition
// metadata:
//   name: ratings
//   namespace: bookinfo
// spec:
//   hostname: ratings.prod.internal.company.com
//   ports:
//   - number: 80
//     name: http
//     protocol: HTTP
//     applicationPort: 9080 # where the app process is listening
//   sidecarsPresent: true
//   sidecarSettings:
//     usingIptablesCapture: false
//     egressHttpProxyPort: 15080 # outbound traffic explicitly sent here.
//   endpointSource:
//     manual:
//       values:
//       - address: 3.3.3.3
//       - address: 4.4.4.4
// ```
//
// Instead of specifying the endpoints manually, it is possible to automatically obtain the
// list of endpoints from external sources. The appropriate endpoint controller must be installed
// in TSB Local Control Plane for this to work. The following example demonstrates reading the
// endpoints of the ratings service directly from VMware vCenter.
//
// ```yaml
// apiVersion: registry.tetrate.io/v1alpha1
// kind: ServiceDefinition
// metadata:
//   name: ratings
//   namespace: bookinfo
// spec:
//   hostname: ratings.prod.internal.company.com
//   ports:
//   - number: 80
//     name: http
//     protocol: HTTP
//     applicationPort: 9080 # where the app process is listening
//   sidecarsPresent: true
//   sidecarSettings:
//     usingIptablesCapture: false
//     egressHttpProxyPort: 15080 # outbound traffic explicitly sent here.
//   endpointSource:
//     vmware:
//       context: us-dal01 # must match key in the secrets containing the list of vCenter URLs with
//       username/passwords.
//       guestNetwork: "vm-prod-1" # Only get the IPs of VM NICs in this network.
//       vmResourcePaths: # the inventory path
//       - /dal01/vm/apps/bookinfo/ratings-01
//       - /dal01/vm/apps/bookinfo/ratings-02
//       - /dal01/vm/apps/bookinfo/ratings-03
// ```
//
// In the above example, the IP addresses assigned to the NICs
// belonging to the "vm-prod-1" network in the VMs with the specified
// inventory paths will be automatically added as endpoints to the
// ratings service and populated in the TSB catalog.
//
type ServiceDefinition struct {
	// Hostname by which this service will be accessed.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// List of ports and protocols associated with the service.
	Ports []*Port `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	// If set to true, all communication with the endpoints will be over
	// mutual TLS. If set to false, TLS settings for communicating with
	// the service must be specified explicitly.
	SidecarsPresent bool `protobuf:"varint,3,opt,name=sidecars_present,json=sidecarsPresent,proto3" json:"sidecars_present,omitempty"`
	// Settings for the sidecar on the VM. If omitted, and
	// sidecarsPresent is set to true, the VM will
	// be assumed to have sidecars with Istio mutual TLS enabled.
	SidecarSettings *SidecarSettings `protobuf:"bytes,4,opt,name=sidecar_settings,json=sidecarSettings,proto3" json:"sidecar_settings,omitempty"`
	// When sidecars are not present, the service is assumed to be
	// outside the mesh. Specify the TLS settings that client side
	// proxies such as Gateways or Sidecars should use to talk to this
	// service.
	ExternalServiceTlsSettings *TLSSettings `protobuf:"bytes,5,opt,name=external_service_tls_settings,json=externalServiceTlsSettings,proto3" json:"external_service_tls_settings,omitempty"`
	// The list of subject alternate names allowed for workload
	// instances that implement this service. This information is used
	// to enforce
	// [secure-naming](https://istio.io/docs/concepts/security/#secure-naming)
	// on the client side.  If specified, the client side proxy will
	// verify that the server certificate's subject alternate name
	// matches one of the specified values.  If omitted, defaults to the
	// SAN corresponding to the default service account in the namespace
	// where this resource is defined.
	SubjectAltNames      []string                          `protobuf:"bytes,6,rep,name=subject_alt_names,json=subjectAltNames,proto3" json:"subject_alt_names,omitempty"`
	EndpointSource       *ServiceDefinition_EndpointSource `protobuf:"bytes,7,opt,name=endpoint_source,json=endpointSource,proto3" json:"endpoint_source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ServiceDefinition) Reset()         { *m = ServiceDefinition{} }
func (m *ServiceDefinition) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition) ProtoMessage()    {}
func (*ServiceDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0}
}
func (m *ServiceDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition.Merge(m, src)
}
func (m *ServiceDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition proto.InternalMessageInfo

func (m *ServiceDefinition) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ServiceDefinition) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ServiceDefinition) GetSidecarsPresent() bool {
	if m != nil {
		return m.SidecarsPresent
	}
	return false
}

func (m *ServiceDefinition) GetSidecarSettings() *SidecarSettings {
	if m != nil {
		return m.SidecarSettings
	}
	return nil
}

func (m *ServiceDefinition) GetExternalServiceTlsSettings() *TLSSettings {
	if m != nil {
		return m.ExternalServiceTlsSettings
	}
	return nil
}

func (m *ServiceDefinition) GetSubjectAltNames() []string {
	if m != nil {
		return m.SubjectAltNames
	}
	return nil
}

func (m *ServiceDefinition) GetEndpointSource() *ServiceDefinition_EndpointSource {
	if m != nil {
		return m.EndpointSource
	}
	return nil
}

type ServiceDefinition_ManualSource struct {
	Values               []*StaticEndpoint `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceDefinition_ManualSource) Reset()         { *m = ServiceDefinition_ManualSource{} }
func (m *ServiceDefinition_ManualSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_ManualSource) ProtoMessage()    {}
func (*ServiceDefinition_ManualSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 0}
}
func (m *ServiceDefinition_ManualSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_ManualSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_ManualSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_ManualSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_ManualSource.Merge(m, src)
}
func (m *ServiceDefinition_ManualSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_ManualSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_ManualSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_ManualSource proto.InternalMessageInfo

func (m *ServiceDefinition_ManualSource) GetValues() []*StaticEndpoint {
	if m != nil {
		return m.Values
	}
	return nil
}

type ServiceDefinition_AWSSource struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceDefinition_AWSSource) Reset()         { *m = ServiceDefinition_AWSSource{} }
func (m *ServiceDefinition_AWSSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_AWSSource) ProtoMessage()    {}
func (*ServiceDefinition_AWSSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 1}
}
func (m *ServiceDefinition_AWSSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_AWSSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_AWSSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_AWSSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_AWSSource.Merge(m, src)
}
func (m *ServiceDefinition_AWSSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_AWSSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_AWSSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_AWSSource proto.InternalMessageInfo

type ServiceDefinition_GCPSource struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceDefinition_GCPSource) Reset()         { *m = ServiceDefinition_GCPSource{} }
func (m *ServiceDefinition_GCPSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_GCPSource) ProtoMessage()    {}
func (*ServiceDefinition_GCPSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 2}
}
func (m *ServiceDefinition_GCPSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_GCPSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_GCPSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_GCPSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_GCPSource.Merge(m, src)
}
func (m *ServiceDefinition_GCPSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_GCPSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_GCPSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_GCPSource proto.InternalMessageInfo

type ServiceDefinition_AzureSource struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceDefinition_AzureSource) Reset()         { *m = ServiceDefinition_AzureSource{} }
func (m *ServiceDefinition_AzureSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_AzureSource) ProtoMessage()    {}
func (*ServiceDefinition_AzureSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 3}
}
func (m *ServiceDefinition_AzureSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_AzureSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_AzureSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_AzureSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_AzureSource.Merge(m, src)
}
func (m *ServiceDefinition_AzureSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_AzureSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_AzureSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_AzureSource proto.InternalMessageInfo

type ServiceDefinition_VMwareSource struct {
	// REQUIRED. The key in the secret that maps to the vCenter to
	// use. A kubernetes secret with a map of key->vCenter URLs (in
	// https://user:password@host:port/sdk format) must be mounted in
	// tsbd pod and supplied using the vmware-credentials-file command
	// line argument.
	Context string `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// When selecting the VM IP address to use on a VM with multiple
	// NICs where each NIC is attached to a different network, the
	// guestNetwork field determines the network/NIC whose IP
	// addresses can be used. If omitted, the IP address from
	// guest.IpAddress property (i.e. the default reported in vCenter)
	// will be used. Can be omitted if VMs have only one NIC.
	GuestNetwork string `protobuf:"bytes,2,opt,name=guest_network,json=guestNetwork,proto3" json:"guest_network,omitempty"`
	// The full (case sensitive) inventory path to the VM resources in
	// the vCenter inventory. E.g., /dc0/vm/folder1/folder2/vm-name
	VmResourcePaths      []string `protobuf:"bytes,3,rep,name=vm_resource_paths,json=vmResourcePaths,proto3" json:"vm_resource_paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceDefinition_VMwareSource) Reset()         { *m = ServiceDefinition_VMwareSource{} }
func (m *ServiceDefinition_VMwareSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_VMwareSource) ProtoMessage()    {}
func (*ServiceDefinition_VMwareSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 4}
}
func (m *ServiceDefinition_VMwareSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_VMwareSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_VMwareSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_VMwareSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_VMwareSource.Merge(m, src)
}
func (m *ServiceDefinition_VMwareSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_VMwareSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_VMwareSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_VMwareSource proto.InternalMessageInfo

func (m *ServiceDefinition_VMwareSource) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *ServiceDefinition_VMwareSource) GetGuestNetwork() string {
	if m != nil {
		return m.GuestNetwork
	}
	return ""
}

func (m *ServiceDefinition_VMwareSource) GetVmResourcePaths() []string {
	if m != nil {
		return m.VmResourcePaths
	}
	return nil
}

type ServiceDefinition_RESTSource struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceDefinition_RESTSource) Reset()         { *m = ServiceDefinition_RESTSource{} }
func (m *ServiceDefinition_RESTSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_RESTSource) ProtoMessage()    {}
func (*ServiceDefinition_RESTSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 5}
}
func (m *ServiceDefinition_RESTSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_RESTSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_RESTSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_RESTSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_RESTSource.Merge(m, src)
}
func (m *ServiceDefinition_RESTSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_RESTSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_RESTSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_RESTSource proto.InternalMessageInfo

type ServiceDefinition_EndpointSource struct {
	Manual               *ServiceDefinition_ManualSource `protobuf:"bytes,1,opt,name=manual,proto3" json:"manual,omitempty"`
	Aws                  *ServiceDefinition_AWSSource    `protobuf:"bytes,2,opt,name=aws,proto3" json:"aws,omitempty"`
	Gcp                  *ServiceDefinition_GCPSource    `protobuf:"bytes,3,opt,name=gcp,proto3" json:"gcp,omitempty"`
	Azure                *ServiceDefinition_AzureSource  `protobuf:"bytes,4,opt,name=azure,proto3" json:"azure,omitempty"`
	Vmware               *ServiceDefinition_VMwareSource `protobuf:"bytes,5,opt,name=vmware,proto3" json:"vmware,omitempty"`
	Other                *ServiceDefinition_RESTSource   `protobuf:"bytes,6,opt,name=other,proto3" json:"other,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ServiceDefinition_EndpointSource) Reset()         { *m = ServiceDefinition_EndpointSource{} }
func (m *ServiceDefinition_EndpointSource) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition_EndpointSource) ProtoMessage()    {}
func (*ServiceDefinition_EndpointSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{0, 6}
}
func (m *ServiceDefinition_EndpointSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition_EndpointSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition_EndpointSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceDefinition_EndpointSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition_EndpointSource.Merge(m, src)
}
func (m *ServiceDefinition_EndpointSource) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition_EndpointSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition_EndpointSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition_EndpointSource proto.InternalMessageInfo

func (m *ServiceDefinition_EndpointSource) GetManual() *ServiceDefinition_ManualSource {
	if m != nil {
		return m.Manual
	}
	return nil
}

func (m *ServiceDefinition_EndpointSource) GetAws() *ServiceDefinition_AWSSource {
	if m != nil {
		return m.Aws
	}
	return nil
}

func (m *ServiceDefinition_EndpointSource) GetGcp() *ServiceDefinition_GCPSource {
	if m != nil {
		return m.Gcp
	}
	return nil
}

func (m *ServiceDefinition_EndpointSource) GetAzure() *ServiceDefinition_AzureSource {
	if m != nil {
		return m.Azure
	}
	return nil
}

func (m *ServiceDefinition_EndpointSource) GetVmware() *ServiceDefinition_VMwareSource {
	if m != nil {
		return m.Vmware
	}
	return nil
}

func (m *ServiceDefinition_EndpointSource) GetOther() *ServiceDefinition_RESTSource {
	if m != nil {
		return m.Other
	}
	return nil
}

// Settings for the sidecar running on the VMs corresponding to the
// service.
type SidecarSettings struct {
	// Set to true if the sidecar has IPtables to capture all inbound
	// and outbound traffic from the user application
	// process. Defaults to true.
	UsingIptablesCapture *types.BoolValue `protobuf:"bytes,1,opt,name=using_iptables_capture,json=usingIptablesCapture,proto3" json:"using_iptables_capture,omitempty"`
	// In workloads where IPtables capture is not used, outbound HTTP
	// traffic from the application can be proxied though the local
	// sidecar on a specific port. To utilize this feature, HTTP proxy
	// should be enabled (either via environment variable
	// `HTTP_PROXY=http://localhost:PORT/`, or language runtime
	// specific options). Calls from the application for
	// http://foo.bar.com will be routed to the local sidecar, which
	// in turn will route the call appropriately to the destination
	// over mutual TLS.
	EgressHttpProxyPort  uint32   `protobuf:"varint,2,opt,name=egress_http_proxy_port,json=egressHttpProxyPort,proto3" json:"egress_http_proxy_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SidecarSettings) Reset()         { *m = SidecarSettings{} }
func (m *SidecarSettings) String() string { return proto.CompactTextString(m) }
func (*SidecarSettings) ProtoMessage()    {}
func (*SidecarSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{1}
}
func (m *SidecarSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarSettings.Merge(m, src)
}
func (m *SidecarSettings) XXX_Size() int {
	return m.Size()
}
func (m *SidecarSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarSettings.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarSettings proto.InternalMessageInfo

func (m *SidecarSettings) GetUsingIptablesCapture() *types.BoolValue {
	if m != nil {
		return m.UsingIptablesCapture
	}
	return nil
}

func (m *SidecarSettings) GetEgressHttpProxyPort() uint32 {
	if m != nil {
		return m.EgressHttpProxyPort
	}
	return 0
}

// Endpoint defines a network IP address associated with the service.
type StaticEndpoint struct {
	// REQUIRED: Address associated with the network endpoint without the
	// port.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Set of ports associated with the endpoint. The ports must be
	// associated with a port name that was declared as part of the
	// service. If omitted, the endpoint will be assumed to have the same ports
	// as the service.
	Ports map[string]uint32 `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// One or more labels associated with the endpoint.
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The locality associated with the endpoint. A locality corresponds
	// to a failure domain (e.g., country/region/zone). Arbitrary failure
	// domain hierarchies can be represented by separating each
	// encapsulating failure domain by /. For example, the locality of an
	// an endpoint in US, in US-East-1 region, within availability zone
	// az-1, in data center rack r11 can be represented as
	// us/us-east-1/az-1/r11. Istio will configure the sidecar to route to
	// endpoints within the same locality as the sidecar. If none of the
	// endpoints in the locality are available, endpoints parent locality
	// (but within the same network ID) will be chosen. For example, if
	// there are two endpoints in same network (networkID "n1"), say e1
	// with locality us/us-east-1/az-1/r11 and e2 with locality
	// us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality
	// will prefer e1 from the same locality over e2 from a different
	// locality. Endpoint e2 could be the IP associated with a gateway
	// (that bridges networks n1 and n2), or the IP associated with a
	// standard service endpoint.
	Locality string `protobuf:"bytes,4,opt,name=locality,proto3" json:"locality,omitempty"`
	// The load balancing weight associated with the endpoint. Endpoints
	// with higher weights will receive proportionally higher traffic.
	Weight               uint32   `protobuf:"varint,5,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StaticEndpoint) Reset()         { *m = StaticEndpoint{} }
func (m *StaticEndpoint) String() string { return proto.CompactTextString(m) }
func (*StaticEndpoint) ProtoMessage()    {}
func (*StaticEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_92df8994d7d46291, []int{2}
}
func (m *StaticEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaticEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaticEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticEndpoint.Merge(m, src)
}
func (m *StaticEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *StaticEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_StaticEndpoint proto.InternalMessageInfo

func (m *StaticEndpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *StaticEndpoint) GetPorts() map[string]uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *StaticEndpoint) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *StaticEndpoint) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *StaticEndpoint) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func init() {
	proto.RegisterType((*ServiceDefinition)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition")
	proto.RegisterType((*ServiceDefinition_ManualSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.ManualSource")
	proto.RegisterType((*ServiceDefinition_AWSSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.AWSSource")
	proto.RegisterType((*ServiceDefinition_GCPSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.GCPSource")
	proto.RegisterType((*ServiceDefinition_AzureSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.AzureSource")
	proto.RegisterType((*ServiceDefinition_VMwareSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.VMwareSource")
	proto.RegisterType((*ServiceDefinition_RESTSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.RESTSource")
	proto.RegisterType((*ServiceDefinition_EndpointSource)(nil), "tetrate.api.tcc.core.v1.ServiceDefinition.EndpointSource")
	proto.RegisterType((*SidecarSettings)(nil), "tetrate.api.tcc.core.v1.SidecarSettings")
	proto.RegisterType((*StaticEndpoint)(nil), "tetrate.api.tcc.core.v1.StaticEndpoint")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.tcc.core.v1.StaticEndpoint.LabelsEntry")
	proto.RegisterMapType((map[string]uint32)(nil), "tetrate.api.tcc.core.v1.StaticEndpoint.PortsEntry")
}

func init() { proto.RegisterFile("service_definition_crd.proto", fileDescriptor_92df8994d7d46291) }

var fileDescriptor_92df8994d7d46291 = []byte{
	// 857 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x06, 0xad, 0x5f, 0x4a, 0x34, 0xf4, 0x21, 0xde, 0x3f, 0x70, 0x09, 0x22, 0x31, 0x04, 0xb7,
	0x40, 0xd5, 0xa2, 0xa0, 0x10, 0xb9, 0x87, 0x24, 0x37, 0x85, 0x93, 0xba, 0x4d, 0x11, 0x27, 0x11,
	0x56, 0x46, 0x0a, 0xf4, 0x86, 0x58, 0x51, 0x6b, 0x8a, 0x0d, 0xc5, 0x25, 0x76, 0x87, 0x92, 0xd5,
	0x27, 0xe9, 0xe3, 0xf4, 0xb2, 0x97, 0x7d, 0x81, 0x02, 0x85, 0x2f, 0xfb, 0x14, 0xc5, 0x1e, 0x48,
	0xdb, 0x01, 0x84, 0x46, 0x77, 0xfc, 0x66, 0x77, 0xbe, 0x99, 0xfd, 0xe6, 0x40, 0x78, 0xa0, 0xb8,
	0x5c, 0x64, 0x09, 0x8f, 0xa7, 0xfc, 0x22, 0x2b, 0x32, 0xcc, 0x44, 0x11, 0x27, 0x72, 0x1a, 0x95,
	0x52, 0xa0, 0x20, 0x1f, 0x21, 0x47, 0xc9, 0x90, 0x47, 0xac, 0xcc, 0x22, 0x4c, 0x92, 0x28, 0x11,
	0x92, 0x47, 0x8b, 0x47, 0xe1, 0x83, 0x54, 0x88, 0x34, 0xe7, 0x03, 0x56, 0x66, 0x03, 0x56, 0x14,
	0x02, 0x99, 0xf6, 0x54, 0xd6, 0x2d, 0x3c, 0x74, 0xa7, 0x06, 0x4d, 0xaa, 0x8b, 0xc1, 0x52, 0xb2,
	0xb2, 0xe4, 0xb2, 0x3e, 0x27, 0x52, 0x54, 0x98, 0x15, 0x69, 0x9c, 0x15, 0x17, 0xc2, 0xd9, 0xf6,
	0x31, 0x57, 0x8a, 0xa3, 0x36, 0xbb, 0x6b, 0x47, 0xbf, 0x77, 0x61, 0x7f, 0x6c, 0xd3, 0xfb, 0xae,
	0xc9, 0x8e, 0x84, 0x70, 0x77, 0x26, 0x14, 0x16, 0x6c, 0xce, 0x03, 0xaf, 0xe7, 0xf5, 0xbb, 0xb4,
	0xc1, 0xe4, 0x18, 0xda, 0xa5, 0x90, 0xa8, 0x82, 0xad, 0x5e, 0xab, 0xef, 0x0f, 0x1f, 0x46, 0x6b,
	0xf2, 0x8f, 0x46, 0x42, 0x22, 0xb5, 0x77, 0xc9, 0x67, 0x70, 0x4f, 0x65, 0x53, 0x9e, 0x30, 0xa9,
	0xe2, 0x52, 0x72, 0xc5, 0x0b, 0x0c, 0x5a, 0x3d, 0xaf, 0x7f, 0x97, 0xee, 0xd5, 0xf6, 0x91, 0x35,
	0x93, 0x71, 0x73, 0x35, 0xae, 0x73, 0x0d, 0xfe, 0xd7, 0xf3, 0xfa, 0xfe, 0xb0, 0xbf, 0x36, 0xd4,
	0xd8, 0x3a, 0x8c, 0xdd, 0xfd, 0x86, 0xb4, 0x36, 0x90, 0x14, 0x1e, 0xf2, 0x4b, 0xe4, 0xb2, 0x60,
	0x79, 0x5c, 0x57, 0x03, 0x73, 0x75, 0x1d, 0xa1, 0x6d, 0x22, 0x7c, 0xb2, 0x36, 0xc2, 0xf9, 0xd9,
	0xb8, 0x61, 0x0f, 0x6b, 0x2a, 0x27, 0xdc, 0x79, 0xae, 0x9a, 0x40, 0x9f, 0xc3, 0xbe, 0xaa, 0x26,
	0xbf, 0xf0, 0x04, 0x63, 0x96, 0x63, 0xac, 0x15, 0x53, 0x41, 0xa7, 0xd7, 0xea, 0x77, 0xe9, 0x9e,
	0x3b, 0x38, 0xc9, 0xf1, 0xb5, 0x36, 0x93, 0x09, 0xec, 0xf1, 0x62, 0x5a, 0x8a, 0xac, 0xc0, 0x58,
	0x89, 0x4a, 0x26, 0x3c, 0xb8, 0x63, 0xd2, 0x78, 0xb2, 0xfe, 0xa1, 0xef, 0x97, 0x2a, 0x3a, 0x75,
	0x0c, 0x63, 0x43, 0x40, 0x77, 0xf9, 0x2d, 0x1c, 0xbe, 0x81, 0xed, 0x57, 0xac, 0xa8, 0x58, 0x6e,
	0x31, 0xf9, 0x16, 0x3a, 0x0b, 0x96, 0x57, 0x5c, 0x05, 0x9e, 0x29, 0xdf, 0xa7, 0xeb, 0x43, 0xe9,
	0x7e, 0x4b, 0x6a, 0x7a, 0xea, 0xdc, 0x42, 0x1f, 0xba, 0x27, 0x3f, 0x8d, 0x1d, 0xbb, 0x0f, 0xdd,
	0x1f, 0x9e, 0x8f, 0x1c, 0xd8, 0x01, 0xff, 0xe4, 0xd7, 0x4a, 0x72, 0x07, 0x57, 0xb0, 0xfd, 0xf6,
	0xd5, 0x92, 0xd5, 0x98, 0x04, 0x70, 0x27, 0x11, 0x05, 0xf2, 0x4b, 0x74, 0x2d, 0x55, 0x43, 0xf2,
	0x31, 0xec, 0xa4, 0x15, 0x57, 0x18, 0x17, 0x1c, 0x97, 0x42, 0xbe, 0x0b, 0xb6, 0xcc, 0xf9, 0xb6,
	0x31, 0xbe, 0xb6, 0x36, 0x2d, 0xec, 0x62, 0x1e, 0x4b, 0x6e, 0x85, 0x8a, 0x4b, 0x86, 0x33, 0x15,
	0xb4, 0xac, 0xb0, 0x8b, 0x39, 0x75, 0xf6, 0x91, 0x36, 0x87, 0xdb, 0x00, 0xf4, 0x74, 0x7c, 0xee,
	0x12, 0xf9, 0xab, 0x05, 0xbb, 0xb7, 0x55, 0x22, 0x6f, 0xa0, 0x33, 0x37, 0xaa, 0x98, 0x54, 0xfc,
	0xe1, 0x37, 0x1b, 0x08, 0x7e, 0x53, 0x4e, 0xea, 0x68, 0xc8, 0xf7, 0xd0, 0x62, 0x4b, 0x65, 0x12,
	0xf7, 0x87, 0x5f, 0x6e, 0xc0, 0xd6, 0x68, 0x49, 0x35, 0x81, 0xe6, 0x49, 0x93, 0xd2, 0x8c, 0xc6,
	0x66, 0x3c, 0x4d, 0x19, 0xa8, 0x26, 0x20, 0x67, 0xd0, 0x66, 0xba, 0x16, 0x6e, 0x72, 0xbe, 0xde,
	0x24, 0xa3, 0xeb, 0x1a, 0x52, 0x4b, 0xa2, 0xe5, 0x5a, 0xcc, 0x75, 0x29, 0xdd, 0x98, 0x6c, 0x22,
	0xd7, 0xcd, 0x1e, 0xa0, 0x8e, 0x86, 0xbc, 0x84, 0xb6, 0xc0, 0x19, 0x97, 0x41, 0xc7, 0xf0, 0x7d,
	0xb5, 0x01, 0xdf, 0x75, 0x61, 0xa9, 0xe5, 0x38, 0xfa, 0xcd, 0x83, 0xbd, 0xf7, 0x16, 0x00, 0x19,
	0xc1, 0x41, 0xa5, 0xcc, 0xf6, 0x2b, 0x91, 0x4d, 0x72, 0xae, 0xe2, 0x84, 0x95, 0xa8, 0x05, 0xb1,
	0x05, 0x0f, 0x23, 0xbb, 0x3e, 0xa3, 0x7a, 0x7d, 0x46, 0xcf, 0x84, 0xc8, 0xdf, 0xea, 0x16, 0xa7,
	0xf7, 0x8d, 0xe7, 0x8f, 0xce, 0xf1, 0xb9, 0xf5, 0x23, 0xc7, 0x70, 0xc0, 0x53, 0xc9, 0x95, 0x8a,
	0x67, 0x88, 0x65, 0x5c, 0x4a, 0x71, 0xb9, 0x8a, 0xf5, 0x72, 0x33, 0x45, 0xdf, 0xa1, 0xff, 0xb7,
	0xa7, 0x2f, 0x10, 0xcb, 0x91, 0x3e, 0xd3, 0xdb, 0xef, 0xe8, 0x9f, 0x2d, 0xd8, 0xbd, 0x3d, 0x47,
	0x7a, 0x0c, 0xd8, 0x74, 0xaa, 0xaf, 0xd6, 0x63, 0xe0, 0x20, 0x79, 0x71, 0x7b, 0xb1, 0x0e, 0x3f,
	0x70, 0x32, 0xcd, 0x9e, 0x55, 0xa7, 0x05, 0xca, 0x55, 0xbd, 0x6d, 0x5f, 0x42, 0x27, 0x67, 0x13,
	0x9e, 0xdb, 0x01, 0xf1, 0x87, 0xc7, 0x1f, 0x4a, 0x75, 0x66, 0xbc, 0x2c, 0x97, 0xa3, 0xd0, 0xff,
	0x82, 0x5c, 0x24, 0x2c, 0xcf, 0x70, 0x65, 0xba, 0xa9, 0x4b, 0x1b, 0x4c, 0x0e, 0xa0, 0xb3, 0xe4,
	0x59, 0x3a, 0x43, 0xd3, 0x18, 0x3b, 0xd4, 0xa1, 0xf0, 0x31, 0xc0, 0x75, 0x56, 0xe4, 0x1e, 0xb4,
	0xde, 0xf1, 0x95, 0x7b, 0xae, 0xfe, 0x24, 0xf7, 0xa1, 0x6d, 0xd6, 0x89, 0xd3, 0xce, 0x82, 0xa7,
	0x5b, 0x8f, 0xbd, 0xf0, 0x09, 0xf8, 0x37, 0x92, 0xf8, 0x2f, 0xd7, 0xee, 0x0d, 0xd7, 0x67, 0x4f,
	0xff, 0xb8, 0x3a, 0xf4, 0xfe, 0xbc, 0x3a, 0xf4, 0xfe, 0xbe, 0x3a, 0xf4, 0x7e, 0xfe, 0x22, 0xcd,
	0x70, 0x56, 0x4d, 0xa2, 0x44, 0xcc, 0x07, 0xee, 0xf5, 0x99, 0xa8, 0xbf, 0xcc, 0x3f, 0x15, 0x93,
	0x64, 0xa0, 0x75, 0x18, 0x2c, 0x1e, 0x4d, 0x3a, 0xa6, 0x0f, 0x8e, 0xff, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0xa3, 0xf0, 0x09, 0x25, 0xab, 0x07, 0x00, 0x00,
}

func (m *ServiceDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndpointSource != nil {
		{
			size, err := m.EndpointSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SubjectAltNames) > 0 {
		for iNdEx := len(m.SubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubjectAltNames[iNdEx])
			copy(dAtA[i:], m.SubjectAltNames[iNdEx])
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.SubjectAltNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ExternalServiceTlsSettings != nil {
		{
			size, err := m.ExternalServiceTlsSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SidecarSettings != nil {
		{
			size, err := m.SidecarSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SidecarsPresent {
		i--
		if m.SidecarsPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_ManualSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_ManualSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_ManualSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_AWSSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_AWSSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_AWSSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_GCPSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_GCPSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_GCPSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_AzureSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_AzureSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_AzureSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_VMwareSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_VMwareSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_VMwareSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmResourcePaths) > 0 {
		for iNdEx := len(m.VmResourcePaths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VmResourcePaths[iNdEx])
			copy(dAtA[i:], m.VmResourcePaths[iNdEx])
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.VmResourcePaths[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GuestNetwork) > 0 {
		i -= len(m.GuestNetwork)
		copy(dAtA[i:], m.GuestNetwork)
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.GuestNetwork)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_RESTSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_RESTSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_RESTSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDefinition_EndpointSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition_EndpointSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceDefinition_EndpointSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Other != nil {
		{
			size, err := m.Other.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Vmware != nil {
		{
			size, err := m.Vmware.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Azure != nil {
		{
			size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gcp != nil {
		{
			size, err := m.Gcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Manual != nil {
		{
			size, err := m.Manual.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SidecarSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SidecarSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EgressHttpProxyPort != 0 {
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(m.EgressHttpProxyPort))
		i--
		dAtA[i] = 0x10
	}
	if m.UsingIptablesCapture != nil {
		{
			size, err := m.UsingIptablesCapture.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Weight != 0 {
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Locality) > 0 {
		i -= len(m.Locality)
		copy(dAtA[i:], m.Locality)
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.Locality)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ports) > 0 {
		for k := range m.Ports {
			v := m.Ports[k]
			baseI := i
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintServiceDefinitionCrd(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintServiceDefinitionCrd(dAtA []byte, offset int, v uint64) int {
	offset -= sovServiceDefinitionCrd(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServiceDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovServiceDefinitionCrd(uint64(l))
		}
	}
	if m.SidecarsPresent {
		n += 2
	}
	if m.SidecarSettings != nil {
		l = m.SidecarSettings.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.ExternalServiceTlsSettings != nil {
		l = m.ExternalServiceTlsSettings.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if len(m.SubjectAltNames) > 0 {
		for _, s := range m.SubjectAltNames {
			l = len(s)
			n += 1 + l + sovServiceDefinitionCrd(uint64(l))
		}
	}
	if m.EndpointSource != nil {
		l = m.EndpointSource.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_ManualSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovServiceDefinitionCrd(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_AWSSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_GCPSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_AzureSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_VMwareSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	l = len(m.GuestNetwork)
	if l > 0 {
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if len(m.VmResourcePaths) > 0 {
		for _, s := range m.VmResourcePaths {
			l = len(s)
			n += 1 + l + sovServiceDefinitionCrd(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_RESTSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceDefinition_EndpointSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Manual != nil {
		l = m.Manual.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Gcp != nil {
		l = m.Gcp.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Vmware != nil {
		l = m.Vmware.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Other != nil {
		l = m.Other.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsingIptablesCapture != nil {
		l = m.UsingIptablesCapture.Size()
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.EgressHttpProxyPort != 0 {
		n += 1 + sovServiceDefinitionCrd(uint64(m.EgressHttpProxyPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaticEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovServiceDefinitionCrd(uint64(len(k))) + 1 + sovServiceDefinitionCrd(uint64(v))
			n += mapEntrySize + 1 + sovServiceDefinitionCrd(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovServiceDefinitionCrd(uint64(len(k))) + 1 + len(v) + sovServiceDefinitionCrd(uint64(len(v)))
			n += mapEntrySize + 1 + sovServiceDefinitionCrd(uint64(mapEntrySize))
		}
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovServiceDefinitionCrd(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovServiceDefinitionCrd(uint64(m.Weight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovServiceDefinitionCrd(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServiceDefinitionCrd(x uint64) (n int) {
	return sovServiceDefinitionCrd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarsPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SidecarsPresent = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarSettings == nil {
				m.SidecarSettings = &SidecarSettings{}
			}
			if err := m.SidecarSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalServiceTlsSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalServiceTlsSettings == nil {
				m.ExternalServiceTlsSettings = &TLSSettings{}
			}
			if err := m.ExternalServiceTlsSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSource == nil {
				m.EndpointSource = &ServiceDefinition_EndpointSource{}
			}
			if err := m.EndpointSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_ManualSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &StaticEndpoint{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_AWSSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_GCPSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_AzureSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_VMwareSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMwareSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMwareSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuestNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuestNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmResourcePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmResourcePaths = append(m.VmResourcePaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_RESTSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RESTSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RESTSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition_EndpointSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Manual == nil {
				m.Manual = &ServiceDefinition_ManualSource{}
			}
			if err := m.Manual.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aws == nil {
				m.Aws = &ServiceDefinition_AWSSource{}
			}
			if err := m.Aws.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gcp == nil {
				m.Gcp = &ServiceDefinition_GCPSource{}
			}
			if err := m.Gcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Azure == nil {
				m.Azure = &ServiceDefinition_AzureSource{}
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vmware", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vmware == nil {
				m.Vmware = &ServiceDefinition_VMwareSource{}
			}
			if err := m.Vmware.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Other == nil {
				m.Other = &ServiceDefinition_RESTSource{}
			}
			if err := m.Other.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsingIptablesCapture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsingIptablesCapture == nil {
				m.UsingIptablesCapture = &types.BoolValue{}
			}
			if err := m.UsingIptablesCapture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressHttpProxyPort", wireType)
			}
			m.EgressHttpProxyPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressHttpProxyPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServiceDefinitionCrd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDefinitionCrd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDefinitionCrd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServiceDefinitionCrd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDefinitionCrd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDefinitionCrd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServiceDefinitionCrd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDefinitionCrd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServiceDefinitionCrd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServiceDefinitionCrd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServiceDefinitionCrd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceDefinitionCrd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServiceDefinitionCrd
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthServiceDefinitionCrd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServiceDefinitionCrd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServiceDefinitionCrd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthServiceDefinitionCrd
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServiceDefinitionCrd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServiceDefinitionCrd   = fmt.Errorf("proto: integer overflow")
)
