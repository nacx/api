// Copyright (c) Tetrate, Inc 2019 All Rights Reserved.

syntax = "proto3";

package tetrate.api.tcc.core.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/core/v1";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";
import "tlssettings.proto";

// RoutingInfo (Deprecated)
//
// HTTP routing settings for application or service. Subsets of a service should be declared here as
// well.
message RoutingInfo {
  // One or more versions of the service. Each version has a distinct name and a set of labels that
  // help uniquely identify the pods/VMs of that version.
  repeated Subset subsets = 1;

  // HTTP specific settings, transformations and routing rules associated with HTTP traffic to this
  // service.
  HttpSettings http_settings = 2;

  // TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
  // this service.
  TcpSettings tcp_settings = 3;
}

enum ServiceType {
  // An internal service in an application that is not exposed to the outside world.
  INTERNAL = 0;
  // A load balancer service running only the proxy as the workload. A load balancer service inside
  // an user application forwards traffic to other services in the application. A load balancer
  // service inside the "system" application forwards traffic to services in other user
  // applications.
  LOADBALANCER = 1;
  // An external service (not in the mesh) accessed by the services in the application.
  EXTERNAL = 2;
}

enum LoadBalancerClass {
  NONE = 0;
  ENVOY = 1;
  F5 = 2;
}

enum LoadBalancerTier {
  TIER_NOT_SET = 0;
  TIER1 = 1;
  TIER2 = 2;
}

// LBRouteSettings
//
// HTTP/TCP routing settings for application exposed via a load balancer service. Enforced at load
// balancer only.
message LBRouteSettings {
  bool enable_workflows = 1;

  LoadBalancerClass load_balancer_class = 2 [(validate.rules).enum = {
    defined_only: true,
    not_in: [0]
  }];

  // Current restrictions: Tier1 load balancers can only route to other tier2 load balancers in any
  // cluster (local/remote). They cannot route to internal services in their local clusters. Tier2
  // load balancers can route to internal services in the same cluster only.
  LoadBalancerTier load_balancer_tier = 4;

  message LBRoute {
    // Hostname with which the application is exposed on this load balancer.
    string hostname = 1 [(validate.rules).string.min_len = 1];
    // TLS certificate info for the application. If nil, the gateway will expose the application on
    // port 80 only.
    TLSSettings tls = 2;
    // HTTP specific settings, transformations and routing rules associated with HTTP traffic to
    // this service.
    HttpSettings http_settings = 3;
    // TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
    // this service.
    TcpSettings tcp_settings = 4;
  };
  repeated LBRoute routes = 3;
}

// InternalRouteSettings
//
// HTTP/TCP routing settings for an internal service in an application. Enforced at the sidecars for
// services inside the same application.
message InternalRouteSettings {
  // HTTP specific settings, transformations and routing rules associated with HTTP traffic to this
  // service.
  HttpSettings http_settings = 1;

  // TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
  // this service.
  TcpSettings tcp_settings = 2;
};

// ExternalRouteSettings
//
// HTTP/TCP routing settings for an external service in the "system" application. Enforced at the
// external facing gateway in the "system" application.
message ExternalRouteSettings {
  // TLS certificate info for the external service. If nil, the gateway will communicate with the
  // external service over plain text.
  TLSSettings tls = 1;

  // HTTP specific settings, transformations and routing rules associated with HTTP traffic to this
  // service.
  HttpSettings http_settings = 2;

  // TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
  // this service.
  TcpSettings tcp_settings = 3;
};

enum Registry {
  UNKNOWN = 0;
  KUBERNETES = 1;
  VM = 2;
}

message Port {
  // A valid non-negative integer port number.
  uint32 number = 1;

  // clang-format off

  // The protocol exposed on the port. MUST BE one of HTTP|GRPC|HTTP2|HTTPS|TCP|TLS.
  //
  // TLS implies the connection will be routed based on the SNI header to the destination without
  // terminating the TLS connection.
  string protocol = 2 [(validate.rules).string = {in: ["HTTP", "GRPC", "HTTP2", "HTTPS", "TCP", "TLS", "UDP", "SCTP"]}];

  // clang-format on

  // Name assigned to the port.
  string name = 3;

  // The endpoint port to which this service port maps to. For example, service port 80 exposed on
  // the load balancer could map to an endpoint port 9080 on a VM.
  uint32 endpoint_port = 4;

  // Indicates the node port attached to a physical deployment on a kubernetes cluster.
  uint32 kubernetes_node_port = 5;
}

message Subset {
  string name = 1 [(validate.rules).string.min_len = 1];
  // Labels apply a filter over the endpoints of a service in the service registry.
  map<string, string> labels = 2 [(validate.rules).map.min_pairs = 1];
}

// HttpSettings
//
// HTTP settings for a service. Applicable to ports receiving HTTP traffic.
message HttpSettings {
  // Describes a HTTP cookie that will be used for sticky sessions. If the cookie is not present, it
  // will be generated.
  message HTTPCookie {
    // Name of the cookie.
    string name = 1 [(validate.rules).string.min_len = 1];

    // Path to set for the cookie.
    string path = 2 [(validate.rules).string.min_len = 1];

    // Lifetime of the cookie.
    google.protobuf.Duration ttl = 3 [(validate.rules).message.required = true];
  }

  // If set, the load balancer will route all requests from a particular client to the same backend
  // of the service.
  message StickySession {
    oneof hash_key {
      // Hash based on a specific HTTP header.
      string header = 1 [(validate.rules).string.min_len = 1];

      // Hash based on HTTP cookie.
      HTTPCookie cookie = 2;

      // Hash based on the source IP address.
      bool use_source_ip = 3;
    }
  }

  StickySession sticky_session = 1;
  CorsPolicy cors_policy = 2;
  repeated HttpRule route_rules = 3;
}

// TCP settings for a service. Applicable to ports receiving non-HTTP traffic.
message TcpSettings {
  // The destination to which the connection should be routed.
  Route route = 1 [(validate.rules).message.required = true];
}

// A single HTTP rule.
message HttpRule {
  // One or more match conditions (OR-ed).
  repeated HttpMatchCondition match = 1;

  // One or more mutations to be performed before forwarding. Includes typical modifications to be
  // done on a single request like URL rewrite, host rewrite, headers to add/remove/append.
  HttpModifyAction modify = 2;

  oneof route_or_redirect {
    Route route = 4;
    Redirect redirect = 5;
  }
}

// A single match clause to match all aspects of a request.
message HttpMatchCondition {
  // URI to match.
  StringMatch uri = 1;

  // URI Scheme
  StringMatch scheme = 2;

  // HTTP Method.
  StringMatch method = 3;

  // HTTP Authority.
  StringMatch authority = 4;

  // The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id.
  map<string, StringMatch> headers = 5;
}

// Describes how to match a given string in HTTP headers. Match is case-sensitive.
message StringMatch {
  oneof match_type {
    // Exact string match.
    string exact = 1;

    // Prefix-based match.
    string prefix = 2;

    // ECMAscript style regex-based match.
    string regex = 3;
  }
}

message HTTPRewrite {
  // Rewrite the path (or the prefix) portion of the URI with this value. If the original URI was
  // matched based on prefix, the value provided in this field will replace the corresponding
  // matched prefix.
  string uri = 1;

  // Rewrite the Authority/Host header with this value.
  string authority = 2;
}

// Header manipulation rules.
message Headers {
  // Header manipulation rules to apply before forwarding a request to the destination service.
  HeaderOperations request = 1;
  // Header manipulation rules to apply before returning a response to the caller.
  HeaderOperations response = 2;

  // HeaderOperations Describes the header manipulations to apply.
  message HeaderOperations {
    // Overwrite the headers specified by key with the given values.
    map<string, string> set = 1;
    // Append the given values to the headers specified by keys (will create a comma-separated list
    // of values).
    map<string, string> add = 2;
    // Remove a the specified headers.
    repeated string remove = 3;
  }
}

// HTTP path/url/header modification.
message HttpModifyAction {
  HTTPRewrite rewrite = 1;
  Headers headers = 2;
}

// One or more destinations in a local cluster for the given request.
message Route {
  // A destination local to the cluster where the load balancer or sidecar is present.
  message LocalDestination {
    // If omitted, will route to same application as the service. The application field is used by
    // load balancers in the system application to route to other applications.
    string application = 1;
    // If omitted, will route to the service owning this route.  When used with a Load Balancer
    // (shared or dedicated), traffic can be routed to another service in the same application or a
    // different application.
    string service = 2;
    // If omitted, will route to same host as the service.
    string host = 3 [deprecated = true];
    string subset = 4;
  }

  // A destination load balancer service in another cluster. This destination type is applicable
  // only when used with a load balancer service.
  message RemoteDestination {
    // If omitted, defaults to system application.
    string application = 1;
    // The load balancer service to route the traffic to.
    string service = 2 [(validate.rules).string.min_len = 1];
  }

  message Destination {
    oneof target {
      option (validate.required) = true;
      // A local destination.
      LocalDestination local = 1;
      // A remote destination.
      RemoteDestination remote = 2;
      // Instead of specifying local/remote services, you can specify the hostname/IP address to
      // which traffic should be routed to. This address should be reachable from the load balancer.
      // This destination type is applicable only when used with a load balancer service.
      string address = 3;
    }
    // The value of weight is 100 if omitted. The sum of all weights should add up to 100.
    uint32 weight = 4;
    // Optional.
    uint32 port = 5;
  }

  // All destinations within a route must be of the same type.
  repeated Destination destinations = 1 [(validate.rules).repeated = {min_items: 1}];
}

message Redirect {
  // On a redirect, overwrite the Path portion of the URL with this value.
  string uri = 1;
  // On a redirect, overwrite the Authority/Host portion of the URL with this value.
  string authority = 2;
}

message CorsPolicy {
  // The list of origins that are allowed to perform CORS requests. The content will be serialized
  // into the Access-Control-Allow-Origin header. Wildcard * will allow all origins.
  repeated string allow_origin = 1;
  // List of HTTP methods allowed to access the resource. The content will be serialized into the
  // Access-Control-Allow-Methods header.
  repeated string allow_methods = 2;
  // List of HTTP headers that can be used when requesting the resource. Serialized to
  // Access-Control-Allow-Headers header.
  repeated string allow_headers = 3;
  // A white list of HTTP headers that the browsers are allowed to access. Serialized into
  // Access-Control-Expose-Headers header.
  repeated string expose_headers = 4;
  // Specifies how long the results of a preflight request can be cached. Translates to the
  // Access-Control-Max-Age header.
  google.protobuf.Duration max_age = 5;
  // Indicates whether the caller is allowed to send the actual request (not the preflight) using
  // credentials. Translates to Access-Control-Allow-Credentials header.
  google.protobuf.BoolValue allow_credentials = 6;
}
