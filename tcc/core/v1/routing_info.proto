syntax = "proto3";

package tetrate.api.tcc.core.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/core/v1";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";
import "protoc-gen-swagger/options/annotations.proto";

message RoutingInfo {
  option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			title: "Routing Info"
			description: "HTTP routing settings for application or service. Subsets of a service should be declared here as well."
		}
	};
  repeated Subset subsets = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "One or more versions of the service. Each version has a distinct name and a set of labels that help uniquely identify the pods/VMs of that version."}];

  HttpSettings http_settings = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  HTTP specific settings, transformations and routing rules associated with HTTP traffic to this service."}];

  TcpSettings tcp_settings = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "TCP specific settings, transformations and routing rules associated with non-HTTP traffic to this service."}];
}

enum Registry {
  UNKNOWN = 0;
  KUBERNETES = 1;
  VM = 2;
}

message Port {
  uint32 number = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "A valid non-negative integer port number."}];

  string protocol = 2 [(validate.rules).string = {in: ["HTTP", "GRPC", "HTTP2", "TCP", "TLS", "UDP", "SCTP"]}, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  The protocol exposed on the port. MUST BE one of HTTP|GRPC|HTTP2|HTTPS|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection."}];

  string name = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Name assigned to the port."}];

  uint32 endpoint_port = 4 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "The endpoint port to which this service port maps to. For example, service port 80 exposed on the load balancer could map to an endpoint port 9080 on a VM."}];
}

message Subset {
  string name = 1 [(validate.rules).string.min_len = 1];
  map<string, string> labels = 2 [(validate.rules).map.min_pairs = 1, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Labels apply a filter over the endpoints of a service in the service registry."}];
}


message HttpSettings {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "HTTP settings for a service. Applicable to ports receiving HTTP traffic."
		}
	};
  message HTTPCookie {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "  Describes a HTTP cookie that will be used for sticky sessions. If the cookie is not present, it will be generated."
		}
	};    
    string name = 1 [(validate.rules).string.min_len = 1, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Name of the cookie."}];
    
    string path = 2 [(validate.rules).string.min_len = 1, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Path to set for the cookie."}];

    google.protobuf.Duration ttl = 3 [(validate.rules).message.required = true, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Lifetime of the cookie."}];
  }

  message StickySession {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "If set, the load balancer will route all requests from a particular client to the same backend of the service."
		}
	};

    oneof hash_key {
      string header = 1 [(validate.rules).string.min_len = 1, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Hash based on a specific HTTP header."}];

      
      HTTPCookie cookie = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Hash based on HTTP cookie."}];

      
      bool use_source_ip = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Hash based on the source IP address."}];
    }
  }

  StickySession sticky_session = 1;
  CorsPolicy cors_policy = 2;
  repeated HttpRule route_rules = 3;
}

message TcpSettings {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "TCP settings for a service. Applicable to ports receiving non-HTTP traffic."
		}
	};
  
  Route route = 1 [(validate.rules).message.required = true, (grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "The destination to which the connection should be forwarded to."}];
}


message HttpRule {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "A single HTTP rule"
		}
	};
  
  repeated HttpMatchCondition match = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "one or more match conditions (OR-ed)"}];

  HttpModifyAction modify = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  One or more mutations to be performed before forwarding. Includes typical modifications to be done on a single request like URL rewrite, host rewrite, headers to add/remove/append"}];

  oneof route_or_redirect {
    Route route = 4;
    Redirect redirect = 5;
  }
}


message HttpMatchCondition {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "A single match clause to match all aspects of a request"
		}
	};
  
  StringMatch uri = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "URI to match"}];

  
  StringMatch scheme = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "URI Scheme"}];

  
  StringMatch method = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "HTTP Method"}];

  
  StringMatch authority = 4 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "HTTP Authority"}];

  
  map<string, StringMatch> headers = 5 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id."}];
}


message StringMatch {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "Describes how to match a given string in HTTP headers. Match is case-sensitive."
		}
	};
  oneof match_type {
    
    string exact = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "exact string match"}];

    
    string prefix = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "prefix-based match"}];

    
    string regex = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "ECMAscript style regex-based match"}];
  }
}

message HTTPRewrite {

  string uri = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  Rewrite the path (or the prefix) portion of the URI with this value. If the original URI was matched based on prefix, the value provided in this field will replace the corresponding matched prefix."}];

  
  string authority = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Rewrite the Authority/Host header with this value."}];
}


message Headers {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "Header manipulation rules"
		}
	};

  HeaderOperations request = 1[(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  Header manipulation rules to apply before forwarding a request to the destination service"}];
  
  HeaderOperations response = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Header manipulation rules to apply before returning a response to the caller"}];


  message HeaderOperations {
  option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "  HeaderOperations Describes the header manipulations to apply"
		}
	};

    map<string, string> set = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Overwrite the headers specified by key with the given values"}];

    map<string, string> add = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Append the given values to the headers specified by keys (will create a comma-separated list of values)"}];
    
    repeated string remove = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "Remove a the specified headers"}];
  }
}


message HttpModifyAction {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "HTTP path/url/header modification"
		}
	};
  HTTPRewrite rewrite = 1;
  Headers headers = 2;
}


message Route {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
		json_schema: {
			description: "One or more destinations for the given request"
		}
	};

  message Destination {
    
    string host = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "if omitted, will route to same host as the service"}];
    string subset = 2;
    
    uint32 weight = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "100 if omitted. sum of all weights should add up to 100"}];
   
    uint32 port = 4 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "optional"}];
  }
  repeated Destination destinations = 1 [(validate.rules).repeated.min_items = 1];
}

message Redirect {
  string uri = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "On a redirect, overwrite the Path portion of the URL with this value."}];

  string authority = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "On a redirect, overwrite the Authority/Host portion of the URL with this value."}];
}

message CorsPolicy {
  repeated string allow_origin = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  The list of origins that are allowed to perform CORS requests. The content will be serialized into the Access-Control-Allow-Origin header. Wildcard * will allow all origins."}];

  repeated string allow_methods = 2 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  List of HTTP methods allowed to access the resource. The content will be serialized into the Access-Control-Allow-Methods header."}];

  repeated string allow_headers = 3 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: " List of HTTP headers that can be used when requesting the resource. Serialized to Access-Control-Allow-Headers header."}];

  repeated string expose_headers = 4 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  A white list of HTTP headers that the browsers are allowed to access. Serialized into Access-Control-Expose-Headers header."}];

  google.protobuf.Duration max_age = 5 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  Specifies how long the results of a preflight request can be cached. Translates to the Access-Control-Max-Age header."}];

  google.protobuf.BoolValue allow_credentials = 6 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {description: "  Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials. Translates to Access-Control-Allow-Credentials header."}];
}
