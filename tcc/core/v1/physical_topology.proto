syntax = "proto3";

package tetrate.api.tcc.core.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/core/v1";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "endpoint.proto";
import "service.proto";
import "client_settings.proto";
import "permissions.proto";

// Physical resource hierarchy - clusters, namespaces, services,
// endpoints, and load balancers.  For kubernetes, the namesapce
// creation is performed outside the scope of TCC. For VMs, we allow
// users to create namespaces and move services into those namespaces.
// Load balancers can only expose services that are part of its
// cluster (vm or k8s). We expect an Istio control plane for each
// cluster.
service PhysicalTopology {
  rpc CreateCluster(CreateClusterRequest) returns (Cluster) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{name}"
      body: "*"
    };
  };

  rpc UpdateCluster(UpdateClusterRequest) returns (Cluster) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/clusters/{name}"
      body: "*"
    };
  };

  rpc GetCluster(GetClusterRequest) returns (Cluster) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{name}"
    };
  };

  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters"
    };
  }

  rpc DeleteCluster(DeleteClusterRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/clusters/{name}"
    };
  };

  rpc CreateNamespace(CreateNamespaceRequest) returns (Namespace) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{name}"
      body: "*"
    };
  };

  rpc GetNamespace(GetNamespaceRequest) returns (Namespace) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{name}"
    };
  };

  rpc UpdateNamespace(UpdateNamespaceRequest) returns (Namespace) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{name}"
      body: "*"
    };
  };

  rpc ListNamespaces(ListNamespacesRequest) returns (ListNamespacesResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces"
    };
  }

  rpc DeleteNamespace(DeleteNamespaceRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{name}"
    };
  };

  rpc CreateLoadBalancer(CreateLoadBalancerRequest) returns (LoadBalancer) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/loadbalancers/{name}"
      body: "*"
    };
  };

  rpc GetLoadBalancer(GetLoadBalancerRequest) returns (LoadBalancer) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/loadbalancers/{name}"
    };
  };

  rpc ListLoadBalancers(ListLoadBalancersRequest) returns (ListLoadBalancersResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/loadbalancers"
    };
  };

  rpc UpdateLoadBalancer(UpdateLoadBalancerRequest) returns (LoadBalancer) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/loadbalancers/{name}"
      body: "*"
    };
  };

  rpc DeleteLoadBalancer(DeleteLoadBalancerRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/loadbalancers/{name}"
    };
  };

  rpc CreateService(CreateServiceRequest) returns (Service) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{hostname}"
      body: "*"
    };
  };

  rpc GetService(GetServiceRequest) returns (Service) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{hostname}"
    };
  };

  rpc ListService(ListServiceRequest) returns (ListServiceResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services"
    };
  };

  rpc UpdateService(UpdateServiceRequest) returns (Service) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{hostname}"
      body: "*"
    };
  };

  rpc DeleteService(DeleteServiceRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{hostname}"
    };
  };

  rpc CreateEndpoint(CreateEndpointRequest) returns (Endpoint) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/endpoints/{name}"
      body: "*"
    };
  };

  rpc GetEndpoint(GetEndpointRequest) returns (Endpoint) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/endpoints/{name}"
    };
  };

  rpc ListNamespaceEndpoint(ListNamespaceEndpointRequest) returns (ListEndpointResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/endpoints"
    };
  };

  rpc ListServiceEndpoint(ListServiceEndpointRequest) returns (ListEndpointResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{service}/endpoints"
    };
  };

  rpc ListServiceSubsetEndpoint(ListServiceSubsetEndpointRequest) returns (ListEndpointResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/services/{service}/subsets/{subset}/endpoints"
    };
  };

  rpc UpdateEndpoint(UpdateEndpointRequest) returns (Endpoint) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/endpoints/{name}"
      body: "*"
    };
  };

  rpc DeleteEndpoint(DeleteEndpointRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/clusters/{cluster}/namespaces/{namespace}/endpoints/{name}"
    };
  };

  rpc BatchOperation(BatchOperationRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/clusters/{cluster}/batch"
      body: "*"
    };
  };
}

message Cluster {
  string name = 1;
  string display_name = 2;
  string tenant = 3;
  // currently accepted values are kubernetes or f5
  string registrytype = 4;

  // Information like datacenter where the cluster is present
  map<string, string> attributes = 5;
  
  ClientSettings client_settings = 6;
  Permissions permissions = 7;
}

message CreateClusterRequest {
  string name = 1;
  string display_name = 2;
  string tenant = 3;
  string registrytype = 4;
  map<string, string> attributes = 5;
  ClientSettings client_settings = 6;
  Permissions permissions = 7;
}

message UpdateClusterRequest {
  string name = 1;
  string display_name = 2;
  string tenant = 3;
  string registrytype = 4;
  map<string, string> attributes = 5;
  ClientSettings client_settings = 6;
  Permissions permissions = 7;
}

message GetClusterRequest {
  string name = 1;
  string tenant = 2;
}

message ListClustersRequest {
  string tenant = 1;
}

message ListClustersResponse {
  repeated Cluster clusters = 1;
}

message DeleteClusterRequest {
  string name = 1;
  string tenant = 2;
}


message Namespace {
  string name = 1;
  string cluster = 2;
  string tenant = 3;
  // The services (or namespaces) that endpoints in this namespace
  // depend upon for proper operation. Must be of the form
  // ns1/foo.com, or ns1/. If omitted, its assumed that endpoints in
  // this namespace depend only on other services in the same
  // namespace as the endpoint.
  repeated string dependencies = 4;

  ClientSettings client_settings = 5;
  Permissions permissions = 6;
}

message CreateNamespaceRequest {
  string name = 1;
  string cluster = 2;
  string tenant = 3;
  repeated string dependencies = 4;
  ClientSettings client_settings = 5;
  Permissions permissions = 6;
}

message UpdateNamespaceRequest {
  string name = 1;
  string cluster = 2;
  string tenant = 3;
  repeated string dependencies = 4;
  ClientSettings client_settings = 5;
  Permissions permissions = 6;
}

message GetNamespaceRequest {
  string name = 1;
  string cluster = 2;
  string tenant = 3;
}

message ListNamespacesRequest {
  string cluster = 1;
  string tenant = 2;
}

message ListNamespacesResponse {
  repeated Namespace namespaces = 1;
}

message DeleteNamespaceRequest {
  string name = 1;
  string cluster = 2;
  string tenant = 3;
}

message LoadBalancer {
  string name = 1;
  string namespace = 2;
  string cluster = 3;
  string tenant = 4;
  // f5 or envoy
  LBClass class = 5;

  oneof class_info {
    // If its a hardware load balancer like F5, we need its management
    // IP to talk to it.
    string management_ip = 6;

    // The namespace/hostname of the service in this cluster that implements this load balancer.
    string service_name = 7;
  }

  map<string, string> labels = 8;

  // List of services (in cluster) attached to this loadbalancer in the form
  // namespace/hostname
  repeated string services = 9;
}

message CreateLoadBalancerRequest {
  string name = 1;
  string namespace = 2;
  string cluster = 3;
  string tenant = 4;
  LBClass class = 5;

  oneof class_info {
    string management_ip = 6;
    string service_name = 7;
  }

  map<string, string> labels = 8;
}

message GetLoadBalancerRequest {
  string name = 1;
  string namespace = 2;
  string cluster = 3;
  string tenant = 4;
}

message ListLoadBalancersRequest {
  string namespace = 1;
  string cluster = 2;
  string tenant = 3;
}

message ListLoadBalancersResponse {
  repeated LoadBalancer loadbalancers = 1;
}

message UpdateLoadBalancerRequest {
  string name = 1;
  string namespace = 2;
  string cluster = 3;
  string tenant = 4;
  LBClass class = 5;

  oneof class_info {
    string management_ip = 6;
    string service_name = 7;
  }

  map<string, string> labels = 8;
}

message DeleteLoadBalancerRequest {
  string name = 1;
  string namespace = 2;
  string cluster = 3;
  string tenant = 4;
}

enum LBClass {
  Envoy = 0;
  F5 = 1;
}

// Transactional. If any one operation fails, transaction will be rolled back.
message BatchOperationRequest {
  string tenant = 1;
  string cluster = 2;

  // Tenant and cluster fields in these objects will be ignored.

  repeated CreateNamespaceRequest create_namespaces = 3;
  repeated UpdateNamespaceRequest update_namespaces = 4;
  repeated DeleteNamespaceRequest delete_namespaces = 5;
  repeated CreateLoadBalancerRequest create_loadbalancers = 6;
  repeated UpdateLoadBalancerRequest update_loadbalancers = 7;
  repeated DeleteLoadBalancerRequest delete_loadbalancers = 8;
  repeated CreateServiceRequest create_services = 9;
  repeated UpdateServiceRequest update_services = 10;
  repeated DeleteServiceRequest delete_services = 11;
  repeated CreateEndpointRequest create_endpoints = 12;
  repeated UpdateEndpointRequest update_endpoints = 13;
  repeated DeleteEndpointRequest delete_endpoints = 14;
}
