syntax = "proto3";

package tetrate.api.tcc.core.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/core/v1";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "validate/validate.proto";
import "routing_info.proto";
import "client_settings.proto";
import "tlssettings.proto";

service LogicalResourceModel {
  rpc CreateEnvironment(CreateEnvironmentRequest) returns (Environment) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments"
      body: "*"
    };
  };

  rpc GetEnvironment(GetEnvironmentRequest) returns (Environment) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{id}"
    };
  };

  rpc UpdateEnvironment(Environment) returns (Environment) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{id}"
      body: "*"
    };
  };

  rpc ListEnvironments(ListEnvironmentsRequest) returns (ListEnvironmentsResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments"
    };
  }

  rpc DeleteEnvironment(DeleteEnvironmentRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{id}"
    };
  };

  rpc CreateApplication(CreateApplicationRequest) returns (Application) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments/{environment}/applications"
      body: "*"
    };
  };

  rpc GetApplication(GetApplicationRequest) returns (Application) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
    };
  };

  rpc UpdateApplication(Application) returns (Application) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
      body: "*"
    };
  };

  rpc ListApplications(ListApplicationsRequest) returns (ListApplicationsResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications"
    };
  }

  rpc DeleteApplication(DeleteApplicationRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
    };
  };

  rpc CreateService(CreateServiceRequest) returns (Service) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services"
      body: "*"
    };
  };

  rpc GetService(GetServiceRequest) returns (Service) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
    };
  };

  rpc ListServices(ListServicesRequest) returns (ListServicesResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services"
    };
  };

  rpc UpdateService(Service) returns (Service) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
      body: "*"
    };
  };

  rpc DeleteService(DeleteServiceRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
    };
  };

  rpc CreateLoadBalancer(CreateLoadBalancerRequest) returns (LoadBalancer) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments/{environment}/loadbalancers"
      body: "*"
    };
  };

  rpc GetLoadBalancer(GetLoadBalancerRequest) returns (LoadBalancer) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/loadbalancers/{id}"
    };
  };

  rpc ListLoadBalancers(ListLoadBalancersRequest) returns (ListLoadBalancersResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/loadbalancers"
    };
  };

  rpc UpdateLoadBalancer(LoadBalancer) returns (LoadBalancer) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/loadbalancers/{id}"
      body: "*"
    };
  };

  rpc DeleteLoadBalancer(DeleteLoadBalancerRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{environment}/loadbalancers/{id}"
    };
  };
}

// Environment
//
// Environment is a collection of applications, services, load balancers, and clusters where they are deployed.
message Environment {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // A short name for the environment (e.g,, dev, stage, us-1, etc.).
  string id = 3 [(validate.rules).string.min_len = 1];
  // Additional information for readability.
  string description = 4;
  // Resilience settings that apply to all clusters in the environment.
  ClientSettings client_settings = 5;
}

message CreateEnvironmentRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // If present, this will be used as the id for the created object.
  string id = 3;
  // Additional information for readability.
  string description = 4;
  // Resilience settings that apply to all clusters in the environment.
  ClientSettings client_settings = 5;
}

message GetEnvironmentRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string id = 3 [(validate.rules).string.min_len = 1];
}

message ListEnvironmentsRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
}

message ListEnvironmentsResponse {
  repeated Environment environments = 1;
}

message DeleteEnvironmentRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string id = 3 [(validate.rules).string.min_len = 1];
}

// Application
//
// An Application is a collection of services. Each application corresponds to a kubernetes namespace or an application
// deployment on VMs. The hostname of the application is exposed via the load balancer (either shared or dedicated).
message Application {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // short name for the application. Clusters are expected to have namespaces that match the application Id, especially
  // on Kubernetes.
  string id = 4 [(validate.rules).string.min_len = 1];
  // Additional information.
  string description = 5;
  // Hostname with which the application is exposed on a Gateway.
  string hostname = 6 [(validate.rules).string.min_len = 1];
  // HTTP Routing settings for the applications. Note that subsets should not be defined at application level.
  RoutingInfo routing_info = 7;
  // Resilience settings that apply to all services within the application, for outbound calls from the application's
  // services to other services.
  ClientSettings client_settings = 8;

  message ApplicationSpecificLB {
    // Load balancer deployment labels (Kubernetes only for now). If gateway was created using TCC helm charts, use tcc:
    // appgateway for kubernetes. The gateway will expose the application on ports 80 and 443 (if tls is configured).
    map<string, string> labels = 1 [(validate.rules).map.min_pairs = 1];
    // TLS certificate info for the application. If nil, the gateway will expose the application on port 80 only.
    // Internal use only. Auto populated.
    TLSSettings tls = 2;
  }

  // An application can be exposed on a shared gateway in the cluster or a dedicated gateway in the app's namespace.
  // Set app_lb to indicate that the application should be exposed on the dedicated load balancer deployed in the app
  // namespace. It is assumed that the gateway service is deployed in the app's namespace.
  ApplicationSpecificLB app_lb = 9;
}

message CreateApplicationRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // short name for the application. Clusters are expected to have namespaces that match the application Id, especially
  // on Kubernetes. If present, this will be used as the id for the created object.
  string id = 4;
  // Additional information.
  string description = 5;
  // Hostname with which the application is exposed on a Gateway.
  string hostname = 6 [(validate.rules).string.min_len = 1];
  // HTTP Routing settings for the applications. Note that subsets should not be defined at application level.
  RoutingInfo routing_info = 7;
  // Resilience settings that apply to all services within the application, for outbound calls from the application's
  // services to other services.
  ClientSettings client_settings = 8;

  message ApplicationSpecificLB {
    // Load balancer deployment labels (Kubernetes only for now). If gateway was created using TCC helm charts, use tcc:
    // appgateway for kubernetes. The gateway will expose the application on ports 80 and 443 (if tls is configured).
    map<string, string> labels = 1 [(validate.rules).map.min_pairs = 1];
    // TLS certificate info for the application. If nil, the gateway will expose the application on port 80 only.
    // Internal use only. Auto populated.
    TLSSettings tls = 2;
  }

  // An application can be exposed on a shared gateway in the cluster or a dedicated gateway in the app's namespace. Set
  // app_lb to indicate that the application should be exposed on the dedicated load balancer deployed in the app
  // namespace. It is assumed that the gateway service is deployed in the app's namespace.
  ApplicationSpecificLB app_lb = 9;
}

message GetApplicationRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}

message ListApplicationsRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
}

message ListApplicationsResponse {
  repeated Application applications = 1;
}

message DeleteApplicationRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}

message Service {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // Application.Id.
  string application = 4 [(validate.rules).string.min_len = 1];
  // Short name for the service. Clusters are expected to have namespaces that match the application, and services that
  // match the Id, especially on Kubernetes.
  string id = 5 [(validate.rules).string.min_len = 1];
  string description = 6;
  // FQDN hostname of the service.
  string hostname = 7 [(validate.rules).string.min_len = 1];
  // User identifiable tags associated with this service.
  map<string, string> labels = 8;

  repeated Port ports = 9 ;
  // HTTP Routing settings for the service. Note that subsets (versions of the service) if any should be defined here.
  RoutingInfo routing_info = 10;
  string etag = 11 [(validate.rules).string.min_len = 1];
}

message CreateServiceRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // Application.Id.
  string application = 4 [(validate.rules).string.min_len = 1];
  // If present, this will be used as the id for the created object.
  string id = 5;

  string description = 6;
  // FQDN hostname of the service.
  string hostname = 7 [(validate.rules).string.min_len = 1];
  // User identifiable tags associated with this service.
  map<string, string> labels = 8;

  repeated Port ports = 9 ;
  // HTTP Routing settings for the service. Note that subsets (versions of the service) if any should be defined here.
  RoutingInfo routing_info = 10;
}

message GetServiceRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
  string id = 5 [(validate.rules).string.min_len = 1];
}

message ListServicesRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
}

message ListServicesResponse {
  repeated Service services = 1;
}

message DeleteServiceRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
  string id = 5 [(validate.rules).string.min_len = 1];
}

enum LoadBalancerClass {
  NONE = 0;
  ENVOY = 1;
  F5 = 2;
}

message LoadBalancer {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
  string description = 5;
  bool enable_workflows = 6;

  LoadBalancerClass load_balancer_class = 7 [(validate.rules).enum = {defined_only: true, not_in : [0]}];
  Registry registry = 8 [(validate.rules).enum = {defined_only: true, not_in : [0]}];

  // The namespace where the load balancer is/will be deployed in a given cluster.
  string cluster_namespace = 9 [(validate.rules).string.min_len = 1];

  // Labels that uniquely identify the cluster loadbalancer. If cluster level gateway was deployed using TCC helm
  // charts, set this field to tcc: clustergateway.
  map<string, string> labels = 10 [(validate.rules).map.min_pairs = 1];

  // Map of applications attached to this loadbalancer in the form applicationId: TLS credential information.
  map<string, TLSSettings> applications = 11 [(validate.rules).map.no_sparse = true];

  // Client settings are applicable for traffic from the load balancer's cluster namespace to the application's
  // namespaces.
  ClientSettings client_settings = 12;
  string etag = 13 [(validate.rules).string.min_len = 1];
}

message CreateLoadBalancerRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // If present, this will be used as the id for the created object.
  string id = 4;

  string description = 5;
  bool enable_workflows = 6;

  LoadBalancerClass load_balancer_class = 7 [(validate.rules).enum = {defined_only: true, not_in : [0]}];
  Registry registry = 8 [(validate.rules).enum = {defined_only: true, not_in : [0]}];

  // The namespace where the load balancer is/will be deployed in a given cluster.
  string cluster_namespace = 9 [(validate.rules).string.min_len = 1];

  // Labels that uniquely identify the cluster loadbalancer. If cluster level gateway was deployed using TCC helm
  // charts, set this field to tcc: clustergateway.
  map<string, string> labels = 10 [(validate.rules).map.min_pairs = 1];

  // Map of applications attached to this loadbalancer in the form applicationId: TLS credential information.
  map<string, TLSSettings> applications = 11 [(validate.rules).map.no_sparse = true];

  // Client settings are applicable for traffic from the load balancer's cluster namespace to the application's
  // namespaces.
  ClientSettings client_settings = 12;
}

message GetLoadBalancerRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}

message ListLoadBalancersRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
}

message ListLoadBalancersResponse {
  repeated LoadBalancer loadbalancers = 1;
}

message DeleteLoadBalancerRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}
