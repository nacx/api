// Copyright (c) Tetrate, Inc 2019 All Rights Reserved.

syntax = "proto3";

package tetrate.api.tcc.core.v1;
option go_package = "github.com/tetrateio/tetrate/api/tcc/core/v1";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";

import "routing_info.proto";
import "client_settings.proto";
import "tlssettings.proto";

import "q/rbac/v1/rbac.proto";

service LogicalResourceModel {
  rpc CreateEnvironment(CreateEnvironmentRequest) returns (Environment) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments"
      body: "*"
    };
  };

  rpc GetEnvironment(GetEnvironmentRequest) returns (Environment) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{id}"
    };
  };

  rpc UpdateEnvironment(Environment) returns (Environment) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{id}"
      body: "*"
    };
  };

  rpc ListEnvironments(ListEnvironmentsRequest) returns (ListEnvironmentsResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments"
    };
  }

  rpc DeleteEnvironment(DeleteEnvironmentRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{id}"
    };
  };

  rpc GetEnvironmentPolicy(GetEnvironmentRequest) returns (tetrate.api.q.rbac.v1.Policy) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{id}/policy"
    };
  };

  rpc SetEnvironmentPolicy(EnvironmentPolicyRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{id}/policy"
      body: "policy"
    };
  };

  rpc CreateApplication(CreateApplicationRequest) returns (Application) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments/{environment}/applications"
      body: "*"
    };
  };

  rpc GetApplication(GetApplicationRequest) returns (Application) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
    };
  };

  rpc UpdateApplication(Application) returns (Application) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
      body: "*"
    };
  };

  rpc ListApplications(ListApplicationsRequest) returns (ListApplicationsResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications"
    };
  }

  rpc DeleteApplication(DeleteApplicationRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}"
    };
  };

  rpc GetApplicationPolicy(GetApplicationRequest) returns (tetrate.api.q.rbac.v1.Policy) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}/policy"
    };
  };

  rpc SetApplicationPolicy(ApplicationPolicyRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/applications/{id}/policy"
      body: "policy"
    };
  };

  rpc CreateService(CreateServiceRequest) returns (Service) {
    option (google.api.http) = {
      post: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services"
      body: "*"
    };
  };

  rpc GetService(GetServiceRequest) returns (Service) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
    };
  };

  rpc ListServices(ListServicesRequest) returns (ListServicesResponse) {
    option (google.api.http) = {
      get: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services"
    };
  };

  rpc UpdateService(Service) returns (Service) {
    option (google.api.http) = {
      put: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
      body: "*"
    };
  };

  rpc DeleteService(DeleteServiceRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/tenants/{tenant}/environments/{environment}/applications/{application}/services/{id}"
    };
  };
}

// Environment
//
// Environment is a collection of applications, services, load balancers, and clusters where they are deployed.
message Environment {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // A short name for the environment (e.g,, dev, stage, us-1, etc.).
  string id = 3 [(validate.rules).string.min_len = 1];
  // Additional information for readability.
  string description = 4;
  // Resilience settings that apply to all clusters in the environment.
  ClientSettings client_settings = 5;
}

message CreateEnvironmentRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // If present, this will be used as the id for the created object.
  string id = 3;
  // Additional information for readability.
  string description = 4;
  // Resilience settings that apply to all clusters in the environment.
  ClientSettings client_settings = 5;
}

message GetEnvironmentRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string id = 3 [(validate.rules).string.min_len = 1];
}

message EnvironmentPolicyRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string id = 3 [(validate.rules).string.min_len = 1];
  tetrate.api.q.rbac.v1.Policy policy = 4 [(validate.rules).message.required = true];
}

message ListEnvironmentsRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
}

message ListEnvironmentsResponse {
  repeated Environment environments = 1;
}

message DeleteEnvironmentRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string id = 3 [(validate.rules).string.min_len = 1];
}

// Application
//
// An Application is a collection of services. Each application typically corresponds to one or more kubernetes namespace or an application
// deployment on VMs.
message Application {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // short name for the application.
  string id = 4 [(validate.rules).string.min_len = 1];
  // Additional information.
  string description = 5;
  // Resilience settings that apply to all services within the application, for outbound calls from the application's
  // services to other services in the application or to other applications.
  ClientSettings client_settings = 8;
  // An application can be exposed on a shared load balancer in the cluster or a dedicated load balancer
  // in one of the application's namespaces. Set app_lbs to indicate that the application should be exposed on
  // the dedicated load balancers. Namespace where each of the dedicated load balancer is scoped should be unique.
  repeated ApplicationSpecificLB app_lbs = 9;
  // List of namespaces where the application services (or components) are scoped within. If omitted, the application
  // is assumed to be scoped in a namespace matching the Id field.
  repeated string namespaces = 10;
  // Indicates whether communication between services in the
  // application should use mutual TLS or not. Defaults to true if not
  // specified. Applications with just the app specific LB should set
  // this value to false.
  google.protobuf.BoolValue use_mtls_between_services = 11;
}

message CreateApplicationRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // short name for the application.
  string id = 4;
  // Additional information.
  string description = 5;
  // Resilience settings that apply to all services within the application, for outbound calls from the application's
  // services to other services.
  ClientSettings client_settings = 8;
  // An application can be exposed on a shared load balancer in the cluster or a dedicated load balancer
  // in one of the application's namespaces. Set app_lbs to indicate that the application should be exposed on
  // the dedicated load balancers. Namespace where each of the dedicated load balancer is scoped should be unique.
  repeated ApplicationSpecificLB app_lbs = 9;
  // List of namespaces where the application services (or components) are scoped within. If omitted, the application
  // is assumed to be scoped in a namespace matching the Id field.
  repeated string namespaces = 10;
  // Indicates whether communication between services in the
  // application should use mutual TLS or not. Defaults to true if not
  // specified. Applications with just the app specific LB should set
  // this value to false.
  google.protobuf.BoolValue use_mtls_between_services = 11;
}

message GetApplicationRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}

message ApplicationPolicyRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
  tetrate.api.q.rbac.v1.Policy policy = 5 [(validate.rules).message.required = true];
}

message ListApplicationsRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
}

message ListApplicationsResponse {
  repeated Application applications = 1;
}

message DeleteApplicationRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string id = 4 [(validate.rules).string.min_len = 1];
}

message ApplicationSpecificLB {
  // Load balancer deployment labels (Kubernetes only for now). If gateway was created using TCC helm charts, use app:
  // {namespace}-tcclb for kubernetes. The gateway will expose the application on ports 80 and 443 (if tls is configured).
  map<string, string> labels = 1 [(validate.rules).map.min_pairs = 1];
  // TLS certificate info for the application. If nil, the gateway will expose the application on port 80 only.
  // Internal use only. Auto populated.
  TLSSettings tls = 2;
  // The namespace where this dedicated load balancer of the application is scoped. It should be one of application
  // namespaces. This field cannot be omitted if the application has more than one namespace. If there is only
  // one dedicated load balancer and application has only one  namespace and if this namespace field is omitted,
  // then this field would default to the application namespace.
  string namespace = 3;
  // Hostname with which the application is exposed on this load balancer.
  string hostname = 4 [(validate.rules).string.min_len = 1];
  // HTTP Routing settings for the hostname.
  RoutingInfo routing_info = 5;
  // Indicator whether to use this LB as primary. This is used for Metrics reporting at the App level. If there are
  // multiple dedicated load balancers in an App, only one and mandatorily one has to be marked primary. If there
  // is only one dedicated load balancer in an app, it will be marked as primary by default.
  bool is_primary = 6;
}

message Service {
  // Internal use only. Auto populated field.
  string name = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // Application.Id.
  string application = 4 [(validate.rules).string.min_len = 1];
  // Short name for the service. Clusters are expected to have namespaces that match the application, and services that
  // match the Id, especially on Kubernetes.
  string id = 5 [(validate.rules).string.min_len = 1];
  string description = 6;
  // FQDN hostname of the service.
  string hostname = 7 [(validate.rules).string.min_len = 1];
  // User identifiable tags associated with this service.
  map<string, string> labels = 8;

  repeated Port ports = 9 ;
  // HTTP Routing settings for the service.
  RoutingInfo routing_info = 10;
  string etag = 11 [(validate.rules).string.min_len = 1];
  // Namespace where the service is scoped and should be one of application namespaces. If the application has
  // only one namespace and if this field is omitted, this filed would default to the application namespace.
  // This field cannot be omitted if the application has more than one namespace.
  string namespace = 12;
  // One or more versions of the service. Each version has a distinct
  // name and a set of labels that help uniquely identify the pods/VMs
  // of that version.
  repeated Subset subsets = 13;
  // Internal/external/load balancer service. External services can be
  // created only in the "system" application.  Load balancer services
  // in the "system" application act as shared load balancers for the
  // entire cluster, while those under user created applications act
  // as a dedicated load balancer for that application. Defaults to internal.
  ServiceType service_type = 14;

  oneof routing {
    // allowed only if the service is of type load balancer.
    LBRouteSettings lb_settings = 15;
    // allowed only if the service is of type internal.
    InternalRouteSettings internal_routes = 16;
    // allowed only if the service is of type external.
    ExternalRouteSettings external_routes = 17;
  }
}

message CreateServiceRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  // Tenant.Id.
  string tenant = 2 [(validate.rules).string.min_len = 1];
  // Environment.Id.
  string environment = 3 [(validate.rules).string.min_len = 1];
  // Application.Id.
  string application = 4 [(validate.rules).string.min_len = 1];
  // If present, this will be used as the id for the created object.
  string id = 5;

  string description = 6;
  // FQDN hostname of the service.
  string hostname = 7 [(validate.rules).string.min_len = 1];
  // User identifiable tags associated with this service.
  map<string, string> labels = 8;

  repeated Port ports = 9 ;
  // HTTP Routing settings for the service. Note that subsets (versions of the service) if any should be defined here.
  RoutingInfo routing_info = 10;
  // Namespace where the service is scoped. It should be one of application namespaces. If the application has
  // only one namespace and if this field is omitted, this filed would default to the application namespace.
  // This field cannot be omitted if the application has more than one namespace.
  string namespace = 11;
  // One or more versions of the service. Each version has a distinct
  // name and a set of labels that help uniquely identify the pods/VMs
  // of that version.
  repeated Subset subsets = 12;

  // Internal/external/load balancer service. External services can be
  // created only in the "system" application.  Load balancer services
  // in the "system" application act as shared load balancers for the
  // entire cluster, while those under user created applications act
  // as a dedicated load balancer for that application. Defaults to internal.
  ServiceType service_type = 13;

  oneof routing {
    // allowed only if the service is of type load balancer.
    LBRouteSettings lb_settings = 14;
    // allowed only if the service is of type internal.
    InternalRouteSettings internal_routes = 15;
    // allowed only if the service is of type external.
    ExternalRouteSettings external_routes = 16;
  }  
}

message GetServiceRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
  string id = 5 [(validate.rules).string.min_len = 1];
}

message ListServicesRequest {
  // Internal use only. Auto populated field.
  string parent = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
}

message ListServicesResponse {
  repeated Service services = 1;
}

message DeleteServiceRequest {
  // Internal use only. Auto populated field.
  string name = 1;
  string tenant = 2 [(validate.rules).string.min_len = 1];
  string environment = 3 [(validate.rules).string.min_len = 1];
  string application = 4 [(validate.rules).string.min_len = 1];
  string id = 5 [(validate.rules).string.min_len = 1];
}

// Traffic routing settings for various hostnames exposed at the cluster load balancer.
message ListOfLBRoutingInfo {
  message LBRoutingInfo {
    // Hostname with which the application is exposed on this load balancer.
    string hostname = 1 [(validate.rules).string.min_len = 1];
    // TLS certificate info for the application. If nil, the gateway will expose the application on port 80 only.
    TLSSettings tls = 2;
    // HTTP Routing settings for the hostname. Note that subsets should not be defined at LB hostname level.
    RoutingInfo routing_info = 3;
  };
  repeated LBRoutingInfo lb_settings = 1;
}


