// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: routing_info.proto

package v1

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ServiceType int32

const (
	// An internal service in an application that is not exposed to the outside world.
	ServiceType_INTERNAL ServiceType = 0
	// A load balancer service running only the proxy as the workload. A load balancer service inside
	// an user application forwards traffic to other services in the application. A load balancer
	// service inside the "system" application forwards traffic to services in other user
	// applications.
	ServiceType_LOADBALANCER ServiceType = 1
	// An external service (not in the mesh) accessed by the services in the application.
	ServiceType_EXTERNAL ServiceType = 2
)

var ServiceType_name = map[int32]string{
	0: "INTERNAL",
	1: "LOADBALANCER",
	2: "EXTERNAL",
}

var ServiceType_value = map[string]int32{
	"INTERNAL":     0,
	"LOADBALANCER": 1,
	"EXTERNAL":     2,
}

func (x ServiceType) String() string {
	return proto.EnumName(ServiceType_name, int32(x))
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{0}
}

type LoadBalancerClass int32

const (
	LoadBalancerClass_NONE  LoadBalancerClass = 0
	LoadBalancerClass_ENVOY LoadBalancerClass = 1
	LoadBalancerClass_F5    LoadBalancerClass = 2
)

var LoadBalancerClass_name = map[int32]string{
	0: "NONE",
	1: "ENVOY",
	2: "F5",
}

var LoadBalancerClass_value = map[string]int32{
	"NONE":  0,
	"ENVOY": 1,
	"F5":    2,
}

func (x LoadBalancerClass) String() string {
	return proto.EnumName(LoadBalancerClass_name, int32(x))
}

func (LoadBalancerClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{1}
}

type LoadBalancerTier int32

const (
	LoadBalancerTier_TIER_NOT_SET LoadBalancerTier = 0
	LoadBalancerTier_TIER1        LoadBalancerTier = 1
	LoadBalancerTier_TIER2        LoadBalancerTier = 2
)

var LoadBalancerTier_name = map[int32]string{
	0: "TIER_NOT_SET",
	1: "TIER1",
	2: "TIER2",
}

var LoadBalancerTier_value = map[string]int32{
	"TIER_NOT_SET": 0,
	"TIER1":        1,
	"TIER2":        2,
}

func (x LoadBalancerTier) String() string {
	return proto.EnumName(LoadBalancerTier_name, int32(x))
}

func (LoadBalancerTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{2}
}

type Registry int32

const (
	Registry_UNKNOWN    Registry = 0
	Registry_KUBERNETES Registry = 1
	Registry_VM         Registry = 2
)

var Registry_name = map[int32]string{
	0: "UNKNOWN",
	1: "KUBERNETES",
	2: "VM",
}

var Registry_value = map[string]int32{
	"UNKNOWN":    0,
	"KUBERNETES": 1,
	"VM":         2,
}

func (x Registry) String() string {
	return proto.EnumName(Registry_name, int32(x))
}

func (Registry) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{3}
}

// Available entity options to rate limit by.
type RateLimitSettings_LimitBy int32

const (
	// Limit by IP.
	RateLimitSettings_IP RateLimitSettings_LimitBy = 0
	// Limit by user. Basic auth must be enabled.
	RateLimitSettings_USER RateLimitSettings_LimitBy = 1
	// Limit without any entity. This will count all traffic incoming to the proxy for this
	// LoadBalancer.
	RateLimitSettings_NONE RateLimitSettings_LimitBy = 2
)

var RateLimitSettings_LimitBy_name = map[int32]string{
	0: "IP",
	1: "USER",
	2: "NONE",
}

var RateLimitSettings_LimitBy_value = map[string]int32{
	"IP":   0,
	"USER": 1,
	"NONE": 2,
}

func (x RateLimitSettings_LimitBy) String() string {
	return proto.EnumName(RateLimitSettings_LimitBy_name, int32(x))
}

func (RateLimitSettings_LimitBy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{17, 0}
}

// LBRouteSettings
//
// HTTP/TCP routing settings for application exposed via a load balancer service. Enforced at load
// balancer only.
type LBRouteSettings struct {
	EnableWorkflows   bool              `protobuf:"varint,1,opt,name=enable_workflows,json=enableWorkflows,proto3" json:"enable_workflows,omitempty"`
	LoadBalancerClass LoadBalancerClass `protobuf:"varint,2,opt,name=load_balancer_class,json=loadBalancerClass,proto3,enum=tetrate.api.tcc.core.v1.LoadBalancerClass" json:"load_balancer_class,omitempty"`
	// Current restrictions: Tier1 load balancers can only route to other tier2 load balancers in any
	// cluster (local/remote). They cannot route to internal services in their local clusters. Tier2
	// load balancers can route to internal services in the same cluster only.
	LoadBalancerTier     LoadBalancerTier           `protobuf:"varint,4,opt,name=load_balancer_tier,json=loadBalancerTier,proto3,enum=tetrate.api.tcc.core.v1.LoadBalancerTier" json:"load_balancer_tier,omitempty"`
	Routes               []*LBRouteSettings_LBRoute `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *LBRouteSettings) Reset()         { *m = LBRouteSettings{} }
func (m *LBRouteSettings) String() string { return proto.CompactTextString(m) }
func (*LBRouteSettings) ProtoMessage()    {}
func (*LBRouteSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{0}
}
func (m *LBRouteSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LBRouteSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LBRouteSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LBRouteSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LBRouteSettings.Merge(m, src)
}
func (m *LBRouteSettings) XXX_Size() int {
	return m.Size()
}
func (m *LBRouteSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_LBRouteSettings.DiscardUnknown(m)
}

var xxx_messageInfo_LBRouteSettings proto.InternalMessageInfo

func (m *LBRouteSettings) GetEnableWorkflows() bool {
	if m != nil {
		return m.EnableWorkflows
	}
	return false
}

func (m *LBRouteSettings) GetLoadBalancerClass() LoadBalancerClass {
	if m != nil {
		return m.LoadBalancerClass
	}
	return LoadBalancerClass_NONE
}

func (m *LBRouteSettings) GetLoadBalancerTier() LoadBalancerTier {
	if m != nil {
		return m.LoadBalancerTier
	}
	return LoadBalancerTier_TIER_NOT_SET
}

func (m *LBRouteSettings) GetRoutes() []*LBRouteSettings_LBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type LBRouteSettings_LBRoute struct {
	// Hostname with which the application is exposed on this load balancer.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// TLS certificate info for the application. If nil, the gateway will expose the application on
	// port 80 only.
	Tls *TLSSettings `protobuf:"bytes,2,opt,name=tls,proto3" json:"tls,omitempty"`
	// HTTP specific settings, transformations and routing rules associated with HTTP traffic to
	// this service.
	HttpSettings *HttpSettings `protobuf:"bytes,3,opt,name=http_settings,json=httpSettings,proto3" json:"http_settings,omitempty"`
	// TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
	// this service.
	TcpSettings *TcpSettings `protobuf:"bytes,4,opt,name=tcp_settings,json=tcpSettings,proto3" json:"tcp_settings,omitempty"`
	// One or more auth settings (OR-ed).
	AuthSettings []*LBRouteSettings_LBRoute_AuthSettings `protobuf:"bytes,5,rep,name=auth_settings,json=authSettings,proto3" json:"auth_settings,omitempty"`
	// Rate limit settings.
	RateLimitSettings    *RateLimitSettings `protobuf:"bytes,6,opt,name=rate_limit_settings,json=rateLimitSettings,proto3" json:"rate_limit_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LBRouteSettings_LBRoute) Reset()         { *m = LBRouteSettings_LBRoute{} }
func (m *LBRouteSettings_LBRoute) String() string { return proto.CompactTextString(m) }
func (*LBRouteSettings_LBRoute) ProtoMessage()    {}
func (*LBRouteSettings_LBRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{0, 0}
}
func (m *LBRouteSettings_LBRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LBRouteSettings_LBRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LBRouteSettings_LBRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LBRouteSettings_LBRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LBRouteSettings_LBRoute.Merge(m, src)
}
func (m *LBRouteSettings_LBRoute) XXX_Size() int {
	return m.Size()
}
func (m *LBRouteSettings_LBRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_LBRouteSettings_LBRoute.DiscardUnknown(m)
}

var xxx_messageInfo_LBRouteSettings_LBRoute proto.InternalMessageInfo

func (m *LBRouteSettings_LBRoute) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *LBRouteSettings_LBRoute) GetTls() *TLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *LBRouteSettings_LBRoute) GetHttpSettings() *HttpSettings {
	if m != nil {
		return m.HttpSettings
	}
	return nil
}

func (m *LBRouteSettings_LBRoute) GetTcpSettings() *TcpSettings {
	if m != nil {
		return m.TcpSettings
	}
	return nil
}

func (m *LBRouteSettings_LBRoute) GetAuthSettings() []*LBRouteSettings_LBRoute_AuthSettings {
	if m != nil {
		return m.AuthSettings
	}
	return nil
}

func (m *LBRouteSettings_LBRoute) GetRateLimitSettings() *RateLimitSettings {
	if m != nil {
		return m.RateLimitSettings
	}
	return nil
}

// Available authentication settings.
type LBRouteSettings_LBRoute_AuthSettings struct {
	// Types that are valid to be assigned to Settings:
	//	*LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings
	Settings             isLBRouteSettings_LBRoute_AuthSettings_Settings `protobuf_oneof:"settings"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *LBRouteSettings_LBRoute_AuthSettings) Reset()         { *m = LBRouteSettings_LBRoute_AuthSettings{} }
func (m *LBRouteSettings_LBRoute_AuthSettings) String() string { return proto.CompactTextString(m) }
func (*LBRouteSettings_LBRoute_AuthSettings) ProtoMessage()    {}
func (*LBRouteSettings_LBRoute_AuthSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{0, 0, 0}
}
func (m *LBRouteSettings_LBRoute_AuthSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LBRouteSettings_LBRoute_AuthSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LBRouteSettings_LBRoute_AuthSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LBRouteSettings_LBRoute_AuthSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LBRouteSettings_LBRoute_AuthSettings.Merge(m, src)
}
func (m *LBRouteSettings_LBRoute_AuthSettings) XXX_Size() int {
	return m.Size()
}
func (m *LBRouteSettings_LBRoute_AuthSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_LBRouteSettings_LBRoute_AuthSettings.DiscardUnknown(m)
}

var xxx_messageInfo_LBRouteSettings_LBRoute_AuthSettings proto.InternalMessageInfo

type isLBRouteSettings_LBRoute_AuthSettings_Settings interface {
	isLBRouteSettings_LBRoute_AuthSettings_Settings()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings struct {
	BasicAuthSettings *BasicAuthSettings `protobuf:"bytes,1,opt,name=basic_auth_settings,json=basicAuthSettings,proto3,oneof"`
}

func (*LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings) isLBRouteSettings_LBRoute_AuthSettings_Settings() {
}

func (m *LBRouteSettings_LBRoute_AuthSettings) GetSettings() isLBRouteSettings_LBRoute_AuthSettings_Settings {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *LBRouteSettings_LBRoute_AuthSettings) GetBasicAuthSettings() *BasicAuthSettings {
	if x, ok := m.GetSettings().(*LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings); ok {
		return x.BasicAuthSettings
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LBRouteSettings_LBRoute_AuthSettings) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LBRouteSettings_LBRoute_AuthSettings_OneofMarshaler, _LBRouteSettings_LBRoute_AuthSettings_OneofUnmarshaler, _LBRouteSettings_LBRoute_AuthSettings_OneofSizer, []interface{}{
		(*LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings)(nil),
	}
}

func _LBRouteSettings_LBRoute_AuthSettings_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LBRouteSettings_LBRoute_AuthSettings)
	// settings
	switch x := m.Settings.(type) {
	case *LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BasicAuthSettings); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LBRouteSettings_LBRoute_AuthSettings.Settings has unexpected type %T", x)
	}
	return nil
}

func _LBRouteSettings_LBRoute_AuthSettings_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LBRouteSettings_LBRoute_AuthSettings)
	switch tag {
	case 1: // settings.basic_auth_settings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BasicAuthSettings)
		err := b.DecodeMessage(msg)
		m.Settings = &LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LBRouteSettings_LBRoute_AuthSettings_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LBRouteSettings_LBRoute_AuthSettings)
	// settings
	switch x := m.Settings.(type) {
	case *LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings:
		s := proto.Size(x.BasicAuthSettings)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// InternalRouteSettings
//
// HTTP/TCP routing settings for an internal service in an application. Enforced at the sidecars for
// services inside the same application.
type InternalRouteSettings struct {
	// HTTP specific settings, transformations and routing rules associated with HTTP traffic to this
	// service.
	HttpSettings *HttpSettings `protobuf:"bytes,1,opt,name=http_settings,json=httpSettings,proto3" json:"http_settings,omitempty"`
	// TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
	// this service.
	TcpSettings          *TcpSettings `protobuf:"bytes,2,opt,name=tcp_settings,json=tcpSettings,proto3" json:"tcp_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *InternalRouteSettings) Reset()         { *m = InternalRouteSettings{} }
func (m *InternalRouteSettings) String() string { return proto.CompactTextString(m) }
func (*InternalRouteSettings) ProtoMessage()    {}
func (*InternalRouteSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{1}
}
func (m *InternalRouteSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalRouteSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalRouteSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalRouteSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalRouteSettings.Merge(m, src)
}
func (m *InternalRouteSettings) XXX_Size() int {
	return m.Size()
}
func (m *InternalRouteSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalRouteSettings.DiscardUnknown(m)
}

var xxx_messageInfo_InternalRouteSettings proto.InternalMessageInfo

func (m *InternalRouteSettings) GetHttpSettings() *HttpSettings {
	if m != nil {
		return m.HttpSettings
	}
	return nil
}

func (m *InternalRouteSettings) GetTcpSettings() *TcpSettings {
	if m != nil {
		return m.TcpSettings
	}
	return nil
}

// ExternalRouteSettings
//
// HTTP/TCP routing settings for an external service in the "system" application. Enforced at the
// external facing gateway in the "system" application.
type ExternalRouteSettings struct {
	// TLS certificate info for the external service. If nil, the gateway will communicate with the
	// external service over plain text.
	Tls *TLSSettings `protobuf:"bytes,1,opt,name=tls,proto3" json:"tls,omitempty"`
	// HTTP specific settings, transformations and routing rules associated with HTTP traffic to this
	// service.
	HttpSettings *HttpSettings `protobuf:"bytes,2,opt,name=http_settings,json=httpSettings,proto3" json:"http_settings,omitempty"`
	// TCP specific settings, transformations and routing rules associated with non-HTTP traffic to
	// this service.
	TcpSettings          *TcpSettings `protobuf:"bytes,3,opt,name=tcp_settings,json=tcpSettings,proto3" json:"tcp_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ExternalRouteSettings) Reset()         { *m = ExternalRouteSettings{} }
func (m *ExternalRouteSettings) String() string { return proto.CompactTextString(m) }
func (*ExternalRouteSettings) ProtoMessage()    {}
func (*ExternalRouteSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{2}
}
func (m *ExternalRouteSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalRouteSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalRouteSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalRouteSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalRouteSettings.Merge(m, src)
}
func (m *ExternalRouteSettings) XXX_Size() int {
	return m.Size()
}
func (m *ExternalRouteSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalRouteSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalRouteSettings proto.InternalMessageInfo

func (m *ExternalRouteSettings) GetTls() *TLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *ExternalRouteSettings) GetHttpSettings() *HttpSettings {
	if m != nil {
		return m.HttpSettings
	}
	return nil
}

func (m *ExternalRouteSettings) GetTcpSettings() *TcpSettings {
	if m != nil {
		return m.TcpSettings
	}
	return nil
}

type Port struct {
	// A valid non-negative integer port number.
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// The protocol exposed on the port. MUST BE one of HTTP|GRPC|HTTP2|HTTPS|TCP|TLS.
	//
	// TLS implies the connection will be routed based on the SNI header to the destination without
	// terminating the TLS connection.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Name assigned to the port.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The endpoint port to which this service port maps to. For example, service port 80 exposed on
	// the load balancer could map to an endpoint port 9080 on a VM.
	EndpointPort uint32 `protobuf:"varint,4,opt,name=endpoint_port,json=endpointPort,proto3" json:"endpoint_port,omitempty"`
	// Indicates the node port attached to a physical deployment on a kubernetes cluster.
	KubernetesNodePort uint32 `protobuf:"varint,5,opt,name=kubernetes_node_port,json=kubernetesNodePort,proto3" json:"kubernetes_node_port,omitempty"`
	// In cases where IPtables based capture is not used, the sidecar
	// and the application could be listening on different ports in the
	// same VM. For example, the endpoint_port of 9080 is the port where Envoy listens for inbound
	// traffic and
	// forwards incoming traffic to the the weblogic application server listening on 127.0.0.1:7070
	ApplicationPort      uint32   `protobuf:"varint,6,opt,name=application_port,json=applicationPort,proto3" json:"application_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{3}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Port) GetEndpointPort() uint32 {
	if m != nil {
		return m.EndpointPort
	}
	return 0
}

func (m *Port) GetKubernetesNodePort() uint32 {
	if m != nil {
		return m.KubernetesNodePort
	}
	return 0
}

func (m *Port) GetApplicationPort() uint32 {
	if m != nil {
		return m.ApplicationPort
	}
	return 0
}

type Subset struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Labels apply a filter over the endpoints of a service in the service registry.
	Labels               map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Subset) Reset()         { *m = Subset{} }
func (m *Subset) String() string { return proto.CompactTextString(m) }
func (*Subset) ProtoMessage()    {}
func (*Subset) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{4}
}
func (m *Subset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subset.Merge(m, src)
}
func (m *Subset) XXX_Size() int {
	return m.Size()
}
func (m *Subset) XXX_DiscardUnknown() {
	xxx_messageInfo_Subset.DiscardUnknown(m)
}

var xxx_messageInfo_Subset proto.InternalMessageInfo

func (m *Subset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subset) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// HttpSettings
//
// HTTP settings for a service. Applicable to ports receiving HTTP traffic.
type HttpSettings struct {
	StickySession        *HttpSettings_StickySession `protobuf:"bytes,1,opt,name=sticky_session,json=stickySession,proto3" json:"sticky_session,omitempty"`
	CorsPolicy           *CorsPolicy                 `protobuf:"bytes,2,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	RouteRules           []*HttpRule                 `protobuf:"bytes,3,rep,name=route_rules,json=routeRules,proto3" json:"route_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *HttpSettings) Reset()         { *m = HttpSettings{} }
func (m *HttpSettings) String() string { return proto.CompactTextString(m) }
func (*HttpSettings) ProtoMessage()    {}
func (*HttpSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{5}
}
func (m *HttpSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpSettings.Merge(m, src)
}
func (m *HttpSettings) XXX_Size() int {
	return m.Size()
}
func (m *HttpSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpSettings.DiscardUnknown(m)
}

var xxx_messageInfo_HttpSettings proto.InternalMessageInfo

func (m *HttpSettings) GetStickySession() *HttpSettings_StickySession {
	if m != nil {
		return m.StickySession
	}
	return nil
}

func (m *HttpSettings) GetCorsPolicy() *CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *HttpSettings) GetRouteRules() []*HttpRule {
	if m != nil {
		return m.RouteRules
	}
	return nil
}

// Describes a HTTP cookie that will be used for sticky sessions. If the cookie is not present, it
// will be generated.
type HttpSettings_HTTPCookie struct {
	// Name of the cookie.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Lifetime of the cookie.
	Ttl                  *types.Duration `protobuf:"bytes,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *HttpSettings_HTTPCookie) Reset()         { *m = HttpSettings_HTTPCookie{} }
func (m *HttpSettings_HTTPCookie) String() string { return proto.CompactTextString(m) }
func (*HttpSettings_HTTPCookie) ProtoMessage()    {}
func (*HttpSettings_HTTPCookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{5, 0}
}
func (m *HttpSettings_HTTPCookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpSettings_HTTPCookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpSettings_HTTPCookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpSettings_HTTPCookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpSettings_HTTPCookie.Merge(m, src)
}
func (m *HttpSettings_HTTPCookie) XXX_Size() int {
	return m.Size()
}
func (m *HttpSettings_HTTPCookie) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpSettings_HTTPCookie.DiscardUnknown(m)
}

var xxx_messageInfo_HttpSettings_HTTPCookie proto.InternalMessageInfo

func (m *HttpSettings_HTTPCookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HttpSettings_HTTPCookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HttpSettings_HTTPCookie) GetTtl() *types.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

// If set, the load balancer will route all requests from a particular client to the same backend
// of the service.
type HttpSettings_StickySession struct {
	// Types that are valid to be assigned to HashKey:
	//	*HttpSettings_StickySession_Header
	//	*HttpSettings_StickySession_Cookie
	//	*HttpSettings_StickySession_UseSourceIp
	HashKey              isHttpSettings_StickySession_HashKey `protobuf_oneof:"hash_key"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *HttpSettings_StickySession) Reset()         { *m = HttpSettings_StickySession{} }
func (m *HttpSettings_StickySession) String() string { return proto.CompactTextString(m) }
func (*HttpSettings_StickySession) ProtoMessage()    {}
func (*HttpSettings_StickySession) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{5, 1}
}
func (m *HttpSettings_StickySession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpSettings_StickySession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpSettings_StickySession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpSettings_StickySession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpSettings_StickySession.Merge(m, src)
}
func (m *HttpSettings_StickySession) XXX_Size() int {
	return m.Size()
}
func (m *HttpSettings_StickySession) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpSettings_StickySession.DiscardUnknown(m)
}

var xxx_messageInfo_HttpSettings_StickySession proto.InternalMessageInfo

type isHttpSettings_StickySession_HashKey interface {
	isHttpSettings_StickySession_HashKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpSettings_StickySession_Header struct {
	Header string `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}
type HttpSettings_StickySession_Cookie struct {
	Cookie *HttpSettings_HTTPCookie `protobuf:"bytes,2,opt,name=cookie,proto3,oneof"`
}
type HttpSettings_StickySession_UseSourceIp struct {
	UseSourceIp bool `protobuf:"varint,3,opt,name=use_source_ip,json=useSourceIp,proto3,oneof"`
}

func (*HttpSettings_StickySession_Header) isHttpSettings_StickySession_HashKey()      {}
func (*HttpSettings_StickySession_Cookie) isHttpSettings_StickySession_HashKey()      {}
func (*HttpSettings_StickySession_UseSourceIp) isHttpSettings_StickySession_HashKey() {}

func (m *HttpSettings_StickySession) GetHashKey() isHttpSettings_StickySession_HashKey {
	if m != nil {
		return m.HashKey
	}
	return nil
}

func (m *HttpSettings_StickySession) GetHeader() string {
	if x, ok := m.GetHashKey().(*HttpSettings_StickySession_Header); ok {
		return x.Header
	}
	return ""
}

func (m *HttpSettings_StickySession) GetCookie() *HttpSettings_HTTPCookie {
	if x, ok := m.GetHashKey().(*HttpSettings_StickySession_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *HttpSettings_StickySession) GetUseSourceIp() bool {
	if x, ok := m.GetHashKey().(*HttpSettings_StickySession_UseSourceIp); ok {
		return x.UseSourceIp
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpSettings_StickySession) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpSettings_StickySession_OneofMarshaler, _HttpSettings_StickySession_OneofUnmarshaler, _HttpSettings_StickySession_OneofSizer, []interface{}{
		(*HttpSettings_StickySession_Header)(nil),
		(*HttpSettings_StickySession_Cookie)(nil),
		(*HttpSettings_StickySession_UseSourceIp)(nil),
	}
}

func _HttpSettings_StickySession_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpSettings_StickySession)
	// hash_key
	switch x := m.HashKey.(type) {
	case *HttpSettings_StickySession_Header:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Header)
	case *HttpSettings_StickySession_Cookie:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cookie); err != nil {
			return err
		}
	case *HttpSettings_StickySession_UseSourceIp:
		t := uint64(0)
		if x.UseSourceIp {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("HttpSettings_StickySession.HashKey has unexpected type %T", x)
	}
	return nil
}

func _HttpSettings_StickySession_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpSettings_StickySession)
	switch tag {
	case 1: // hash_key.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HashKey = &HttpSettings_StickySession_Header{x}
		return true, err
	case 2: // hash_key.cookie
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpSettings_HTTPCookie)
		err := b.DecodeMessage(msg)
		m.HashKey = &HttpSettings_StickySession_Cookie{msg}
		return true, err
	case 3: // hash_key.use_source_ip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.HashKey = &HttpSettings_StickySession_UseSourceIp{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _HttpSettings_StickySession_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpSettings_StickySession)
	// hash_key
	switch x := m.HashKey.(type) {
	case *HttpSettings_StickySession_Header:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Header)))
		n += len(x.Header)
	case *HttpSettings_StickySession_Cookie:
		s := proto.Size(x.Cookie)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpSettings_StickySession_UseSourceIp:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TCP settings for a service. Applicable to ports receiving non-HTTP traffic.
type TcpSettings struct {
	// The destination to which the connection should be routed.
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpSettings) Reset()         { *m = TcpSettings{} }
func (m *TcpSettings) String() string { return proto.CompactTextString(m) }
func (*TcpSettings) ProtoMessage()    {}
func (*TcpSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{6}
}
func (m *TcpSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpSettings.Merge(m, src)
}
func (m *TcpSettings) XXX_Size() int {
	return m.Size()
}
func (m *TcpSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TcpSettings proto.InternalMessageInfo

func (m *TcpSettings) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

// A single HTTP rule.
type HttpRule struct {
	// One or more match conditions (OR-ed).
	Match []*HttpMatchCondition `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// One or more mutations to be performed before forwarding. Includes typical modifications to be
	// done on a single request like URL rewrite, host rewrite, headers to add/remove/append.
	Modify *HttpModifyAction `protobuf:"bytes,2,opt,name=modify,proto3" json:"modify,omitempty"`
	// Types that are valid to be assigned to RouteOrRedirect:
	//	*HttpRule_Route
	//	*HttpRule_Redirect
	RouteOrRedirect      isHttpRule_RouteOrRedirect `protobuf_oneof:"route_or_redirect"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *HttpRule) Reset()         { *m = HttpRule{} }
func (m *HttpRule) String() string { return proto.CompactTextString(m) }
func (*HttpRule) ProtoMessage()    {}
func (*HttpRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{7}
}
func (m *HttpRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpRule.Merge(m, src)
}
func (m *HttpRule) XXX_Size() int {
	return m.Size()
}
func (m *HttpRule) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpRule.DiscardUnknown(m)
}

var xxx_messageInfo_HttpRule proto.InternalMessageInfo

type isHttpRule_RouteOrRedirect interface {
	isHttpRule_RouteOrRedirect()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpRule_Route struct {
	Route *Route `protobuf:"bytes,4,opt,name=route,proto3,oneof"`
}
type HttpRule_Redirect struct {
	Redirect *Redirect `protobuf:"bytes,5,opt,name=redirect,proto3,oneof"`
}

func (*HttpRule_Route) isHttpRule_RouteOrRedirect()    {}
func (*HttpRule_Redirect) isHttpRule_RouteOrRedirect() {}

func (m *HttpRule) GetRouteOrRedirect() isHttpRule_RouteOrRedirect {
	if m != nil {
		return m.RouteOrRedirect
	}
	return nil
}

func (m *HttpRule) GetMatch() []*HttpMatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HttpRule) GetModify() *HttpModifyAction {
	if m != nil {
		return m.Modify
	}
	return nil
}

func (m *HttpRule) GetRoute() *Route {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Route); ok {
		return x.Route
	}
	return nil
}

func (m *HttpRule) GetRedirect() *Redirect {
	if x, ok := m.GetRouteOrRedirect().(*HttpRule_Redirect); ok {
		return x.Redirect
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpRule_OneofMarshaler, _HttpRule_OneofUnmarshaler, _HttpRule_OneofSizer, []interface{}{
		(*HttpRule_Route)(nil),
		(*HttpRule_Redirect)(nil),
	}
}

func _HttpRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpRule)
	// route_or_redirect
	switch x := m.RouteOrRedirect.(type) {
	case *HttpRule_Route:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case *HttpRule_Redirect:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Redirect); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpRule.RouteOrRedirect has unexpected type %T", x)
	}
	return nil
}

func _HttpRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpRule)
	switch tag {
	case 4: // route_or_redirect.route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Route)
		err := b.DecodeMessage(msg)
		m.RouteOrRedirect = &HttpRule_Route{msg}
		return true, err
	case 5: // route_or_redirect.redirect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Redirect)
		err := b.DecodeMessage(msg)
		m.RouteOrRedirect = &HttpRule_Redirect{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpRule)
	// route_or_redirect
	switch x := m.RouteOrRedirect.(type) {
	case *HttpRule_Route:
		s := proto.Size(x.Route)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpRule_Redirect:
		s := proto.Size(x.Redirect)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A single match clause to match all aspects of a request.
type HttpMatchCondition struct {
	// URI to match.
	Uri *StringMatch `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// URI Scheme
	Scheme *StringMatch `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// HTTP Method.
	Method *StringMatch `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	// HTTP Authority.
	Authority *StringMatch `protobuf:"bytes,4,opt,name=authority,proto3" json:"authority,omitempty"`
	// The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id.
	Headers              map[string]*StringMatch `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HttpMatchCondition) Reset()         { *m = HttpMatchCondition{} }
func (m *HttpMatchCondition) String() string { return proto.CompactTextString(m) }
func (*HttpMatchCondition) ProtoMessage()    {}
func (*HttpMatchCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{8}
}
func (m *HttpMatchCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpMatchCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpMatchCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpMatchCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMatchCondition.Merge(m, src)
}
func (m *HttpMatchCondition) XXX_Size() int {
	return m.Size()
}
func (m *HttpMatchCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMatchCondition.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMatchCondition proto.InternalMessageInfo

func (m *HttpMatchCondition) GetUri() *StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func (m *HttpMatchCondition) GetScheme() *StringMatch {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *HttpMatchCondition) GetMethod() *StringMatch {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *HttpMatchCondition) GetAuthority() *StringMatch {
	if m != nil {
		return m.Authority
	}
	return nil
}

func (m *HttpMatchCondition) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Describes how to match a given string in HTTP headers. Match is case-sensitive.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StringMatch) Reset()         { *m = StringMatch{} }
func (m *StringMatch) String() string { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()    {}
func (*StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{9}
}
func (m *StringMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatch.Merge(m, src)
}
func (m *StringMatch) XXX_Size() int {
	return m.Size()
}
func (m *StringMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatch.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatch proto.InternalMessageInfo

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringMatch_OneofMarshaler, _StringMatch_OneofUnmarshaler, _StringMatch_OneofSizer, []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

func _StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Exact)
	case *StringMatch_Prefix:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Prefix)
	case *StringMatch_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("StringMatch.MatchType has unexpected type %T", x)
	}
	return nil
}

func _StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringMatch)
	switch tag {
	case 1: // match_type.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Exact{x}
		return true, err
	case 2: // match_type.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Prefix{x}
		return true, err
	case 3: // match_type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *StringMatch_Prefix:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *StringMatch_Regex:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HTTPRewrite struct {
	// Rewrite the path (or the prefix) portion of the URI with this value. If the original URI was
	// matched based on prefix, the value provided in this field will replace the corresponding
	// matched prefix.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// Rewrite the Authority/Host header with this value.
	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPRewrite) Reset()         { *m = HTTPRewrite{} }
func (m *HTTPRewrite) String() string { return proto.CompactTextString(m) }
func (*HTTPRewrite) ProtoMessage()    {}
func (*HTTPRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{10}
}
func (m *HTTPRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPRewrite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPRewrite.Merge(m, src)
}
func (m *HTTPRewrite) XXX_Size() int {
	return m.Size()
}
func (m *HTTPRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPRewrite proto.InternalMessageInfo

func (m *HTTPRewrite) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *HTTPRewrite) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

// Header manipulation rules.
type Headers struct {
	// Header manipulation rules to apply before forwarding a request to the destination service.
	Request *Headers_HeaderOperations `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// Header manipulation rules to apply before returning a response to the caller.
	Response             *Headers_HeaderOperations `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Headers) Reset()         { *m = Headers{} }
func (m *Headers) String() string { return proto.CompactTextString(m) }
func (*Headers) ProtoMessage()    {}
func (*Headers) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{11}
}
func (m *Headers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Headers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Headers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Headers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Headers.Merge(m, src)
}
func (m *Headers) XXX_Size() int {
	return m.Size()
}
func (m *Headers) XXX_DiscardUnknown() {
	xxx_messageInfo_Headers.DiscardUnknown(m)
}

var xxx_messageInfo_Headers proto.InternalMessageInfo

func (m *Headers) GetRequest() *Headers_HeaderOperations {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Headers) GetResponse() *Headers_HeaderOperations {
	if m != nil {
		return m.Response
	}
	return nil
}

// HeaderOperations Describes the header manipulations to apply.
type Headers_HeaderOperations struct {
	// Overwrite the headers specified by key with the given values.
	Set map[string]string `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Append the given values to the headers specified by keys (will create a comma-separated list
	// of values).
	Add map[string]string `protobuf:"bytes,2,rep,name=add,proto3" json:"add,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Remove a the specified headers.
	Remove               []string `protobuf:"bytes,3,rep,name=remove,proto3" json:"remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Headers_HeaderOperations) Reset()         { *m = Headers_HeaderOperations{} }
func (m *Headers_HeaderOperations) String() string { return proto.CompactTextString(m) }
func (*Headers_HeaderOperations) ProtoMessage()    {}
func (*Headers_HeaderOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{11, 0}
}
func (m *Headers_HeaderOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Headers_HeaderOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Headers_HeaderOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Headers_HeaderOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Headers_HeaderOperations.Merge(m, src)
}
func (m *Headers_HeaderOperations) XXX_Size() int {
	return m.Size()
}
func (m *Headers_HeaderOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_Headers_HeaderOperations.DiscardUnknown(m)
}

var xxx_messageInfo_Headers_HeaderOperations proto.InternalMessageInfo

func (m *Headers_HeaderOperations) GetSet() map[string]string {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Headers_HeaderOperations) GetAdd() map[string]string {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *Headers_HeaderOperations) GetRemove() []string {
	if m != nil {
		return m.Remove
	}
	return nil
}

// HTTP path/url/header modification.
type HttpModifyAction struct {
	Rewrite              *HTTPRewrite `protobuf:"bytes,1,opt,name=rewrite,proto3" json:"rewrite,omitempty"`
	Headers              *Headers     `protobuf:"bytes,2,opt,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HttpModifyAction) Reset()         { *m = HttpModifyAction{} }
func (m *HttpModifyAction) String() string { return proto.CompactTextString(m) }
func (*HttpModifyAction) ProtoMessage()    {}
func (*HttpModifyAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{12}
}
func (m *HttpModifyAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpModifyAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpModifyAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpModifyAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpModifyAction.Merge(m, src)
}
func (m *HttpModifyAction) XXX_Size() int {
	return m.Size()
}
func (m *HttpModifyAction) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpModifyAction.DiscardUnknown(m)
}

var xxx_messageInfo_HttpModifyAction proto.InternalMessageInfo

func (m *HttpModifyAction) GetRewrite() *HTTPRewrite {
	if m != nil {
		return m.Rewrite
	}
	return nil
}

func (m *HttpModifyAction) GetHeaders() *Headers {
	if m != nil {
		return m.Headers
	}
	return nil
}

// One or more destinations in a local cluster for the given request.
type Route struct {
	// All destinations within a route must be of the same type.
	Destinations         []*Route_Destination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{13}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetDestinations() []*Route_Destination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// A destination local to the cluster where the load balancer or sidecar is present.
type Route_LocalDestination struct {
	// If omitted, will route to same application as the service. The application field is used by
	// load balancers in the system application to route to other applications.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// If omitted, will route to the service owning this route.  When used with a Load Balancer
	// (shared or dedicated), traffic can be routed to another service in the same application or a
	// different application.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// If omitted, will route to same host as the service.
	Host                 string   `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"` // Deprecated: Do not use.
	Subset               string   `protobuf:"bytes,4,opt,name=subset,proto3" json:"subset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route_LocalDestination) Reset()         { *m = Route_LocalDestination{} }
func (m *Route_LocalDestination) String() string { return proto.CompactTextString(m) }
func (*Route_LocalDestination) ProtoMessage()    {}
func (*Route_LocalDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{13, 0}
}
func (m *Route_LocalDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route_LocalDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route_LocalDestination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route_LocalDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route_LocalDestination.Merge(m, src)
}
func (m *Route_LocalDestination) XXX_Size() int {
	return m.Size()
}
func (m *Route_LocalDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_Route_LocalDestination.DiscardUnknown(m)
}

var xxx_messageInfo_Route_LocalDestination proto.InternalMessageInfo

func (m *Route_LocalDestination) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *Route_LocalDestination) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

// Deprecated: Do not use.
func (m *Route_LocalDestination) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Route_LocalDestination) GetSubset() string {
	if m != nil {
		return m.Subset
	}
	return ""
}

// A destination load balancer service in another cluster. This destination type is applicable
// only when used with a load balancer service.
type Route_RemoteDestination struct {
	// If omitted, defaults to system application.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// The load balancer service to route the traffic to.
	Service              string   `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route_RemoteDestination) Reset()         { *m = Route_RemoteDestination{} }
func (m *Route_RemoteDestination) String() string { return proto.CompactTextString(m) }
func (*Route_RemoteDestination) ProtoMessage()    {}
func (*Route_RemoteDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{13, 1}
}
func (m *Route_RemoteDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route_RemoteDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route_RemoteDestination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route_RemoteDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route_RemoteDestination.Merge(m, src)
}
func (m *Route_RemoteDestination) XXX_Size() int {
	return m.Size()
}
func (m *Route_RemoteDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_Route_RemoteDestination.DiscardUnknown(m)
}

var xxx_messageInfo_Route_RemoteDestination proto.InternalMessageInfo

func (m *Route_RemoteDestination) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *Route_RemoteDestination) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

type Route_Destination struct {
	// Types that are valid to be assigned to Target:
	//	*Route_Destination_Local
	//	*Route_Destination_Remote
	//	*Route_Destination_Address
	Target isRoute_Destination_Target `protobuf_oneof:"target"`
	// The value of weight is 100 if omitted. The sum of all weights should add up to 100.
	Weight uint32 `protobuf:"varint,4,opt,name=weight,proto3" json:"weight,omitempty"`
	// Optional.
	Port                 uint32   `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route_Destination) Reset()         { *m = Route_Destination{} }
func (m *Route_Destination) String() string { return proto.CompactTextString(m) }
func (*Route_Destination) ProtoMessage()    {}
func (*Route_Destination) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{13, 2}
}
func (m *Route_Destination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route_Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route_Destination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route_Destination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route_Destination.Merge(m, src)
}
func (m *Route_Destination) XXX_Size() int {
	return m.Size()
}
func (m *Route_Destination) XXX_DiscardUnknown() {
	xxx_messageInfo_Route_Destination.DiscardUnknown(m)
}

var xxx_messageInfo_Route_Destination proto.InternalMessageInfo

type isRoute_Destination_Target interface {
	isRoute_Destination_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Route_Destination_Local struct {
	Local *Route_LocalDestination `protobuf:"bytes,1,opt,name=local,proto3,oneof"`
}
type Route_Destination_Remote struct {
	Remote *Route_RemoteDestination `protobuf:"bytes,2,opt,name=remote,proto3,oneof"`
}
type Route_Destination_Address struct {
	Address string `protobuf:"bytes,3,opt,name=address,proto3,oneof"`
}

func (*Route_Destination_Local) isRoute_Destination_Target()   {}
func (*Route_Destination_Remote) isRoute_Destination_Target()  {}
func (*Route_Destination_Address) isRoute_Destination_Target() {}

func (m *Route_Destination) GetTarget() isRoute_Destination_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Route_Destination) GetLocal() *Route_LocalDestination {
	if x, ok := m.GetTarget().(*Route_Destination_Local); ok {
		return x.Local
	}
	return nil
}

func (m *Route_Destination) GetRemote() *Route_RemoteDestination {
	if x, ok := m.GetTarget().(*Route_Destination_Remote); ok {
		return x.Remote
	}
	return nil
}

func (m *Route_Destination) GetAddress() string {
	if x, ok := m.GetTarget().(*Route_Destination_Address); ok {
		return x.Address
	}
	return ""
}

func (m *Route_Destination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Route_Destination) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Route_Destination) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Route_Destination_OneofMarshaler, _Route_Destination_OneofUnmarshaler, _Route_Destination_OneofSizer, []interface{}{
		(*Route_Destination_Local)(nil),
		(*Route_Destination_Remote)(nil),
		(*Route_Destination_Address)(nil),
	}
}

func _Route_Destination_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Route_Destination)
	// target
	switch x := m.Target.(type) {
	case *Route_Destination_Local:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Local); err != nil {
			return err
		}
	case *Route_Destination_Remote:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Remote); err != nil {
			return err
		}
	case *Route_Destination_Address:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Address)
	case nil:
	default:
		return fmt.Errorf("Route_Destination.Target has unexpected type %T", x)
	}
	return nil
}

func _Route_Destination_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Route_Destination)
	switch tag {
	case 1: // target.local
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Route_LocalDestination)
		err := b.DecodeMessage(msg)
		m.Target = &Route_Destination_Local{msg}
		return true, err
	case 2: // target.remote
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Route_RemoteDestination)
		err := b.DecodeMessage(msg)
		m.Target = &Route_Destination_Remote{msg}
		return true, err
	case 3: // target.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Target = &Route_Destination_Address{x}
		return true, err
	default:
		return false, nil
	}
}

func _Route_Destination_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Route_Destination)
	// target
	switch x := m.Target.(type) {
	case *Route_Destination_Local:
		s := proto.Size(x.Local)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_Destination_Remote:
		s := proto.Size(x.Remote)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_Destination_Address:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Address)))
		n += len(x.Address)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Redirect struct {
	// On a redirect, overwrite the Path portion of the URL with this value.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// On a redirect, overwrite the Authority/Host portion of the URL with this value.
	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redirect) Reset()         { *m = Redirect{} }
func (m *Redirect) String() string { return proto.CompactTextString(m) }
func (*Redirect) ProtoMessage()    {}
func (*Redirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{14}
}
func (m *Redirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Redirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Redirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Redirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redirect.Merge(m, src)
}
func (m *Redirect) XXX_Size() int {
	return m.Size()
}
func (m *Redirect) XXX_DiscardUnknown() {
	xxx_messageInfo_Redirect.DiscardUnknown(m)
}

var xxx_messageInfo_Redirect proto.InternalMessageInfo

func (m *Redirect) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Redirect) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

type CorsPolicy struct {
	// The list of origins that are allowed to perform CORS requests. The content will be serialized
	// into the Access-Control-Allow-Origin header. Wildcard * will allow all origins.
	AllowOrigin []string `protobuf:"bytes,1,rep,name=allow_origin,json=allowOrigin,proto3" json:"allow_origin,omitempty"`
	// List of HTTP methods allowed to access the resource. The content will be serialized into the
	// Access-Control-Allow-Methods header.
	AllowMethods []string `protobuf:"bytes,2,rep,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// List of HTTP headers that can be used when requesting the resource. Serialized to
	// Access-Control-Allow-Headers header.
	AllowHeaders []string `protobuf:"bytes,3,rep,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// A white list of HTTP headers that the browsers are allowed to access. Serialized into
	// Access-Control-Expose-Headers header.
	ExposeHeaders []string `protobuf:"bytes,4,rep,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// Specifies how long the results of a preflight request can be cached. Translates to the
	// Access-Control-Max-Age header.
	MaxAge *types.Duration `protobuf:"bytes,5,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// Indicates whether the caller is allowed to send the actual request (not the preflight) using
	// credentials. Translates to Access-Control-Allow-Credentials header.
	AllowCredentials     *types.BoolValue `protobuf:"bytes,6,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CorsPolicy) Reset()         { *m = CorsPolicy{} }
func (m *CorsPolicy) String() string { return proto.CompactTextString(m) }
func (*CorsPolicy) ProtoMessage()    {}
func (*CorsPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{15}
}
func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorsPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorsPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorsPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorsPolicy.Merge(m, src)
}
func (m *CorsPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CorsPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CorsPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CorsPolicy proto.InternalMessageInfo

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() []string {
	if m != nil {
		return m.AllowMethods
	}
	return nil
}

func (m *CorsPolicy) GetAllowHeaders() []string {
	if m != nil {
		return m.AllowHeaders
	}
	return nil
}

func (m *CorsPolicy) GetExposeHeaders() []string {
	if m != nil {
		return m.ExposeHeaders
	}
	return nil
}

func (m *CorsPolicy) GetMaxAge() *types.Duration {
	if m != nil {
		return m.MaxAge
	}
	return nil
}

func (m *CorsPolicy) GetAllowCredentials() *types.BoolValue {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

type BasicAuthSettings struct {
	// Realm value for WWW-Authenticate header. If empty, will be set to LoadBalancer's hostname.
	Realm string `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty"`
	// Charset value for WWW-Authenticate header. If empty, will be set to "UTF-8".
	Charset string `protobuf:"bytes,2,opt,name=charset,proto3" json:"charset,omitempty"`
	// List of basic auth users.
	Users                []*BasicAuthSettings_User `protobuf:"bytes,3,rep,name=users,proto3" json:"users,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *BasicAuthSettings) Reset()         { *m = BasicAuthSettings{} }
func (m *BasicAuthSettings) String() string { return proto.CompactTextString(m) }
func (*BasicAuthSettings) ProtoMessage()    {}
func (*BasicAuthSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{16}
}
func (m *BasicAuthSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAuthSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicAuthSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicAuthSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuthSettings.Merge(m, src)
}
func (m *BasicAuthSettings) XXX_Size() int {
	return m.Size()
}
func (m *BasicAuthSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuthSettings.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuthSettings proto.InternalMessageInfo

func (m *BasicAuthSettings) GetRealm() string {
	if m != nil {
		return m.Realm
	}
	return ""
}

func (m *BasicAuthSettings) GetCharset() string {
	if m != nil {
		return m.Charset
	}
	return ""
}

func (m *BasicAuthSettings) GetUsers() []*BasicAuthSettings_User {
	if m != nil {
		return m.Users
	}
	return nil
}

type BasicAuthSettings_User struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicAuthSettings_User) Reset()         { *m = BasicAuthSettings_User{} }
func (m *BasicAuthSettings_User) String() string { return proto.CompactTextString(m) }
func (*BasicAuthSettings_User) ProtoMessage()    {}
func (*BasicAuthSettings_User) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{16, 0}
}
func (m *BasicAuthSettings_User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAuthSettings_User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicAuthSettings_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicAuthSettings_User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuthSettings_User.Merge(m, src)
}
func (m *BasicAuthSettings_User) XXX_Size() int {
	return m.Size()
}
func (m *BasicAuthSettings_User) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuthSettings_User.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuthSettings_User proto.InternalMessageInfo

func (m *BasicAuthSettings_User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *BasicAuthSettings_User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type RateLimitSettings struct {
	// The number of requests limit per time interval.
	RequestsLimit uint32 `protobuf:"varint,1,opt,name=requests_limit,json=requestsLimit,proto3" json:"requests_limit,omitempty"`
	// Interval for requests within limit.
	Interval *types.Duration `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
	// Limit by entity. Defaults to IP.
	LimitBy              RateLimitSettings_LimitBy `protobuf:"varint,3,opt,name=limit_by,json=limitBy,proto3,enum=tetrate.api.tcc.core.v1.RateLimitSettings_LimitBy" json:"limit_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *RateLimitSettings) Reset()         { *m = RateLimitSettings{} }
func (m *RateLimitSettings) String() string { return proto.CompactTextString(m) }
func (*RateLimitSettings) ProtoMessage()    {}
func (*RateLimitSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca47932996035b4b, []int{17}
}
func (m *RateLimitSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitSettings.Merge(m, src)
}
func (m *RateLimitSettings) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitSettings.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitSettings proto.InternalMessageInfo

func (m *RateLimitSettings) GetRequestsLimit() uint32 {
	if m != nil {
		return m.RequestsLimit
	}
	return 0
}

func (m *RateLimitSettings) GetInterval() *types.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *RateLimitSettings) GetLimitBy() RateLimitSettings_LimitBy {
	if m != nil {
		return m.LimitBy
	}
	return RateLimitSettings_IP
}

func init() {
	proto.RegisterEnum("tetrate.api.tcc.core.v1.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterEnum("tetrate.api.tcc.core.v1.LoadBalancerClass", LoadBalancerClass_name, LoadBalancerClass_value)
	proto.RegisterEnum("tetrate.api.tcc.core.v1.LoadBalancerTier", LoadBalancerTier_name, LoadBalancerTier_value)
	proto.RegisterEnum("tetrate.api.tcc.core.v1.Registry", Registry_name, Registry_value)
	proto.RegisterEnum("tetrate.api.tcc.core.v1.RateLimitSettings_LimitBy", RateLimitSettings_LimitBy_name, RateLimitSettings_LimitBy_value)
	proto.RegisterType((*LBRouteSettings)(nil), "tetrate.api.tcc.core.v1.LBRouteSettings")
	proto.RegisterType((*LBRouteSettings_LBRoute)(nil), "tetrate.api.tcc.core.v1.LBRouteSettings.LBRoute")
	proto.RegisterType((*LBRouteSettings_LBRoute_AuthSettings)(nil), "tetrate.api.tcc.core.v1.LBRouteSettings.LBRoute.AuthSettings")
	proto.RegisterType((*InternalRouteSettings)(nil), "tetrate.api.tcc.core.v1.InternalRouteSettings")
	proto.RegisterType((*ExternalRouteSettings)(nil), "tetrate.api.tcc.core.v1.ExternalRouteSettings")
	proto.RegisterType((*Port)(nil), "tetrate.api.tcc.core.v1.Port")
	proto.RegisterType((*Subset)(nil), "tetrate.api.tcc.core.v1.Subset")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.tcc.core.v1.Subset.LabelsEntry")
	proto.RegisterType((*HttpSettings)(nil), "tetrate.api.tcc.core.v1.HttpSettings")
	proto.RegisterType((*HttpSettings_HTTPCookie)(nil), "tetrate.api.tcc.core.v1.HttpSettings.HTTPCookie")
	proto.RegisterType((*HttpSettings_StickySession)(nil), "tetrate.api.tcc.core.v1.HttpSettings.StickySession")
	proto.RegisterType((*TcpSettings)(nil), "tetrate.api.tcc.core.v1.TcpSettings")
	proto.RegisterType((*HttpRule)(nil), "tetrate.api.tcc.core.v1.HttpRule")
	proto.RegisterType((*HttpMatchCondition)(nil), "tetrate.api.tcc.core.v1.HttpMatchCondition")
	proto.RegisterMapType((map[string]*StringMatch)(nil), "tetrate.api.tcc.core.v1.HttpMatchCondition.HeadersEntry")
	proto.RegisterType((*StringMatch)(nil), "tetrate.api.tcc.core.v1.StringMatch")
	proto.RegisterType((*HTTPRewrite)(nil), "tetrate.api.tcc.core.v1.HTTPRewrite")
	proto.RegisterType((*Headers)(nil), "tetrate.api.tcc.core.v1.Headers")
	proto.RegisterType((*Headers_HeaderOperations)(nil), "tetrate.api.tcc.core.v1.Headers.HeaderOperations")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.tcc.core.v1.Headers.HeaderOperations.AddEntry")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.tcc.core.v1.Headers.HeaderOperations.SetEntry")
	proto.RegisterType((*HttpModifyAction)(nil), "tetrate.api.tcc.core.v1.HttpModifyAction")
	proto.RegisterType((*Route)(nil), "tetrate.api.tcc.core.v1.Route")
	proto.RegisterType((*Route_LocalDestination)(nil), "tetrate.api.tcc.core.v1.Route.LocalDestination")
	proto.RegisterType((*Route_RemoteDestination)(nil), "tetrate.api.tcc.core.v1.Route.RemoteDestination")
	proto.RegisterType((*Route_Destination)(nil), "tetrate.api.tcc.core.v1.Route.Destination")
	proto.RegisterType((*Redirect)(nil), "tetrate.api.tcc.core.v1.Redirect")
	proto.RegisterType((*CorsPolicy)(nil), "tetrate.api.tcc.core.v1.CorsPolicy")
	proto.RegisterType((*BasicAuthSettings)(nil), "tetrate.api.tcc.core.v1.BasicAuthSettings")
	proto.RegisterType((*BasicAuthSettings_User)(nil), "tetrate.api.tcc.core.v1.BasicAuthSettings.User")
	proto.RegisterType((*RateLimitSettings)(nil), "tetrate.api.tcc.core.v1.RateLimitSettings")
}

func init() { proto.RegisterFile("routing_info.proto", fileDescriptor_ca47932996035b4b) }

var fileDescriptor_ca47932996035b4b = []byte{
	// 2091 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6f, 0x5b, 0x49,
	0x15, 0xcf, 0xf5, 0x77, 0x8e, 0x9d, 0xf6, 0x66, 0xba, 0xdb, 0x0d, 0x16, 0x5b, 0x65, 0xdd, 0xad,
	0xd4, 0x06, 0x64, 0xb7, 0x59, 0x6d, 0x59, 0x02, 0xbb, 0x10, 0xa7, 0xa6, 0xe9, 0xd6, 0x75, 0xa2,
	0xb1, 0xdb, 0x42, 0x85, 0x64, 0xc6, 0xf7, 0x4e, 0xed, 0xab, 0x5c, 0xdf, 0xb9, 0xcc, 0x8c, 0xf3,
	0xf1, 0xc2, 0x03, 0xfb, 0x82, 0x78, 0xe0, 0x81, 0x47, 0x24, 0xf8, 0x0b, 0x90, 0x90, 0x40, 0x02,
	0x84, 0x84, 0xb4, 0xe2, 0x09, 0xf1, 0xc4, 0x5f, 0x80, 0x50, 0x85, 0x84, 0xf6, 0x6f, 0xe0, 0x05,
	0xcd, 0xc7, 0xb5, 0x6f, 0x92, 0x4d, 0x9c, 0x74, 0xf7, 0xc9, 0x73, 0xce, 0x9c, 0xdf, 0x99, 0x99,
	0xf3, 0xed, 0x0b, 0x88, 0xb3, 0x89, 0x0c, 0xa2, 0x61, 0x3f, 0x88, 0x5e, 0xb2, 0x7a, 0xcc, 0x99,
	0x64, 0xe8, 0x2d, 0x49, 0x25, 0x27, 0x92, 0xd6, 0x49, 0x1c, 0xd4, 0xa5, 0xe7, 0xd5, 0x3d, 0xc6,
	0x69, 0x7d, 0xff, 0x5e, 0xf5, 0xc6, 0x90, 0xb1, 0x61, 0x48, 0x1b, 0x5a, 0x6c, 0x30, 0x79, 0xd9,
	0xf0, 0x27, 0x9c, 0xc8, 0x80, 0x45, 0x06, 0x78, 0x7a, 0xff, 0x80, 0x93, 0x38, 0xa6, 0x5c, 0xd8,
	0xfd, 0xb7, 0xf6, 0x49, 0x18, 0xf8, 0x44, 0xd2, 0x46, 0xb2, 0xb0, 0x1b, 0xcb, 0x32, 0x14, 0x82,
	0x4a, 0x75, 0x11, 0x2b, 0x5b, 0xfb, 0xa4, 0x08, 0x57, 0xdb, 0x4d, 0xcc, 0x26, 0x92, 0x76, 0xed,
	0x0e, 0xba, 0x03, 0x2e, 0x8d, 0xc8, 0x20, 0xa4, 0xfd, 0x03, 0xc6, 0xf7, 0x5e, 0x86, 0xec, 0x40,
	0xac, 0x38, 0xab, 0xce, 0xed, 0x12, 0xbe, 0x6a, 0xf8, 0xcf, 0x13, 0x36, 0x1a, 0xc1, 0xb5, 0x90,
	0x11, 0xbf, 0x3f, 0x20, 0x21, 0x89, 0x3c, 0xca, 0xfb, 0x5e, 0x48, 0x84, 0x58, 0xc9, 0xac, 0x3a,
	0xb7, 0xaf, 0xac, 0xaf, 0xd5, 0xcf, 0x78, 0x61, 0xbd, 0xcd, 0x88, 0xdf, 0xb4, 0x90, 0x2d, 0x85,
	0x68, 0x56, 0xfe, 0xf2, 0xd9, 0xa7, 0xd9, 0xe2, 0x4f, 0x9d, 0x9c, 0xeb, 0xac, 0x2e, 0xe0, 0xe5,
	0xf0, 0xa4, 0x00, 0x7a, 0x0e, 0xe8, 0xf8, 0x49, 0x32, 0xa0, 0x7c, 0x25, 0xa7, 0x0f, 0xba, 0x73,
	0xa1, 0x83, 0x7a, 0x01, 0xe5, 0xd8, 0x0d, 0x4f, 0x70, 0xd0, 0x36, 0x14, 0x94, 0x73, 0xa8, 0x58,
	0xc9, 0xae, 0x66, 0x6f, 0x97, 0xd7, 0xef, 0x9e, 0xad, 0xec, 0xb8, 0x9d, 0x12, 0x1a, 0x5b, 0x7c,
	0xf5, 0x4f, 0x39, 0x28, 0x5a, 0x1e, 0xba, 0x05, 0xa5, 0x11, 0x13, 0x32, 0x22, 0x63, 0xaa, 0x6d,
	0xb7, 0xd8, 0x5c, 0x54, 0x2f, 0xcc, 0xf1, 0x8c, 0xeb, 0xe0, 0xe9, 0x16, 0xba, 0x0f, 0x59, 0x19,
	0x1a, 0x7b, 0x95, 0xd7, 0xdf, 0x3d, 0xf3, 0xe4, 0x5e, 0xbb, 0x9b, 0x9c, 0x8a, 0x15, 0x00, 0x7d,
	0x0c, 0x4b, 0x23, 0x29, 0xe3, 0x7e, 0xe2, 0xcd, 0x95, 0xac, 0xd6, 0x70, 0xeb, 0x4c, 0x0d, 0xdb,
	0x52, 0xc6, 0x53, 0x15, 0x95, 0x51, 0x8a, 0x42, 0x0f, 0xa1, 0x22, 0xbd, 0x94, 0xaa, 0xdc, 0xbc,
	0xcb, 0x78, 0x33, 0x4d, 0x65, 0x39, 0x23, 0xd0, 0x00, 0x96, 0xc8, 0x44, 0x8e, 0x66, 0x9a, 0xf2,
	0xda, 0xa0, 0x1f, 0x5e, 0xd6, 0xa0, 0xf5, 0xcd, 0x89, 0x1c, 0xcd, 0x2e, 0x4b, 0x52, 0x14, 0x7a,
	0x01, 0xd7, 0x94, 0xaa, 0x7e, 0x18, 0x8c, 0x03, 0x39, 0x3b, 0xa9, 0xa0, 0xef, 0x7c, 0x76, 0xc0,
	0x61, 0x22, 0x69, 0x5b, 0x41, 0xa6, 0x6a, 0x97, 0xf9, 0x49, 0x56, 0xf5, 0x10, 0x2a, 0xe9, 0x93,
	0xd1, 0x0f, 0xe1, 0xda, 0x80, 0x88, 0xc0, 0xeb, 0x1f, 0x7f, 0x95, 0x33, 0xe7, 0xac, 0xa6, 0xc2,
	0xa4, 0x15, 0x6d, 0x2f, 0xe0, 0xe5, 0xc1, 0x49, 0x66, 0x13, 0xa0, 0x94, 0xa8, 0xac, 0xfd, 0xd6,
	0x81, 0x37, 0x1f, 0x45, 0x92, 0xf2, 0x88, 0x84, 0xc7, 0x73, 0xf1, 0x94, 0xa3, 0x9d, 0x2f, 0xcf,
	0xd1, 0x99, 0xd7, 0x74, 0x74, 0xed, 0x3f, 0x0e, 0xbc, 0xd9, 0x3a, 0xfc, 0xbc, 0xeb, 0xda, 0x78,
	0x76, 0xbe, 0x70, 0x3c, 0x67, 0xbe, 0xbc, 0x67, 0x66, 0x5f, 0xf7, 0x99, 0x3f, 0xcb, 0x40, 0x6e,
	0x97, 0x71, 0x89, 0xae, 0x43, 0x21, 0x9a, 0x8c, 0x07, 0x94, 0xeb, 0x87, 0x2d, 0x61, 0x4b, 0x21,
	0x0c, 0x25, 0x5d, 0x45, 0x3d, 0x16, 0xea, 0x0b, 0x2f, 0x36, 0xef, 0xab, 0x24, 0xbf, 0xc7, 0x1b,
	0x38, 0xb7, 0xdd, 0xeb, 0xed, 0xe2, 0xdc, 0x43, 0xbc, 0xbb, 0x85, 0xf3, 0x6a, 0xbd, 0x6e, 0x7e,
	0xba, 0x38, 0xdb, 0xdb, 0xda, 0xc5, 0xd9, 0x5e, 0xbb, 0x8b, 0xb3, 0x4f, 0x1f, 0xec, 0xe2, 0x5c,
	0x77, 0xab, 0xb7, 0x8b, 0xa7, 0x7a, 0x10, 0x82, 0x9c, 0x2e, 0x1a, 0xea, 0xd6, 0x8b, 0x58, 0xaf,
	0xd1, 0x4d, 0x58, 0xa2, 0x91, 0x1f, 0xb3, 0x20, 0x92, 0xfd, 0x98, 0x71, 0xa9, 0x53, 0x74, 0x09,
	0x57, 0x12, 0xa6, 0xbe, 0xe4, 0x5d, 0x78, 0x63, 0x6f, 0x32, 0xa0, 0x3c, 0xa2, 0x92, 0x8a, 0x7e,
	0xc4, 0x7c, 0x6a, 0x64, 0xf3, 0x5a, 0x16, 0xcd, 0xf6, 0x3a, 0xcc, 0xa7, 0x1a, 0x71, 0x07, 0x5c,
	0x12, 0xc7, 0x61, 0xe0, 0xe9, 0xe6, 0x62, 0xa4, 0x0b, 0x5a, 0xfa, 0x6a, 0x8a, 0xaf, 0x44, 0x6b,
	0x7f, 0x70, 0xa0, 0xd0, 0x9d, 0x0c, 0x04, 0x95, 0xe8, 0x6d, 0x7b, 0xc1, 0x53, 0x55, 0xcd, 0xdc,
	0x75, 0x07, 0x0a, 0x21, 0x19, 0x50, 0x5d, 0xd4, 0x54, 0xf6, 0x7f, 0xed, 0x4c, 0xbb, 0x1b, 0x7d,
	0xf5, 0xb6, 0x96, 0x6e, 0x45, 0x92, 0x1f, 0x35, 0x41, 0x69, 0xcb, 0xff, 0xca, 0xc9, 0x94, 0x1c,
	0x6c, 0xd5, 0x54, 0xbf, 0x09, 0xe5, 0x94, 0x08, 0x72, 0x21, 0xbb, 0x47, 0x8f, 0xcc, 0xe9, 0x58,
	0x2d, 0xd1, 0x1b, 0x90, 0xdf, 0x27, 0xe1, 0x84, 0x1a, 0x17, 0x60, 0x43, 0x6c, 0x64, 0x3e, 0x70,
	0x6a, 0xbf, 0xcb, 0x41, 0x25, 0x1d, 0x28, 0xe8, 0x05, 0x5c, 0x11, 0x32, 0xf0, 0xf6, 0x8e, 0xfa,
	0x82, 0x0a, 0x11, 0xb0, 0xc8, 0x46, 0xea, 0x7b, 0x17, 0x8a, 0xb3, 0x7a, 0x57, 0x63, 0xbb, 0x06,
	0x8a, 0x97, 0x44, 0x9a, 0x44, 0x0f, 0xa0, 0xec, 0x31, 0x2e, 0xfa, 0x31, 0x0b, 0x03, 0xef, 0xc8,
	0x06, 0xf0, 0xcd, 0x33, 0x15, 0x6f, 0x31, 0x2e, 0x76, 0xb5, 0x28, 0x06, 0x6f, 0xba, 0x46, 0x4d,
	0x28, 0xeb, 0x6e, 0xd2, 0xe7, 0x93, 0x70, 0xda, 0x92, 0xde, 0x39, 0xf7, 0x7a, 0x78, 0x12, 0x52,
	0x0c, 0x1a, 0xa5, 0x96, 0xa2, 0xfa, 0x89, 0x03, 0xa0, 0x62, 0x6d, 0x8b, 0xb1, 0xbd, 0x80, 0xce,
	0x73, 0xd8, 0xdb, 0x90, 0x8b, 0x89, 0x1c, 0xd9, 0x00, 0x4e, 0x6f, 0x2b, 0x36, 0xfa, 0x06, 0x64,
	0xa5, 0x0c, 0x6d, 0x12, 0x7d, 0xa5, 0x6e, 0x46, 0x8f, 0x7a, 0x32, 0x7a, 0xd4, 0x1f, 0xd8, 0xd1,
	0xc4, 0xba, 0xee, 0xe7, 0x8e, 0x42, 0x2a, 0x44, 0xf5, 0xf7, 0x0e, 0x2c, 0x1d, 0x33, 0x18, 0xba,
	0x09, 0x85, 0x11, 0x25, 0xbe, 0x4d, 0xa3, 0xf4, 0x59, 0xdb, 0x0b, 0xd8, 0x6e, 0xa1, 0x8f, 0xa1,
	0xe0, 0xe9, 0x7b, 0x5b, 0x0b, 0xde, 0xbd, 0x98, 0x6b, 0x66, 0xef, 0x55, 0xba, 0x8c, 0x06, 0xf4,
	0x2e, 0x2c, 0x4d, 0x04, 0xed, 0x0b, 0x36, 0xe1, 0x1e, 0xed, 0x07, 0xb1, 0x7e, 0x45, 0x69, 0x7b,
	0x01, 0x97, 0x27, 0x82, 0x76, 0x35, 0xf7, 0x51, 0xac, 0x0a, 0xf1, 0x88, 0x88, 0x51, 0x7f, 0x8f,
	0x1e, 0xd5, 0x76, 0xa0, 0x9c, 0x2a, 0x07, 0xe8, 0xbb, 0x90, 0xd7, 0x76, 0xb5, 0x61, 0x72, 0xe3,
	0xec, 0xfe, 0xa2, 0xa4, 0x8e, 0xd9, 0xc0, 0x00, 0x6b, 0xbf, 0xc9, 0x40, 0x29, 0x71, 0x12, 0xda,
	0x84, 0xfc, 0x98, 0x48, 0x6f, 0xb4, 0xe2, 0xcc, 0x49, 0x0d, 0x85, 0x78, 0xa2, 0x24, 0xb7, 0x58,
	0xe4, 0x07, 0xca, 0xbe, 0xd8, 0x20, 0xd1, 0x26, 0x14, 0xc6, 0xcc, 0x0f, 0x5e, 0x26, 0x01, 0x76,
	0xe7, 0x7c, 0x1d, 0x5a, 0x74, 0xd3, 0xd3, 0x1a, 0x2c, 0x10, 0xdd, 0x4f, 0x1e, 0x95, 0xbb, 0xc8,
	0xa3, 0xb6, 0x17, 0xec, 0x53, 0xd0, 0x77, 0xa0, 0xc4, 0xa9, 0x1f, 0x70, 0xea, 0x99, 0xa2, 0x72,
	0x5e, 0x5c, 0x62, 0x2b, 0xb8, 0xbd, 0x80, 0xa7, 0xa0, 0xe6, 0x35, 0x58, 0x36, 0xb1, 0xcd, 0x78,
	0x3f, 0x61, 0xd6, 0xfe, 0x96, 0x05, 0x74, 0xfa, 0xb9, 0xaa, 0x91, 0x4c, 0x78, 0x30, 0xb7, 0x91,
	0x74, 0x25, 0x0f, 0xa2, 0xa1, 0xc6, 0x62, 0x05, 0x40, 0xdf, 0x86, 0x82, 0xf0, 0x46, 0x74, 0x4c,
	0xe7, 0x76, 0xb7, 0x34, 0xd4, 0x62, 0x14, 0x7a, 0x4c, 0xe5, 0x88, 0xf9, 0x73, 0x9b, 0xc6, 0x31,
	0xb4, 0xc1, 0xa0, 0x26, 0x2c, 0xaa, 0x49, 0x81, 0xf1, 0x40, 0x1e, 0xcd, 0x9d, 0xa2, 0xd2, 0x0a,
	0x66, 0x30, 0x84, 0xa1, 0x68, 0x12, 0x21, 0x99, 0x9e, 0x3e, 0xb8, 0x44, 0x90, 0xd4, 0xb7, 0x0d,
	0x54, 0x57, 0x4a, 0x9c, 0x28, 0xaa, 0xfe, 0x08, 0x2a, 0xe9, 0x8d, 0xcf, 0x29, 0xa1, 0x1b, 0xe9,
	0x12, 0x7a, 0xd1, 0x5b, 0xa7, 0x0a, 0x2d, 0x85, 0x72, 0x6a, 0x07, 0x5d, 0x87, 0x3c, 0x3d, 0x24,
	0x9e, 0x34, 0x47, 0xa8, 0x08, 0xd2, 0x24, 0x5a, 0x81, 0x42, 0xcc, 0xe9, 0xcb, 0xe0, 0xd0, 0x14,
	0x1b, 0x95, 0xa9, 0x86, 0x56, 0x08, 0x4e, 0x87, 0xf4, 0xd0, 0xb4, 0x3d, 0x1d, 0x73, 0x8a, 0x6c,
	0x56, 0x00, 0x74, 0xdc, 0xf7, 0xe5, 0x51, 0x4c, 0x6b, 0x1f, 0x42, 0x59, 0xb7, 0x55, 0x7a, 0xc0,
	0x03, 0x49, 0xd5, 0x3b, 0x92, 0x18, 0x59, 0x34, 0xde, 0xff, 0x6a, 0xda, 0x03, 0xa6, 0x1d, 0xcc,
	0x18, 0xb5, 0x7f, 0x65, 0xa1, 0x68, 0x0d, 0x81, 0x1e, 0x43, 0x91, 0xd3, 0x1f, 0x4f, 0xa8, 0x90,
	0x36, 0xc6, 0xee, 0x9d, 0x6d, 0x67, 0x03, 0xb1, 0xbf, 0x3b, 0x31, 0x35, 0x15, 0x4f, 0xe0, 0x44,
	0x03, 0x7a, 0xa2, 0x32, 0x43, 0xc4, 0x2c, 0x12, 0x89, 0x05, 0x5f, 0x43, 0xdb, 0x54, 0x45, 0xf5,
	0x8f, 0x19, 0x70, 0x4f, 0x6e, 0xa3, 0x36, 0x64, 0x05, 0x95, 0xb6, 0x72, 0x6c, 0x5c, 0x5a, 0x7d,
	0xbd, 0x4b, 0xa5, 0x09, 0x0b, 0xa5, 0x46, 0x69, 0x23, 0xbe, 0x6f, 0x5b, 0xf4, 0x6b, 0x68, 0xdb,
	0xf4, 0x7d, 0xab, 0x8d, 0xf8, 0xbe, 0x9a, 0x8f, 0x38, 0x1d, 0xb3, 0x7d, 0xaa, 0xfb, 0xd5, 0x22,
	0xb6, 0x54, 0xf5, 0x3e, 0x94, 0x92, 0x63, 0x2f, 0xd3, 0xb7, 0x15, 0x2e, 0x39, 0xe0, 0x52, 0xfd,
	0xfe, 0x17, 0x0e, 0xb8, 0x27, 0xcb, 0x1e, 0xfa, 0x48, 0x79, 0x5a, 0x07, 0xcc, 0xdc, 0x6a, 0x92,
	0x0a, 0x2e, 0x9c, 0x80, 0xd0, 0xc6, 0x2c, 0x23, 0x8d, 0x6f, 0x57, 0xe7, 0x99, 0x6b, 0x9a, 0x79,
	0xb5, 0xbf, 0xe6, 0x20, 0x6f, 0xfe, 0x0f, 0xbe, 0x80, 0x8a, 0x4f, 0x85, 0x0c, 0x22, 0x63, 0x40,
	0xeb, 0xc7, 0xb5, 0xf3, 0x6b, 0x6f, 0xfd, 0xc1, 0x0c, 0x62, 0x9b, 0xcb, 0x2f, 0xf5, 0x6c, 0x74,
	0x4c, 0x57, 0xf5, 0x27, 0xe0, 0xb6, 0x99, 0x47, 0xc2, 0x94, 0x34, 0x5a, 0x85, 0x72, 0x6a, 0x86,
	0xb3, 0xe6, 0x4b, 0xb3, 0xd0, 0x0a, 0x14, 0x05, 0xe5, 0xfb, 0x81, 0x97, 0x18, 0x32, 0x21, 0xd1,
	0x75, 0xc8, 0xa9, 0x3f, 0xa8, 0x26, 0x17, 0x9b, 0x99, 0x15, 0x07, 0x6b, 0x5a, 0xb9, 0x59, 0xe8,
	0x99, 0x4d, 0x17, 0xb7, 0x45, 0x6c, 0xa9, 0xea, 0x0b, 0x58, 0xc6, 0x74, 0xcc, 0x24, 0xbd, 0xdc,
	0x05, 0x6e, 0x9e, 0xb8, 0x40, 0x7a, 0xf6, 0x48, 0x76, 0xaa, 0xff, 0x73, 0xa0, 0x9c, 0x56, 0xfb,
	0x10, 0xf2, 0xa1, 0x7a, 0xab, 0xf5, 0x65, 0x63, 0x8e, 0x01, 0x4f, 0xda, 0x45, 0x55, 0x16, 0x8d,
	0x57, 0x73, 0x06, 0xd7, 0x97, 0x9e, 0x3b, 0x67, 0x18, 0x4d, 0xa7, 0x5e, 0xa8, 0xaa, 0x97, 0xd1,
	0x80, 0xaa, 0x50, 0x24, 0xbe, 0xcf, 0xa9, 0x10, 0xd3, 0xfa, 0x95, 0x30, 0x94, 0xd1, 0x0e, 0x68,
	0x30, 0x1c, 0x25, 0x43, 0xbb, 0xa5, 0xd4, 0x9c, 0x9f, 0x1a, 0xcf, 0xf5, 0xba, 0x79, 0x15, 0x0a,
	0x92, 0xf0, 0x21, 0x95, 0x28, 0xff, 0xe7, 0xcf, 0x3e, 0xcd, 0x3a, 0xb5, 0x0d, 0x28, 0x25, 0x9d,
	0xf4, 0xd2, 0xd5, 0xee, 0xd7, 0x19, 0x80, 0xd9, 0x90, 0x89, 0xde, 0x81, 0x0a, 0x09, 0x43, 0x76,
	0xd0, 0x67, 0x3c, 0x18, 0x06, 0x91, 0x0e, 0x40, 0xe5, 0x10, 0xc5, 0xdb, 0xd1, 0x2c, 0xf5, 0x37,
	0xc3, 0x88, 0x98, 0x7e, 0x66, 0x26, 0xf8, 0x45, 0x6c, 0x70, 0x4f, 0x0c, 0x6f, 0x26, 0x94, 0x24,
	0x45, 0x36, 0x25, 0x94, 0x54, 0xd7, 0x5b, 0x70, 0x85, 0x1e, 0xc6, 0x4c, 0xd0, 0xa9, 0x54, 0x4e,
	0x4b, 0x2d, 0x19, 0x6e, 0x22, 0xb6, 0x0e, 0xc5, 0x31, 0x39, 0xec, 0x93, 0x21, 0xb5, 0x03, 0xc5,
	0xd9, 0xf3, 0x25, 0x2e, 0x8c, 0xc9, 0xe1, 0xe6, 0x90, 0xa2, 0x87, 0xb0, 0x6c, 0xce, 0xf7, 0x38,
	0xf5, 0x69, 0x24, 0x03, 0x12, 0x26, 0x7f, 0xff, 0xab, 0xa7, 0xd0, 0x4d, 0xc6, 0xc2, 0x67, 0xaa,
	0x3c, 0x60, 0x57, 0x83, 0xb6, 0x66, 0x98, 0xda, 0x3f, 0x1c, 0x58, 0x3e, 0xf5, 0x57, 0x5d, 0x15,
	0x17, 0x4e, 0x49, 0x38, 0xb6, 0x76, 0x36, 0x84, 0xca, 0x15, 0x6f, 0x44, 0xb8, 0x0a, 0x7d, 0x9b,
	0x2b, 0x96, 0x44, 0x2d, 0xc8, 0x4f, 0x44, 0x62, 0x86, 0xf3, 0xe2, 0xf1, 0xd4, 0x51, 0xf5, 0xa7,
	0x82, 0x72, 0x6c, 0xd0, 0xd5, 0x8f, 0x20, 0xa7, 0x48, 0x54, 0x85, 0x92, 0x62, 0xcc, 0xe6, 0x75,
	0x3c, 0xa5, 0xd5, 0x5e, 0x4c, 0x84, 0x38, 0x60, 0xdc, 0xb7, 0xb7, 0x98, 0xd2, 0xb5, 0xff, 0x3a,
	0xb0, 0x7c, 0xea, 0x1b, 0x87, 0x72, 0x83, 0x6d, 0x51, 0xc2, 0x7c, 0x30, 0xb1, 0xff, 0x5f, 0x97,
	0x12, 0xae, 0x16, 0x47, 0xef, 0x43, 0x29, 0x88, 0x24, 0xe5, 0xfb, 0x24, 0xb4, 0xc9, 0x70, 0x8e,
	0x1f, 0xa6, 0xa2, 0xaa, 0xeb, 0x99, 0xaf, 0x30, 0x83, 0x23, 0x1d, 0xf6, 0x57, 0xd6, 0xd7, 0x2f,
	0xfe, 0xfd, 0xa5, 0xae, 0xa9, 0xe6, 0x11, 0x2e, 0x86, 0x66, 0x51, 0xbb, 0x05, 0x45, 0xcb, 0x43,
	0x05, 0xc8, 0x3c, 0xda, 0x75, 0x17, 0x50, 0x09, 0x72, 0x4f, 0xbb, 0x2d, 0xec, 0x3a, 0x6a, 0xd5,
	0xd9, 0xe9, 0xb4, 0xdc, 0xcc, 0xda, 0xb7, 0xa0, 0xdc, 0x35, 0xb5, 0xa1, 0x77, 0x14, 0x53, 0x54,
	0x81, 0xd2, 0xa3, 0x4e, 0xaf, 0x85, 0x3b, 0x9b, 0x6d, 0x77, 0x01, 0xb9, 0x50, 0x69, 0xef, 0x6c,
	0x3e, 0x68, 0x6e, 0xb6, 0x37, 0x3b, 0x5b, 0x1a, 0x58, 0x81, 0x52, 0xeb, 0xfb, 0x76, 0x3f, 0xb3,
	0x76, 0x17, 0x96, 0x4f, 0x7d, 0x7a, 0x9c, 0xea, 0x5e, 0x40, 0x8b, 0x90, 0x6f, 0x75, 0x9e, 0xed,
	0xfc, 0xc0, 0x75, 0xd4, 0x15, 0xbe, 0xf7, 0xbe, 0x9b, 0x59, 0xdb, 0x50, 0xb5, 0xf5, 0xc4, 0x17,
	0x43, 0x17, 0x2a, 0xbd, 0x47, 0x2d, 0xdc, 0xef, 0xec, 0xf4, 0xfa, 0xdd, 0x56, 0xcf, 0x00, 0x15,
	0xe7, 0x9e, 0xeb, 0x24, 0xcb, 0x75, 0x37, 0xb3, 0xd6, 0x50, 0xd9, 0x3b, 0x0c, 0x84, 0x6a, 0x63,
	0x65, 0x28, 0x3e, 0xed, 0x3c, 0xee, 0xec, 0x3c, 0xef, 0xb8, 0x0b, 0xe8, 0x0a, 0xc0, 0xe3, 0xa7,
	0xcd, 0x16, 0xee, 0xb4, 0x7a, 0xad, 0xae, 0x39, 0xec, 0xd9, 0x13, 0x37, 0xd3, 0xdc, 0xf8, 0xfb,
	0xab, 0x1b, 0xce, 0x3f, 0x5f, 0xdd, 0x70, 0xfe, 0xfd, 0xea, 0x86, 0xf3, 0xe2, 0xeb, 0xc3, 0x40,
	0x8e, 0x26, 0x83, 0xba, 0xc7, 0xc6, 0x0d, 0x6b, 0xd7, 0x80, 0x25, 0xab, 0x06, 0x89, 0x83, 0x86,
	0xf4, 0xbc, 0x86, 0xb2, 0x70, 0x63, 0xff, 0xde, 0xa0, 0xa0, 0x5d, 0xf5, 0xde, 0xff, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xd8, 0x4d, 0x5b, 0x71, 0x6a, 0x16, 0x00, 0x00,
}

func (m *LBRouteSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LBRouteSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LBRouteSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LoadBalancerTier != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.LoadBalancerTier))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LoadBalancerClass != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.LoadBalancerClass))
		i--
		dAtA[i] = 0x10
	}
	if m.EnableWorkflows {
		i--
		if m.EnableWorkflows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LBRouteSettings_LBRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LBRouteSettings_LBRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LBRouteSettings_LBRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RateLimitSettings != nil {
		{
			size, err := m.RateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AuthSettings) > 0 {
		for iNdEx := len(m.AuthSettings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TcpSettings != nil {
		{
			size, err := m.TcpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.HttpSettings != nil {
		{
			size, err := m.HttpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Tls != nil {
		{
			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LBRouteSettings_LBRoute_AuthSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LBRouteSettings_LBRoute_AuthSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LBRouteSettings_LBRoute_AuthSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Settings != nil {
		{
			size := m.Settings.Size()
			i -= size
			if _, err := m.Settings.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BasicAuthSettings != nil {
		{
			size, err := m.BasicAuthSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InternalRouteSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalRouteSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalRouteSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpSettings != nil {
		{
			size, err := m.TcpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HttpSettings != nil {
		{
			size, err := m.HttpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalRouteSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalRouteSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalRouteSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpSettings != nil {
		{
			size, err := m.TcpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.HttpSettings != nil {
		{
			size, err := m.HttpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tls != nil {
		{
			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApplicationPort != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.ApplicationPort))
		i--
		dAtA[i] = 0x30
	}
	if m.KubernetesNodePort != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.KubernetesNodePort))
		i--
		dAtA[i] = 0x28
	}
	if m.EndpointPort != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.EndpointPort))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Subset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoutingInfo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouteRules) > 0 {
		for iNdEx := len(m.RouteRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StickySession != nil {
		{
			size, err := m.StickySession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings_HTTPCookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpSettings_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpSettings_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ttl != nil {
		{
			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings_StickySession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpSettings_StickySession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpSettings_StickySession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HashKey != nil {
		{
			size := m.HashKey.Size()
			i -= size
			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings_StickySession_Header) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpSettings_StickySession_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Header)
	copy(dAtA[i:], m.Header)
	i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Header)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HttpSettings_StickySession_Cookie) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpSettings_StickySession_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HttpSettings_StickySession_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpSettings_StickySession_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UseSourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *TcpSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RouteOrRedirect != nil {
		{
			size := m.RouteOrRedirect.Size()
			i -= size
			if _, err := m.RouteOrRedirect.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Modify != nil {
		{
			size, err := m.Modify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpRule_Route) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRule_Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HttpRule_Redirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HttpRule_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *HttpMatchCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpMatchCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpMatchCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoutingInfo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Authority != nil {
		{
			size, err := m.Authority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Method != nil {
		{
			size, err := m.Method.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Scheme != nil {
		{
			size, err := m.Scheme.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Uri != nil {
		{
			size, err := m.Uri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchType != nil {
		{
			size := m.MatchType.Size()
			i -= size
			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Headers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Headers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Headers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Headers_HeaderOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Headers_HeaderOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Headers_HeaderOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Remove) > 0 {
		for iNdEx := len(m.Remove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Remove[iNdEx])
			copy(dAtA[i:], m.Remove[iNdEx])
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Remove[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Add) > 0 {
		for k := range m.Add {
			v := m.Add[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoutingInfo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Set) > 0 {
		for k := range m.Set {
			v := m.Set[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoutingInfo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HttpModifyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpModifyAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpModifyAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Headers != nil {
		{
			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Rewrite != nil {
		{
			size, err := m.Rewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Destinations) > 0 {
		for iNdEx := len(m.Destinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Destinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Route_LocalDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route_LocalDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route_LocalDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Subset) > 0 {
		i -= len(m.Subset)
		copy(dAtA[i:], m.Subset)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Subset)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Application) > 0 {
		i -= len(m.Application)
		copy(dAtA[i:], m.Application)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Application)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route_RemoteDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route_RemoteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route_RemoteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Application) > 0 {
		i -= len(m.Application)
		copy(dAtA[i:], m.Application)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Application)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route_Destination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route_Destination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route_Destination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x28
	}
	if m.Weight != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x20
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Route_Destination_Local) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_Destination_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Route_Destination_Remote) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_Destination_Remote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Remote != nil {
		{
			size, err := m.Remote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Route_Destination_Address) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_Destination_Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Redirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowCredentials != nil {
		{
			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MaxAge != nil {
		{
			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExposeHeaders) > 0 {
		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExposeHeaders[iNdEx])
			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AllowHeaders) > 0 {
		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowHeaders[iNdEx])
			copy(dAtA[i:], m.AllowHeaders[iNdEx])
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AllowMethods) > 0 {
		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowMethods[iNdEx])
			copy(dAtA[i:], m.AllowMethods[iNdEx])
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowOrigin) > 0 {
		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOrigin[iNdEx])
			copy(dAtA[i:], m.AllowOrigin[iNdEx])
			i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BasicAuthSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuthSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicAuthSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Charset) > 0 {
		i -= len(m.Charset)
		copy(dAtA[i:], m.Charset)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Charset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Realm) > 0 {
		i -= len(m.Realm)
		copy(dAtA[i:], m.Realm)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Realm)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasicAuthSettings_User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuthSettings_User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicAuthSettings_User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintRoutingInfo(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LimitBy != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.LimitBy))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RequestsLimit != 0 {
		i = encodeVarintRoutingInfo(dAtA, i, uint64(m.RequestsLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRoutingInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoutingInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LBRouteSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableWorkflows {
		n += 2
	}
	if m.LoadBalancerClass != 0 {
		n += 1 + sovRoutingInfo(uint64(m.LoadBalancerClass))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.LoadBalancerTier != 0 {
		n += 1 + sovRoutingInfo(uint64(m.LoadBalancerTier))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LBRouteSettings_LBRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.HttpSettings != nil {
		l = m.HttpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.TcpSettings != nil {
		l = m.TcpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if len(m.AuthSettings) > 0 {
		for _, e := range m.AuthSettings {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.RateLimitSettings != nil {
		l = m.RateLimitSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LBRouteSettings_LBRoute_AuthSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Settings != nil {
		n += m.Settings.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicAuthSettings != nil {
		l = m.BasicAuthSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *InternalRouteSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpSettings != nil {
		l = m.HttpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.TcpSettings != nil {
		l = m.TcpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalRouteSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.HttpSettings != nil {
		l = m.HttpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.TcpSettings != nil {
		l = m.TcpSettings.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovRoutingInfo(uint64(m.Number))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.EndpointPort != 0 {
		n += 1 + sovRoutingInfo(uint64(m.EndpointPort))
	}
	if m.KubernetesNodePort != 0 {
		n += 1 + sovRoutingInfo(uint64(m.KubernetesNodePort))
	}
	if m.ApplicationPort != 0 {
		n += 1 + sovRoutingInfo(uint64(m.ApplicationPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRoutingInfo(uint64(len(k))) + 1 + len(v) + sovRoutingInfo(uint64(len(v)))
			n += mapEntrySize + 1 + sovRoutingInfo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StickySession != nil {
		l = m.StickySession.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if len(m.RouteRules) > 0 {
		for _, e := range m.RouteRules {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings_HTTPCookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Ttl != nil {
		l = m.Ttl.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings_StickySession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashKey != nil {
		n += m.HashKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings_StickySession_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	n += 1 + l + sovRoutingInfo(uint64(l))
	return n
}
func (m *HttpSettings_StickySession_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *HttpSettings_StickySession_UseSourceIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *TcpSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.Modify != nil {
		l = m.Modify.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.RouteOrRedirect != nil {
		n += m.RouteOrRedirect.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpRule_Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *HttpRule_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *HttpMatchCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uri != nil {
		l = m.Uri.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Scheme != nil {
		l = m.Scheme.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Authority != nil {
		l = m.Authority.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoutingInfo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoutingInfo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoutingInfo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchType != nil {
		n += m.MatchType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovRoutingInfo(uint64(l))
	return n
}
func (m *StringMatch_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovRoutingInfo(uint64(l))
	return n
}
func (m *StringMatch_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovRoutingInfo(uint64(l))
	return n
}
func (m *HTTPRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Headers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Headers_HeaderOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for k, v := range m.Set {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRoutingInfo(uint64(len(k))) + 1 + len(v) + sovRoutingInfo(uint64(len(v)))
			n += mapEntrySize + 1 + sovRoutingInfo(uint64(mapEntrySize))
		}
	}
	if len(m.Add) > 0 {
		for k, v := range m.Add {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRoutingInfo(uint64(len(k))) + 1 + len(v) + sovRoutingInfo(uint64(len(v)))
			n += mapEntrySize + 1 + sovRoutingInfo(uint64(mapEntrySize))
		}
	}
	if len(m.Remove) > 0 {
		for _, s := range m.Remove {
			l = len(s)
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpModifyAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rewrite != nil {
		l = m.Rewrite.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route_LocalDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Application)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Subset)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route_RemoteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Application)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route_Destination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.Weight != 0 {
		n += 1 + sovRoutingInfo(uint64(m.Weight))
	}
	if m.Port != 0 {
		n += 1 + sovRoutingInfo(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route_Destination_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *Route_Destination_Remote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remote != nil {
		l = m.Remote.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	return n
}
func (m *Route_Destination_Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovRoutingInfo(uint64(l))
	return n
}
func (m *Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if len(m.AllowMethods) > 0 {
		for _, s := range m.AllowMethods {
			l = len(s)
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if len(m.AllowHeaders) > 0 {
		for _, s := range m.AllowHeaders {
			l = len(s)
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if len(m.ExposeHeaders) > 0 {
		for _, s := range m.ExposeHeaders {
			l = len(s)
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.MaxAge != nil {
		l = m.MaxAge.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.AllowCredentials != nil {
		l = m.AllowCredentials.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BasicAuthSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Charset)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovRoutingInfo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BasicAuthSettings_User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestsLimit != 0 {
		n += 1 + sovRoutingInfo(uint64(m.RequestsLimit))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovRoutingInfo(uint64(l))
	}
	if m.LimitBy != 0 {
		n += 1 + sovRoutingInfo(uint64(m.LimitBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRoutingInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoutingInfo(x uint64) (n int) {
	return sovRoutingInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LBRouteSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LBRouteSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LBRouteSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableWorkflows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableWorkflows = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerClass", wireType)
			}
			m.LoadBalancerClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancerClass |= LoadBalancerClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &LBRouteSettings_LBRoute{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerTier", wireType)
			}
			m.LoadBalancerTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancerTier |= LoadBalancerTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LBRouteSettings_LBRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LBRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LBRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tls == nil {
				m.Tls = &TLSSettings{}
			}
			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpSettings == nil {
				m.HttpSettings = &HttpSettings{}
			}
			if err := m.HttpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpSettings == nil {
				m.TcpSettings = &TcpSettings{}
			}
			if err := m.TcpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthSettings = append(m.AuthSettings, &LBRouteSettings_LBRoute_AuthSettings{})
			if err := m.AuthSettings[len(m.AuthSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateLimitSettings == nil {
				m.RateLimitSettings = &RateLimitSettings{}
			}
			if err := m.RateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LBRouteSettings_LBRoute_AuthSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuthSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BasicAuthSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &LBRouteSettings_LBRoute_AuthSettings_BasicAuthSettings{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalRouteSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalRouteSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalRouteSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpSettings == nil {
				m.HttpSettings = &HttpSettings{}
			}
			if err := m.HttpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpSettings == nil {
				m.TcpSettings = &TcpSettings{}
			}
			if err := m.TcpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalRouteSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalRouteSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalRouteSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tls == nil {
				m.Tls = &TLSSettings{}
			}
			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpSettings == nil {
				m.HttpSettings = &HttpSettings{}
			}
			if err := m.HttpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpSettings == nil {
				m.TcpSettings = &TcpSettings{}
			}
			if err := m.TcpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointPort", wireType)
			}
			m.EndpointPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesNodePort", wireType)
			}
			m.KubernetesNodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KubernetesNodePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPort", wireType)
			}
			m.ApplicationPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplicationPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoutingInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoutingInfo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickySession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickySession == nil {
				m.StickySession = &HttpSettings_StickySession{}
			}
			if err := m.StickySession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteRules = append(m.RouteRules, &HttpRule{})
			if err := m.RouteRules[len(m.RouteRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpSettings_HTTPCookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = &types.Duration{}
			}
			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpSettings_StickySession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickySession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickySession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashKey = &HttpSettings_StickySession_Header{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpSettings_HTTPCookie{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HashKey = &HttpSettings_StickySession_Cookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HashKey = &HttpSettings_StickySession_UseSourceIp{b}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &HttpMatchCondition{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modify == nil {
				m.Modify = &HttpModifyAction{}
			}
			if err := m.Modify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Route{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteOrRedirect = &HttpRule_Route{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Redirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteOrRedirect = &HttpRule_Redirect{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpMatchCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpMatchCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpMatchCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = &StringMatch{}
			}
			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scheme == nil {
				m.Scheme = &StringMatch{}
			}
			if err := m.Scheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &StringMatch{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authority == nil {
				m.Authority = &StringMatch{}
			}
			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*StringMatch)
			}
			var mapkey string
			var mapvalue *StringMatch
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoutingInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringMatch{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoutingInfo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Headers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &Headers_HeaderOperations{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Headers_HeaderOperations{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoutingInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoutingInfo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Set[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Add == nil {
				m.Add = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoutingInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoutingInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoutingInfo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoutingInfo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Add[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpModifyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpModifyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpModifyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewrite == nil {
				m.Rewrite = &HTTPRewrite{}
			}
			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &Headers{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &Route_Destination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route_LocalDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Application = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route_RemoteDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Application = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route_Destination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Route_LocalDestination{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &Route_Destination_Local{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Route_RemoteDestination{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &Route_Destination_Remote{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = &Route_Destination_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Redirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Redirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Redirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxAge == nil {
				m.MaxAge = &types.Duration{}
			}
			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowCredentials == nil {
				m.AllowCredentials = &types.BoolValue{}
			}
			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuthSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAuthSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAuthSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &BasicAuthSettings_User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuthSettings_User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsLimit", wireType)
			}
			m.RequestsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &types.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitBy", wireType)
			}
			m.LimitBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitBy |= RateLimitSettings_LimitBy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoutingInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoutingInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoutingInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoutingInfo
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRoutingInfo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoutingInfo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoutingInfo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRoutingInfo
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoutingInfo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoutingInfo   = fmt.Errorf("proto: integer overflow")
)
