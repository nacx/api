// tslint:disable
/**
 * TCC Configuration API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 * Contact: info@tetrate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    TetrateApiTccCoreV1RouteLocalDestination,
    TetrateApiTccCoreV1RouteLocalDestinationFromJSON,
    TetrateApiTccCoreV1RouteLocalDestinationToJSON,
    TetrateApiTccCoreV1RouteRemoteDestination,
    TetrateApiTccCoreV1RouteRemoteDestinationFromJSON,
    TetrateApiTccCoreV1RouteRemoteDestinationToJSON,
} from './';

/**
 * 
 * @export
 * @interface TetrateApiTccCoreV1RouteDestination
 */
export interface TetrateApiTccCoreV1RouteDestination {
    /**
     * 
     * @type {TetrateApiTccCoreV1RouteLocalDestination}
     * @memberof TetrateApiTccCoreV1RouteDestination
     */
    local?: TetrateApiTccCoreV1RouteLocalDestination;
    /**
     * 
     * @type {TetrateApiTccCoreV1RouteRemoteDestination}
     * @memberof TetrateApiTccCoreV1RouteDestination
     */
    remote?: TetrateApiTccCoreV1RouteRemoteDestination;
    /**
     * Instead of specifying local/remote services, you can specify the hostname/IP address to which traffic should be routed to. This address should be reachable from the load balancer. This destination type is applicable only when used with a load balancer service.
     * @type {string}
     * @memberof TetrateApiTccCoreV1RouteDestination
     */
    address?: string;
    /**
     * 100 if omitted. sum of all weights should add up to 100.
     * @type {number}
     * @memberof TetrateApiTccCoreV1RouteDestination
     */
    weight?: number;
    /**
     * Optional.
     * @type {number}
     * @memberof TetrateApiTccCoreV1RouteDestination
     */
    port?: number;
}

export function TetrateApiTccCoreV1RouteDestinationFromJSON(json: any): TetrateApiTccCoreV1RouteDestination {
    return {
        'local': !exists(json, 'local') ? undefined : TetrateApiTccCoreV1RouteLocalDestinationFromJSON(json['local']),
        'remote': !exists(json, 'remote') ? undefined : TetrateApiTccCoreV1RouteRemoteDestinationFromJSON(json['remote']),
        'address': !exists(json, 'address') ? undefined : json['address'],
        'weight': !exists(json, 'weight') ? undefined : json['weight'],
        'port': !exists(json, 'port') ? undefined : json['port'],
    };
}

export function TetrateApiTccCoreV1RouteDestinationToJSON(value?: TetrateApiTccCoreV1RouteDestination): any {
    if (value === undefined) {
        return undefined;
    }
    return {
        'local': TetrateApiTccCoreV1RouteLocalDestinationToJSON(value.local),
        'remote': TetrateApiTccCoreV1RouteRemoteDestinationToJSON(value.remote),
        'address': value.address,
        'weight': value.weight,
        'port': value.port,
    };
}


