// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authz.proto

package v1

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Runtime Authorization Policy
//
// Runtime authorization policies are attached to specific resources and define which subjects,
// and under which conditions, are allowed to access them.
// Different subjects can be configured to access the target resource with different conditions
// by setting multiple bindings in the same policy.
//
// The default authorization policy allows access between services within an application, and denies
// cross-application traffic. Traffic between applications must be explicitly enabled by applying
// the corresponding access policy in the target application.
//
// THe following examples show some common policies:
//
//     # Default deny policy for applications. The absence of bindings means that there is no
//     # access allowed from outside the application.
//     policy:
//
//     # Allow access from the 'bookinfo' application. Requests from the client application
//     # present a JWT token for the 'bookinfo' application.
//     policy:
//       bindings:
//       - from:
//         - jwt:
//             principal: bookinfo
//             audience: tsb
//             claims:
//               group: applications
//
//     # Allow access from the 'bookinfo' application, but only to the '/v1/*'
//     # HTTP paths, and only for GET and HEAD requests, on the 'bookinfo.com' host.
//     policy:
//       bindings:
//       - from:
//         - jwt:
//             principal: bookinfo
//             audience: tsb
//             claims:
//               group: applications
//         allow_http:
//           to:
//           - paths:
//             - /v1/*
//             hosts:
//             - bookinfo.com
//             methods:
//             - GET
//             - HEAD
//
//     # Allow access from the 'bookinfo' application, but only to the '/v1/*'
//     # HTTP paths, and only for GET and HEAD requests, on the 'bookinfo.com' host.
//     # In this example the client application is identified by checking the value of
//     # the 'X-App-Id' request header.
//     policy:
//       bindings:
//       - from:
//         - request_headers:
//             X-App-Id: bookinfo
//         allow_http:
//           to:
//           - paths:
//             - /v1/*
//             hosts:
//             - bookinfo.com
//             methods:
//             - GET
//             - HEAD
//
//     # When applied to a service, allows traffic only from the configured identities.
//     policy:
//       bindings:
//       - from:
//         - cluster_local_service_account: default/bookinfo-sa
//         - subject_alt_name: spiffe://cluster.local/ns/default/sa/bookinfo-sa
//
type Policy struct {
	// List of bindings that configure access to the target resource.
	Bindings []*Binding `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	// Etag to guard concurrent modifications to the policy.
	Etag                 string   `protobuf:"bytes,2,opt,name=etag,proto3" json:"etag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{0}
}
func (m *Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return m.Size()
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetBindings() []*Binding {
	if m != nil {
		return m.Bindings
	}
	return nil
}

func (m *Policy) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

// Binding
//
// Bindings define the subjects that can access the resource a policy is attached to,
// and the conditions that need to be met for that access to be granted.
// A policy can have multiple bindings to configure different access controls for specific
// subjects.
type Binding struct {
	// A friendly name to identify the binding.
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// A detailed description of the purpose of the binding.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Bindings can be for HTTP or DB but not both.
	// If a policy must enforce HTTP and DB multiple bindings have to be added to the policy.
	//
	// Types that are valid to be assigned to Rule:
	//	*Binding_AllowHttp
	Rule isBinding_Rule `protobuf_oneof:"rule"`
	// Subjects configure the actors (end users, other services)  that are allowed to access the
	// target resource.
	From                 []*Subject `protobuf:"bytes,5,rep,name=from,proto3" json:"from,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Binding) Reset()         { *m = Binding{} }
func (m *Binding) String() string { return proto.CompactTextString(m) }
func (*Binding) ProtoMessage()    {}
func (*Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{1}
}
func (m *Binding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Binding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding.Merge(m, src)
}
func (m *Binding) XXX_Size() int {
	return m.Size()
}
func (m *Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Binding proto.InternalMessageInfo

type isBinding_Rule interface {
	isBinding_Rule()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Binding_AllowHttp struct {
	AllowHttp *Binding_HTTP_Rules `protobuf:"bytes,3,opt,name=allow_http,json=allowHttp,proto3,oneof"`
}

func (*Binding_AllowHttp) isBinding_Rule() {}

func (m *Binding) GetRule() isBinding_Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *Binding) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Binding) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Binding) GetAllowHttp() *Binding_HTTP_Rules {
	if x, ok := m.GetRule().(*Binding_AllowHttp); ok {
		return x.AllowHttp
	}
	return nil
}

func (m *Binding) GetFrom() []*Subject {
	if m != nil {
		return m.From
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Binding) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Binding_OneofMarshaler, _Binding_OneofUnmarshaler, _Binding_OneofSizer, []interface{}{
		(*Binding_AllowHttp)(nil),
	}
}

func _Binding_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Binding)
	// rule
	switch x := m.Rule.(type) {
	case *Binding_AllowHttp:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowHttp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Binding.Rule has unexpected type %T", x)
	}
	return nil
}

func _Binding_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Binding)
	switch tag {
	case 3: // rule.allow_http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Binding_HTTP_Rules)
		err := b.DecodeMessage(msg)
		m.Rule = &Binding_AllowHttp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Binding_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Binding)
	// rule
	switch x := m.Rule.(type) {
	case *Binding_AllowHttp:
		s := proto.Size(x.AllowHttp)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Binding_HTTP_Rules struct {
	// A set of HTTP rules that need to be satisfied by the HTTP requests to get access to the
	// target resource.
	To                   []*Binding_HTTP_Rules_Http `protobuf:"bytes,1,rep,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Binding_HTTP_Rules) Reset()         { *m = Binding_HTTP_Rules{} }
func (m *Binding_HTTP_Rules) String() string { return proto.CompactTextString(m) }
func (*Binding_HTTP_Rules) ProtoMessage()    {}
func (*Binding_HTTP_Rules) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{1, 0}
}
func (m *Binding_HTTP_Rules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Binding_HTTP_Rules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Binding_HTTP_Rules.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Binding_HTTP_Rules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding_HTTP_Rules.Merge(m, src)
}
func (m *Binding_HTTP_Rules) XXX_Size() int {
	return m.Size()
}
func (m *Binding_HTTP_Rules) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding_HTTP_Rules.DiscardUnknown(m)
}

var xxx_messageInfo_Binding_HTTP_Rules proto.InternalMessageInfo

func (m *Binding_HTTP_Rules) GetTo() []*Binding_HTTP_Rules_Http {
	if m != nil {
		return m.To
	}
	return nil
}

// HTTP Rule
//
// HTTP rules configure specific matching conditions on the HTTP requests made to the
// target resource. Access to the resource will only be allowed if all the conditions
// expressed in all the HTTP rules are met.
//
// All fields are optional, and only the relevant ones have to be configured.
type Binding_HTTP_Rules_Http struct {
	// When applying policies to applications, the hosts field can be used to restrict
	// the hosts each rule applies to. Applications can be exposed on multiple
	// hostnames in the corresponding load balancers, and rules may only target some of them.
	// E.g. ["bookinfo.com"].
	Hosts []string `protobuf:"bytes,1,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// The request path where the request is made against. E.g. ["/accounts"].
	Paths []string `protobuf:"bytes,2,rep,name=paths,proto3" json:"paths,omitempty"`
	// The HTTP methods that are allowed by this rule. E.g. ["GET", "HEAD"].
	Methods []string `protobuf:"bytes,3,rep,name=methods,proto3" json:"methods,omitempty"`
	// A set of request headers that are required in this rule.
	// Note that this set of headers is different than the headers that can be configured in
	// the subject, as these headers will only apply to the configured paths and other fields
	// in this HTTP rule.
	// E.g. "X-App-Id": "bookinfo".
	RequestHeaders map[string]string `protobuf:"bytes,4,rep,name=request_headers,json=requestHeaders,proto3" json:"request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The ports in the target service this rule will apply for. E.g. ["80", "443"].
	Ports                []int32  `protobuf:"varint,5,rep,packed,name=ports,proto3" json:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Binding_HTTP_Rules_Http) Reset()         { *m = Binding_HTTP_Rules_Http{} }
func (m *Binding_HTTP_Rules_Http) String() string { return proto.CompactTextString(m) }
func (*Binding_HTTP_Rules_Http) ProtoMessage()    {}
func (*Binding_HTTP_Rules_Http) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{1, 0, 0}
}
func (m *Binding_HTTP_Rules_Http) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Binding_HTTP_Rules_Http) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Binding_HTTP_Rules_Http.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Binding_HTTP_Rules_Http) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding_HTTP_Rules_Http.Merge(m, src)
}
func (m *Binding_HTTP_Rules_Http) XXX_Size() int {
	return m.Size()
}
func (m *Binding_HTTP_Rules_Http) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding_HTTP_Rules_Http.DiscardUnknown(m)
}

var xxx_messageInfo_Binding_HTTP_Rules_Http proto.InternalMessageInfo

func (m *Binding_HTTP_Rules_Http) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Binding_HTTP_Rules_Http) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *Binding_HTTP_Rules_Http) GetMethods() []string {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *Binding_HTTP_Rules_Http) GetRequestHeaders() map[string]string {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

func (m *Binding_HTTP_Rules_Http) GetPorts() []int32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Subject
//
// A subject designates an actor (user, service, etc) that attempts to access a target resource.
// Subjects can be modeled with JWT tokens, service accounts, and decorated with attributes such as
// HTTP request headers, JWT token claims, etc.
// The fields that define a subject will be matched to incoming requests, to fully qualify where the
// request comes from, and to decide if the given request is allowed or not for the target resource.
// All the fields in a subject are evaluated as AND expressions.
type Subject struct {
	// JWT configuration to identity the subject.
	Jwt *Subject_JWT `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	// Request headers used to qualify a subject.
	// E.g. "User-Agent": "Mozilla/*".
	RequestHeaders map[string]string `protobuf:"bytes,5,rep,name=request_headers,json=requestHeaders,proto3" json:"request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// TLS Identity
	//
	// Defines the identities that can access the targets of the AuthZ policy.
	// Identities can be expressed by providing:
	//   - The service accounts in `namespace/service-account-name` format.
	//   - A Subject Alternate Name (SAN). This will be directly checked against the SAN contained
	//     in the peer certificate.
	//
	// Types that are valid to be assigned to TlsIdentity:
	//	*Subject_ClusterLocalServiceAccount
	//	*Subject_SubjectAltName
	TlsIdentity          isSubject_TlsIdentity `protobuf_oneof:"tls_identity"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Subject) Reset()         { *m = Subject{} }
func (m *Subject) String() string { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()    {}
func (*Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{2}
}
func (m *Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject.Merge(m, src)
}
func (m *Subject) XXX_Size() int {
	return m.Size()
}
func (m *Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Subject proto.InternalMessageInfo

type isSubject_TlsIdentity interface {
	isSubject_TlsIdentity()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Subject_ClusterLocalServiceAccount struct {
	ClusterLocalServiceAccount string `protobuf:"bytes,6,opt,name=cluster_local_service_account,json=clusterLocalServiceAccount,proto3,oneof"`
}
type Subject_SubjectAltName struct {
	SubjectAltName string `protobuf:"bytes,7,opt,name=subject_alt_name,json=subjectAltName,proto3,oneof"`
}

func (*Subject_ClusterLocalServiceAccount) isSubject_TlsIdentity() {}
func (*Subject_SubjectAltName) isSubject_TlsIdentity()             {}

func (m *Subject) GetTlsIdentity() isSubject_TlsIdentity {
	if m != nil {
		return m.TlsIdentity
	}
	return nil
}

func (m *Subject) GetJwt() *Subject_JWT {
	if m != nil {
		return m.Jwt
	}
	return nil
}

func (m *Subject) GetRequestHeaders() map[string]string {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

func (m *Subject) GetClusterLocalServiceAccount() string {
	if x, ok := m.GetTlsIdentity().(*Subject_ClusterLocalServiceAccount); ok {
		return x.ClusterLocalServiceAccount
	}
	return ""
}

func (m *Subject) GetSubjectAltName() string {
	if x, ok := m.GetTlsIdentity().(*Subject_SubjectAltName); ok {
		return x.SubjectAltName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Subject) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Subject_OneofMarshaler, _Subject_OneofUnmarshaler, _Subject_OneofSizer, []interface{}{
		(*Subject_ClusterLocalServiceAccount)(nil),
		(*Subject_SubjectAltName)(nil),
	}
}

func _Subject_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Subject)
	// tls_identity
	switch x := m.TlsIdentity.(type) {
	case *Subject_ClusterLocalServiceAccount:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClusterLocalServiceAccount)
	case *Subject_SubjectAltName:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SubjectAltName)
	case nil:
	default:
		return fmt.Errorf("Subject.TlsIdentity has unexpected type %T", x)
	}
	return nil
}

func _Subject_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Subject)
	switch tag {
	case 6: // tls_identity.cluster_local_service_account
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.TlsIdentity = &Subject_ClusterLocalServiceAccount{x}
		return true, err
	case 7: // tls_identity.subject_alt_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.TlsIdentity = &Subject_SubjectAltName{x}
		return true, err
	default:
		return false, nil
	}
}

func _Subject_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Subject)
	// tls_identity
	switch x := m.TlsIdentity.(type) {
	case *Subject_ClusterLocalServiceAccount:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ClusterLocalServiceAccount)))
		n += len(x.ClusterLocalServiceAccount)
	case *Subject_SubjectAltName:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.SubjectAltName)))
		n += len(x.SubjectAltName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// JWT based subject
//
// JWT based subjects qualify a subject by matching against a JWT token present in the request.
// By default the token is expected to be present in the 'Authorization' HTTP header, with the
// 'Bearer" prefix.
type Subject_JWT struct {
	// The principal qualifies the authority under which the request is made.
	// In Istio environments this is the value of the Issuer claim (iss) concatenated with the
	// value of teh Subject (sub) claim, separated with a '/'.
	Principal string `protobuf:"bytes,1,opt,name=principal,proto3" json:"principal,omitempty"`
	// Audience intended for the token. This is the value of the 'aud' claim.
	Audience string `protobuf:"bytes,2,opt,name=audience,proto3" json:"audience,omitempty"`
	// The authorized presenter of the token. This takes the value of the 'azp' claim.
	Presenter string `protobuf:"bytes,3,opt,name=presenter,proto3" json:"presenter,omitempty"`
	// A set of arbitrary claims that are required to qualify the subject.
	// E.g. "iss": "*@foo.com".
	Claims map[string]string `protobuf:"bytes,4,rep,name=claims,proto3" json:"claims,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Configuration to validate the JWT tokens for this subject.
	Validation           *Subject_JWT_Validation `protobuf:"bytes,5,opt,name=validation,proto3" json:"validation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Subject_JWT) Reset()         { *m = Subject_JWT{} }
func (m *Subject_JWT) String() string { return proto.CompactTextString(m) }
func (*Subject_JWT) ProtoMessage()    {}
func (*Subject_JWT) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{2, 0}
}
func (m *Subject_JWT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject_JWT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject_JWT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject_JWT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject_JWT.Merge(m, src)
}
func (m *Subject_JWT) XXX_Size() int {
	return m.Size()
}
func (m *Subject_JWT) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject_JWT.DiscardUnknown(m)
}

var xxx_messageInfo_Subject_JWT proto.InternalMessageInfo

func (m *Subject_JWT) GetPrincipal() string {
	if m != nil {
		return m.Principal
	}
	return ""
}

func (m *Subject_JWT) GetAudience() string {
	if m != nil {
		return m.Audience
	}
	return ""
}

func (m *Subject_JWT) GetPresenter() string {
	if m != nil {
		return m.Presenter
	}
	return ""
}

func (m *Subject_JWT) GetClaims() map[string]string {
	if m != nil {
		return m.Claims
	}
	return nil
}

func (m *Subject_JWT) GetValidation() *Subject_JWT_Validation {
	if m != nil {
		return m.Validation
	}
	return nil
}

type Subject_JWT_Validation struct {
	// The issuer that is expected for this JWT subject.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// Optional audiences to validate the JWT token against.
	Audiences []string `protobuf:"bytes,2,rep,name=audiences,proto3" json:"audiences,omitempty"`
	// Types that are valid to be assigned to Keys:
	//	*Subject_JWT_Validation_JwksUri
	//	*Subject_JWT_Validation_Jwks
	Keys                 isSubject_JWT_Validation_Keys `protobuf_oneof:"keys"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Subject_JWT_Validation) Reset()         { *m = Subject_JWT_Validation{} }
func (m *Subject_JWT_Validation) String() string { return proto.CompactTextString(m) }
func (*Subject_JWT_Validation) ProtoMessage()    {}
func (*Subject_JWT_Validation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b30dada73a254d2, []int{2, 0, 1}
}
func (m *Subject_JWT_Validation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject_JWT_Validation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject_JWT_Validation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject_JWT_Validation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject_JWT_Validation.Merge(m, src)
}
func (m *Subject_JWT_Validation) XXX_Size() int {
	return m.Size()
}
func (m *Subject_JWT_Validation) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject_JWT_Validation.DiscardUnknown(m)
}

var xxx_messageInfo_Subject_JWT_Validation proto.InternalMessageInfo

type isSubject_JWT_Validation_Keys interface {
	isSubject_JWT_Validation_Keys()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Subject_JWT_Validation_JwksUri struct {
	JwksUri string `protobuf:"bytes,3,opt,name=jwksUri,proto3,oneof"`
}
type Subject_JWT_Validation_Jwks struct {
	Jwks string `protobuf:"bytes,4,opt,name=jwks,proto3,oneof"`
}

func (*Subject_JWT_Validation_JwksUri) isSubject_JWT_Validation_Keys() {}
func (*Subject_JWT_Validation_Jwks) isSubject_JWT_Validation_Keys()    {}

func (m *Subject_JWT_Validation) GetKeys() isSubject_JWT_Validation_Keys {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Subject_JWT_Validation) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *Subject_JWT_Validation) GetAudiences() []string {
	if m != nil {
		return m.Audiences
	}
	return nil
}

func (m *Subject_JWT_Validation) GetJwksUri() string {
	if x, ok := m.GetKeys().(*Subject_JWT_Validation_JwksUri); ok {
		return x.JwksUri
	}
	return ""
}

func (m *Subject_JWT_Validation) GetJwks() string {
	if x, ok := m.GetKeys().(*Subject_JWT_Validation_Jwks); ok {
		return x.Jwks
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Subject_JWT_Validation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Subject_JWT_Validation_OneofMarshaler, _Subject_JWT_Validation_OneofUnmarshaler, _Subject_JWT_Validation_OneofSizer, []interface{}{
		(*Subject_JWT_Validation_JwksUri)(nil),
		(*Subject_JWT_Validation_Jwks)(nil),
	}
}

func _Subject_JWT_Validation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Subject_JWT_Validation)
	// keys
	switch x := m.Keys.(type) {
	case *Subject_JWT_Validation_JwksUri:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.JwksUri)
	case *Subject_JWT_Validation_Jwks:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Jwks)
	case nil:
	default:
		return fmt.Errorf("Subject_JWT_Validation.Keys has unexpected type %T", x)
	}
	return nil
}

func _Subject_JWT_Validation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Subject_JWT_Validation)
	switch tag {
	case 3: // keys.jwksUri
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Keys = &Subject_JWT_Validation_JwksUri{x}
		return true, err
	case 4: // keys.jwks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Keys = &Subject_JWT_Validation_Jwks{x}
		return true, err
	default:
		return false, nil
	}
}

func _Subject_JWT_Validation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Subject_JWT_Validation)
	// keys
	switch x := m.Keys.(type) {
	case *Subject_JWT_Validation_JwksUri:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.JwksUri)))
		n += len(x.JwksUri)
	case *Subject_JWT_Validation_Jwks:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Jwks)))
		n += len(x.Jwks)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Policy)(nil), "tetrate.api.authz.v1.Policy")
	proto.RegisterType((*Binding)(nil), "tetrate.api.authz.v1.Binding")
	proto.RegisterType((*Binding_HTTP_Rules)(nil), "tetrate.api.authz.v1.Binding.HTTP_Rules")
	proto.RegisterType((*Binding_HTTP_Rules_Http)(nil), "tetrate.api.authz.v1.Binding.HTTP_Rules.Http")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.authz.v1.Binding.HTTP_Rules.Http.RequestHeadersEntry")
	proto.RegisterType((*Subject)(nil), "tetrate.api.authz.v1.Subject")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.authz.v1.Subject.RequestHeadersEntry")
	proto.RegisterType((*Subject_JWT)(nil), "tetrate.api.authz.v1.Subject.JWT")
	proto.RegisterMapType((map[string]string)(nil), "tetrate.api.authz.v1.Subject.JWT.ClaimsEntry")
	proto.RegisterType((*Subject_JWT_Validation)(nil), "tetrate.api.authz.v1.Subject.JWT.Validation")
}

func init() { proto.RegisterFile("authz.proto", fileDescriptor_6b30dada73a254d2) }

var fileDescriptor_6b30dada73a254d2 = []byte{
	// 876 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x41, 0x6f, 0xe3, 0xc4,
	0x17, 0xcf, 0xc4, 0x8e, 0xd3, 0xbc, 0xec, 0xbf, 0xff, 0x68, 0xa8, 0x84, 0xb1, 0xd8, 0xd2, 0x8d,
	0x2a, 0x14, 0xa0, 0xeb, 0xd0, 0xac, 0x10, 0xec, 0x4a, 0x1c, 0x92, 0xdd, 0x08, 0xef, 0x6a, 0xb5,
	0x8d, 0xa6, 0x2e, 0x45, 0x20, 0x6a, 0x4d, 0x9d, 0xa1, 0x99, 0xd6, 0xb1, 0xcd, 0xcc, 0x38, 0x55,
	0x56, 0x9c, 0x11, 0xe2, 0x46, 0x8f, 0x7c, 0x08, 0x3e, 0x00, 0x27, 0xb8, 0x71, 0xe4, 0x1b, 0x80,
	0x7a, 0xe3, 0x2b, 0x70, 0x59, 0x64, 0x8f, 0xd3, 0x16, 0x5a, 0xba, 0x2c, 0xe2, 0x12, 0x3d, 0xcf,
	0xfb, 0xbd, 0xdf, 0xbc, 0xf7, 0x7b, 0xef, 0x4d, 0xa0, 0x49, 0x33, 0x35, 0x79, 0xea, 0xa6, 0x22,
	0x51, 0x09, 0x5e, 0x51, 0x4c, 0x09, 0xaa, 0x98, 0x4b, 0x53, 0xee, 0x6a, 0xc7, 0x6c, 0xd3, 0x79,
	0x79, 0x46, 0x23, 0x3e, 0xa6, 0x8a, 0x75, 0x17, 0x86, 0x86, 0xb7, 0x77, 0xc1, 0x1a, 0x25, 0x11,
	0x0f, 0xe7, 0xf8, 0x2e, 0x2c, 0xed, 0xf3, 0x78, 0xcc, 0xe3, 0x03, 0x69, 0xa3, 0x35, 0xa3, 0xd3,
	0xec, 0xdd, 0x74, 0xaf, 0xe2, 0x72, 0x07, 0x1a, 0x45, 0xce, 0xe0, 0x18, 0x83, 0xc9, 0x14, 0x3d,
	0xb0, 0xab, 0x6b, 0xa8, 0xd3, 0x20, 0x85, 0xdd, 0xfe, 0xb1, 0x06, 0xf5, 0x12, 0x89, 0x37, 0xe0,
	0xc6, 0x98, 0xcb, 0x34, 0xa2, 0xf3, 0x20, 0xa6, 0x53, 0x66, 0xa3, 0x1c, 0x37, 0x68, 0x7c, 0xff,
	0xdb, 0x0f, 0x86, 0x29, 0xaa, 0x2d, 0x44, 0x9a, 0xa5, 0xfb, 0x09, 0x9d, 0x32, 0xbc, 0x06, 0xcd,
	0x31, 0x93, 0xa1, 0xe0, 0xa9, 0xe2, 0x49, 0x5c, 0x92, 0x5e, 0x3c, 0xc2, 0x0f, 0x01, 0x68, 0x14,
	0x25, 0xc7, 0xc1, 0x44, 0xa9, 0xd4, 0x36, 0xd6, 0x50, 0xa7, 0xd9, 0xeb, 0x5c, 0x9b, 0xac, 0xeb,
	0xf9, 0xfe, 0x28, 0x20, 0x59, 0xc4, 0xa4, 0x57, 0x21, 0x8d, 0x22, 0xda, 0x53, 0x2a, 0xc5, 0x9b,
	0x60, 0x7e, 0x26, 0x92, 0xa9, 0x5d, 0xbb, 0xae, 0xe2, 0xed, 0x6c, 0xff, 0x90, 0x85, 0x8a, 0x14,
	0x50, 0xe7, 0x17, 0x03, 0xe0, 0x9c, 0x0e, 0xbf, 0x0f, 0x55, 0x95, 0x94, 0x8a, 0xdd, 0xfe, 0xa7,
	0x49, 0xb8, 0xf9, 0xe5, 0xa4, 0xaa, 0x12, 0xe7, 0x1b, 0x03, 0xcc, 0x22, 0x93, 0x75, 0xa8, 0x4d,
	0x12, 0xa9, 0xb4, 0xf8, 0x8d, 0xc1, 0x72, 0xae, 0x4e, 0xe3, 0x04, 0x59, 0x6d, 0x53, 0x54, 0x27,
	0x88, 0x68, 0x67, 0x8e, 0x4a, 0xa9, 0x9a, 0x48, 0xbb, 0x7a, 0x19, 0xd5, 0x42, 0x44, 0x3b, 0xb1,
	0x0f, 0xf5, 0x29, 0x53, 0x93, 0x64, 0x2c, 0x6d, 0xa3, 0xc0, 0xdd, 0xcb, 0x71, 0xef, 0x9c, 0xa0,
	0x5e, 0xfb, 0x6d, 0xe1, 0x12, 0xe3, 0x83, 0xa1, 0x4f, 0x4c, 0x6f, 0xd8, 0x7f, 0x40, 0xcc, 0xd1,
	0xd6, 0xb6, 0x4f, 0x8c, 0xd1, 0x8e, 0x4f, 0x6a, 0xa3, 0xbe, 0x7f, 0xdf, 0x23, 0xd6, 0x83, 0xe1,
	0xe3, 0xa1, 0x3f, 0x24, 0xf5, 0xad, 0x91, 0xff, 0x70, 0xeb, 0xc9, 0x36, 0x59, 0x50, 0xe1, 0xa7,
	0xf0, 0x7f, 0xc1, 0x3e, 0xcf, 0x98, 0x54, 0xc1, 0x84, 0xd1, 0x31, 0x13, 0xd2, 0x36, 0x8b, 0xb2,
	0xfb, 0x2f, 0x54, 0xb6, 0x4b, 0x34, 0x89, 0xa7, 0x39, 0x86, 0xb1, 0x12, 0xf3, 0xb2, 0x90, 0x6f,
	0xcf, 0x0a, 0x59, 0x16, 0x7f, 0x02, 0xe1, 0x0e, 0xd4, 0xd2, 0x44, 0x28, 0x59, 0x34, 0xaa, 0x36,
	0xc0, 0x39, 0xfc, 0x7f, 0x27, 0x08, 0xda, 0x4b, 0x8e, 0x65, 0x3f, 0x7b, 0x66, 0x74, 0x2a, 0x44,
	0x03, 0x9c, 0x3e, 0xbc, 0x74, 0xc5, 0x05, 0xb8, 0x05, 0xc6, 0x11, 0x9b, 0xeb, 0xd1, 0x23, 0xb9,
	0x89, 0x57, 0xa0, 0x36, 0xa3, 0x51, 0xc6, 0xca, 0x09, 0xd3, 0x1f, 0xf7, 0xaa, 0xef, 0xa1, 0x81,
	0x05, 0xa6, 0xc8, 0x22, 0xd6, 0xfe, 0xb2, 0x0e, 0xf5, 0xb2, 0xf7, 0xf8, 0x0e, 0x18, 0x87, 0xc7,
	0xaa, 0x88, 0x6f, 0xf6, 0x6e, 0x5d, 0x3b, 0x27, 0xee, 0xa3, 0x5d, 0x9f, 0xe4, 0x68, 0x7c, 0x78,
	0x59, 0x31, 0x3d, 0x68, 0x9b, 0xd7, 0x13, 0xfc, 0x1b, 0x85, 0xf6, 0xe0, 0x66, 0x18, 0x65, 0x52,
	0x31, 0x11, 0x44, 0x49, 0x48, 0xa3, 0x40, 0x32, 0x31, 0xe3, 0x21, 0x0b, 0x68, 0x18, 0x26, 0x59,
	0xac, 0x6c, 0xab, 0xd8, 0xba, 0x57, 0x72, 0x9a, 0x15, 0x81, 0x7b, 0xad, 0xbd, 0xf5, 0x2f, 0xf6,
	0x3e, 0xd9, 0xeb, 0x7e, 0xfa, 0x56, 0xb7, 0xf8, 0x5d, 0xf7, 0x2a, 0xc4, 0x29, 0x19, 0x1e, 0xe7,
	0x04, 0xdb, 0x3a, 0xbe, 0xaf, 0xc3, 0xf1, 0x9b, 0xd0, 0x92, 0x3a, 0xbd, 0x80, 0x46, 0x4a, 0x2f,
	0x72, 0x3d, 0xa7, 0xf4, 0x2a, 0x64, 0xb9, 0xf4, 0xf4, 0x23, 0x95, 0xaf, 0xb0, 0xf3, 0xbb, 0x01,
	0xc6, 0xa3, 0x5d, 0x1f, 0xbf, 0x0a, 0x8d, 0x54, 0xf0, 0x38, 0xe4, 0x29, 0x8d, 0x4a, 0xe9, 0xcf,
	0x0f, 0xb0, 0x03, 0x4b, 0x34, 0x1b, 0x73, 0x16, 0x87, 0x8b, 0x1e, 0x9c, 0x7d, 0xeb, 0x48, 0x26,
	0x59, 0xac, 0x98, 0x28, 0x36, 0xbc, 0x88, 0x2c, 0x0f, 0xf0, 0x0e, 0x58, 0x61, 0x44, 0xf9, 0x74,
	0x31, 0x80, 0xb7, 0x9f, 0xdb, 0x0f, 0xf7, 0x7e, 0x81, 0xbf, 0x5a, 0xca, 0x92, 0x0c, 0x7f, 0x04,
	0x50, 0x3e, 0x8f, 0xf9, 0xc3, 0x53, 0x2b, 0x5a, 0xbd, 0xf1, 0x7c, 0xea, 0x0f, 0xcf, 0x62, 0x06,
	0x90, 0x33, 0xd7, 0xbe, 0x46, 0x39, 0xeb, 0x05, 0x2e, 0xe7, 0x2e, 0x34, 0x2f, 0x24, 0xf0, 0x22,
	0xc3, 0xe8, 0x7c, 0x87, 0x00, 0xce, 0x6f, 0xc0, 0xb7, 0xc0, 0xe2, 0x52, 0x66, 0x4c, 0x5c, 0x7e,
	0x45, 0x4b, 0x07, 0xde, 0x80, 0xc6, 0x42, 0xc7, 0xbf, 0x7b, 0x27, 0xce, 0x01, 0xf8, 0x75, 0xa8,
	0x1f, 0x1e, 0x1f, 0xc9, 0x1d, 0xc1, 0xb5, 0xce, 0x65, 0x0d, 0xc2, 0xf8, 0x0a, 0x21, 0xaf, 0x42,
	0x16, 0x4e, 0xfc, 0x1a, 0x98, 0xb9, 0x69, 0x9b, 0x7f, 0xb9, 0xd6, 0xab, 0x90, 0xc2, 0x91, 0x6f,
	0xcd, 0x11, 0x9b, 0xff, 0x27, 0x0b, 0xb8, 0x0c, 0x37, 0x54, 0x24, 0x03, 0x3e, 0x66, 0xb1, 0xe2,
	0x6a, 0x3e, 0x78, 0xf7, 0xa7, 0xd3, 0x55, 0xf4, 0xf3, 0xe9, 0x2a, 0xfa, 0xf5, 0x74, 0x15, 0x7d,
	0xfc, 0xc6, 0x01, 0x57, 0x93, 0x6c, 0xdf, 0x0d, 0x93, 0x69, 0xb7, 0x6c, 0x0e, 0x4f, 0x16, 0x56,
	0x97, 0xa6, 0xbc, 0x5b, 0xb4, 0xa9, 0x3b, 0xdb, 0xdc, 0xb7, 0x8a, 0x7f, 0xb9, 0x3b, 0x7f, 0x04,
	0x00, 0x00, 0xff, 0xff, 0x27, 0x6e, 0xa8, 0xe2, 0x23, 0x07, 0x00, 0x00,
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Etag) > 0 {
		i -= len(m.Etag)
		copy(dAtA[i:], m.Etag)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Etag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bindings) > 0 {
		for iNdEx := len(m.Bindings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bindings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthz(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Binding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Binding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Binding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.From) > 0 {
		for iNdEx := len(m.From) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.From[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthz(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Rule != nil {
		{
			size := m.Rule.Size()
			i -= size
			if _, err := m.Rule.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Binding_AllowHttp) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Binding_AllowHttp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowHttp != nil {
		{
			size, err := m.AllowHttp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthz(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Binding_HTTP_Rules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Binding_HTTP_Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Binding_HTTP_Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.To) > 0 {
		for iNdEx := len(m.To) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.To[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthz(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Binding_HTTP_Rules_Http) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Binding_HTTP_Rules_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Binding_HTTP_Rules_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ports) > 0 {
		dAtA3 := make([]byte, len(m.Ports)*10)
		var j2 int
		for _, num1 := range m.Ports {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintAuthz(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RequestHeaders) > 0 {
		for k := range m.RequestHeaders {
			v := m.RequestHeaders[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthz(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthz(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthz(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Methods[iNdEx])
			copy(dAtA[i:], m.Methods[iNdEx])
			i = encodeVarintAuthz(dAtA, i, uint64(len(m.Methods[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintAuthz(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintAuthz(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TlsIdentity != nil {
		{
			size := m.TlsIdentity.Size()
			i -= size
			if _, err := m.TlsIdentity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.RequestHeaders) > 0 {
		for k := range m.RequestHeaders {
			v := m.RequestHeaders[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthz(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthz(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthz(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Jwt != nil {
		{
			size, err := m.Jwt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthz(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subject_ClusterLocalServiceAccount) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Subject_ClusterLocalServiceAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterLocalServiceAccount)
	copy(dAtA[i:], m.ClusterLocalServiceAccount)
	i = encodeVarintAuthz(dAtA, i, uint64(len(m.ClusterLocalServiceAccount)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *Subject_SubjectAltName) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Subject_SubjectAltName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SubjectAltName)
	copy(dAtA[i:], m.SubjectAltName)
	i = encodeVarintAuthz(dAtA, i, uint64(len(m.SubjectAltName)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Subject_JWT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject_JWT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_JWT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Validation != nil {
		{
			size, err := m.Validation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthz(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Claims) > 0 {
		for k := range m.Claims {
			v := m.Claims[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthz(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthz(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthz(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Presenter) > 0 {
		i -= len(m.Presenter)
		copy(dAtA[i:], m.Presenter)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Presenter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Audience) > 0 {
		i -= len(m.Audience)
		copy(dAtA[i:], m.Audience)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Audience)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Principal) > 0 {
		i -= len(m.Principal)
		copy(dAtA[i:], m.Principal)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Principal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subject_JWT_Validation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject_JWT_Validation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_JWT_Validation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keys != nil {
		{
			size := m.Keys.Size()
			i -= size
			if _, err := m.Keys.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Audiences) > 0 {
		for iNdEx := len(m.Audiences) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Audiences[iNdEx])
			copy(dAtA[i:], m.Audiences[iNdEx])
			i = encodeVarintAuthz(dAtA, i, uint64(len(m.Audiences[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintAuthz(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subject_JWT_Validation_JwksUri) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Subject_JWT_Validation_JwksUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.JwksUri)
	copy(dAtA[i:], m.JwksUri)
	i = encodeVarintAuthz(dAtA, i, uint64(len(m.JwksUri)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Subject_JWT_Validation_Jwks) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Subject_JWT_Validation_Jwks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jwks)
	copy(dAtA[i:], m.Jwks)
	i = encodeVarintAuthz(dAtA, i, uint64(len(m.Jwks)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func encodeVarintAuthz(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthz(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bindings) > 0 {
		for _, e := range m.Bindings {
			l = e.Size()
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Binding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	if m.Rule != nil {
		n += m.Rule.Size()
	}
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Binding_AllowHttp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowHttp != nil {
		l = m.AllowHttp.Size()
		n += 1 + l + sovAuthz(uint64(l))
	}
	return n
}
func (m *Binding_HTTP_Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.To) > 0 {
		for _, e := range m.To {
			l = e.Size()
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Binding_HTTP_Rules_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if len(m.Methods) > 0 {
		for _, s := range m.Methods {
			l = len(s)
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if len(m.RequestHeaders) > 0 {
		for k, v := range m.RequestHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthz(uint64(len(k))) + 1 + len(v) + sovAuthz(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthz(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		l = 0
		for _, e := range m.Ports {
			l += sovAuthz(uint64(e))
		}
		n += 1 + sovAuthz(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jwt != nil {
		l = m.Jwt.Size()
		n += 1 + l + sovAuthz(uint64(l))
	}
	if len(m.RequestHeaders) > 0 {
		for k, v := range m.RequestHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthz(uint64(len(k))) + 1 + len(v) + sovAuthz(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthz(uint64(mapEntrySize))
		}
	}
	if m.TlsIdentity != nil {
		n += m.TlsIdentity.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject_ClusterLocalServiceAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterLocalServiceAccount)
	n += 1 + l + sovAuthz(uint64(l))
	return n
}
func (m *Subject_SubjectAltName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubjectAltName)
	n += 1 + l + sovAuthz(uint64(l))
	return n
}
func (m *Subject_JWT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Principal)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	l = len(m.Presenter)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	if len(m.Claims) > 0 {
		for k, v := range m.Claims {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthz(uint64(len(k))) + 1 + len(v) + sovAuthz(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthz(uint64(mapEntrySize))
		}
	}
	if m.Validation != nil {
		l = m.Validation.Size()
		n += 1 + l + sovAuthz(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject_JWT_Validation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovAuthz(uint64(l))
	}
	if len(m.Audiences) > 0 {
		for _, s := range m.Audiences {
			l = len(s)
			n += 1 + l + sovAuthz(uint64(l))
		}
	}
	if m.Keys != nil {
		n += m.Keys.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject_JWT_Validation_JwksUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JwksUri)
	n += 1 + l + sovAuthz(uint64(l))
	return n
}
func (m *Subject_JWT_Validation_Jwks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jwks)
	n += 1 + l + sovAuthz(uint64(l))
	return n
}

func sovAuthz(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthz(x uint64) (n int) {
	return sovAuthz(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bindings = append(m.Bindings, &Binding{})
			if err := m.Bindings[len(m.Bindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Binding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHttp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Binding_HTTP_Rules{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Rule = &Binding_AllowHttp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &Subject{})
			if err := m.From[len(m.From)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Binding_HTTP_Rules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTP_Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTP_Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To, &Binding_HTTP_Rules_Http{})
			if err := m.To[len(m.To)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Binding_HTTP_Rules_Http) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Http: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Http: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestHeaders == nil {
				m.RequestHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthz(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAuthz
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuthz
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAuthz
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ports) == 0 {
					m.Ports = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jwt == nil {
				m.Jwt = &Subject_JWT{}
			}
			if err := m.Jwt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestHeaders == nil {
				m.RequestHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthz(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAuthz
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLocalServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsIdentity = &Subject_ClusterLocalServiceAccount{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsIdentity = &Subject_SubjectAltName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject_JWT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JWT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JWT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Principal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Presenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Claims == nil {
				m.Claims = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthz
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthz(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAuthz
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Claims[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validation == nil {
				m.Validation = &Subject_JWT_Validation{}
			}
			if err := m.Validation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject_JWT_Validation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audiences", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audiences = append(m.Audiences, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwksUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = &Subject_JWT_Validation_JwksUri{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = &Subject_JWT_Validation_Jwks{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthz(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthz
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthz
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthz
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAuthz
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuthz
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuthz(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAuthz
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuthz = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthz   = fmt.Errorf("proto: integer overflow")
)
